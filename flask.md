- [How To Create Your First Web Application Using Flask and Python 3](#how-to-create-your-first-web-application-using-flask-and-python-3)
  - [Introduction](#introduction)
- [Prerequisites](#prerequisites)
- [Step 1 — Installing Flask](#step-1--installing-flask)
- [Step 2 — Creating a Simple Application](#step-2--creating-a-simple-application)
- [Step 3 — Running the Application](#step-3--running-the-application)
- [Step 4 — Routes and View Functions](#step-4--routes-and-view-functions)
- [Step 5 — Dynamic Routes](#step-5--dynamic-routes)
- [Step 6 — Debugging A Flask Application](#step-6--debugging-a-flask-application)
- [Conclusion](#conclusion)
- [How To Use Templates in a Flask Application](#how-to-use-templates-in-a-flask-application)
  - [Introduction](#introduction-1)
- [Prerequisites](#prerequisites-1)
- [Step 1 — Rendering a Template and Using Variables](#step-1--rendering-a-template-and-using-variables)
- [Step 2 — Using Template Inheritance](#step-2--using-template-inheritance)
- [Step 3 — Linking between Pages](#step-3--linking-between-pages)
- [Step 4 — Using Conditionals and Loops](#step-4--using-conditionals-and-loops)
- [Step 5 — Using Filters](#step-5--using-filters)
- [Step 6 — Integrating Bootstrap](#step-6--integrating-bootstrap)
- [Conclusion](#conclusion-1)
- [How To Handle Errors in a Flask Application](#how-to-handle-errors-in-a-flask-application)
  - [Introduction](#introduction-2)
- [Prerequisites](#prerequisites-2)
- [Step 1 — Using The Flask Debugger](#step-1--using-the-flask-debugger)
- [Step 2 — Creating Custom Error Pages](#step-2--creating-custom-error-pages)
- [Step 3 — Using Logging to Track Events in Your Application](#step-3--using-logging-to-track-events-in-your-application)
- [Conclusion](#conclusion-2)
- [How To Use Web Forms in a Flask Application](#how-to-use-web-forms-in-a-flask-application)
  - [Introduction](#introduction-3)
- [Prerequisites](#prerequisites-3)
- [Step 1 — Displaying Messages](#step-1--displaying-messages)
- [Step 2 — Setting Up Forms](#step-2--setting-up-forms)
- [Step 3 — Handling Form Requests](#step-3--handling-form-requests)
- [Conclusion](#conclusion-3)
- [How To Use and Validate Web Forms with Flask-WTF](#how-to-use-and-validate-web-forms-with-flask-wtf)
  - [Introduction](#introduction-4)
- [Prerequisites](#prerequisites-4)
- [Step 1 — Installing Flask and Flask-WTF](#step-1--installing-flask-and-flask-wtf)
- [Step 2 — Setting up Forms](#step-2--setting-up-forms-1)
- [Step 3 — Displaying the Web Form and Courses](#step-3--displaying-the-web-form-and-courses)
- [Step 4 — Accessing Form Data](#step-4--accessing-form-data)
- [Conclusion](#conclusion-4)
- [How To Use an SQLite Database in a Flask Application](#how-to-use-an-sqlite-database-in-a-flask-application)
  - [Introduction](#introduction-5)
- [Prerequisites](#prerequisites-5)
- [Step 1 — Setting up the Database](#step-1--setting-up-the-database)
- [Step 2 — Displaying Posts](#step-2--displaying-posts)
- [Step 3 — Creating Posts](#step-3--creating-posts)
- [Step 4 — Editing Posts](#step-4--editing-posts)
- [Step 5 — Deleting Posts](#step-5--deleting-posts)
- [Conclusion](#conclusion-5)
- [How To Use a PostgreSQL Database in a Flask Application](#how-to-use-a-postgresql-database-in-a-flask-application)
  - [Introduction](#introduction-6)
- [Prerequisites](#prerequisites-6)
- [Step 1 — Creating the PostgreSQL Database and User](#step-1--creating-the-postgresql-database-and-user)
- [Step 2 — Installing Flask and psycopg2](#step-2--installing-flask-and-psycopg2)
- [Step 3 — Setting up a Database](#step-3--setting-up-a-database)
- [Step 4 — Displaying Books](#step-4--displaying-books)
- [Step 5 — Adding New Books](#step-5--adding-new-books)
- [Conclusion](#conclusion-6)
- [How To Use MongoDB in a Flask Application](#how-to-use-mongodb-in-a-flask-application)
  - [Introduction](#introduction-7)
- [Prerequisites](#prerequisites-7)
- [Step 1 — Setting Up PyMongo and Flask](#step-1--setting-up-pymongo-and-flask)
- [Step 2 — Connecting to the MongoDB Server and Creating a Collection](#step-2--connecting-to-the-mongodb-server-and-creating-a-collection)
- [Step 3 — Creating a Web Page for Adding and Displaying Todos](#step-3--creating-a-web-page-for-adding-and-displaying-todos)
- [Step 4 — Deleting Todos](#step-4--deleting-todos)
- [Conclusion](#conclusion-7)
- [How to Use Flask-SQLAlchemy to Interact with Databases in a Flask Application](#how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application)
  - [Introduction](#introduction-8)
- [Prerequisites](#prerequisites-8)
- [Step 1 — Installing Flask and Flask-SQLAlchemy](#step-1--installing-flask-and-flask-sqlalchemy)
- [Step 2 — Setting up the Database and Model](#step-2--setting-up-the-database-and-model)
  - [Setting up The Database Connection](#setting-up-the-database-connection)
  - [Declaring The Table](#declaring-the-table)
  - [Creating the Database](#creating-the-database)
  - [Populating the Table](#populating-the-table)
- [Step 3 — Displaying All Records](#step-3--displaying-all-records)
- [Step 4 — Displaying a Single Record](#step-4--displaying-a-single-record)
- [Step 5 — Creating a New Record](#step-5--creating-a-new-record)
- [Step 6 — Editing a Record](#step-6--editing-a-record)
- [Step 7 — Deleting a Record](#step-7--deleting-a-record)
- [Conclusion](#conclusion-8)
- [How to Use One-to-Many Database Relationships with Flask-SQLAlchemy](#how-to-use-one-to-many-database-relationships-with-flask-sqlalchemy)
  - [Introduction](#introduction-9)
- [Prerequisites](#prerequisites-9)
- [Step 1 — Installing Flask and Flask-SQLAlchemy](#step-1--installing-flask-and-flask-sqlalchemy-1)
- [Step 2 — Setting up the Database and Models](#step-2--setting-up-the-database-and-models)
  - [Setting up The Database Connection](#setting-up-the-database-connection-1)
  - [Declaring The Tables](#declaring-the-tables)
  - [Creating the Database](#creating-the-database-1)
  - [Populating the Tables](#populating-the-tables)
- [Step 3 — Displaying All Posts](#step-3--displaying-all-posts)
- [Step 4 — Displaying a Single Post and its Comments](#step-4--displaying-a-single-post-and-its-comments)
- [Step 5 — Adding New Comments](#step-5--adding-new-comments)
- [Step 6 — Displaying All Comments](#step-6--displaying-all-comments)
- [Step 7 — Deleting Comments](#step-7--deleting-comments)
- [Conclusion](#conclusion-9)
- [How To Use Many-to-Many Database Relationships with Flask-SQLAlchemy](#how-to-use-many-to-many-database-relationships-with-flask-sqlalchemy)
  - [Introduction](#introduction-10)
- [Prerequisites](#prerequisites-10)
- [Step 1 — Setting Up the Web Application](#step-1--setting-up-the-web-application)
- [Step 2 — Setting up Database Models for a Many-to-Many Relationship](#step-2--setting-up-database-models-for-a-many-to-many-relationship)
- [Step 3 — Managing Data in a Many-to-Many Relationship](#step-3--managing-data-in-a-many-to-many-relationship)
- [Step 4 — Displaying Tags Under Each Post](#step-4--displaying-tags-under-each-post)
- [Step 5 — Displaying Tags and Their Posts](#step-5--displaying-tags-and-their-posts)
- [Conclusion](#conclusion-10)
- [How To Query Tables and Paginate Data in Flask-SQLAlchemy](#how-to-query-tables-and-paginate-data-in-flask-sqlalchemy)
  - [Introduction](#introduction-11)
- [Prerequisites](#prerequisites-11)
- [Step 1 — Setting up the Database and Model](#step-1--setting-up-the-database-and-model)
- [Step 2 — Querying Records](#step-2--querying-records)
  - [Retrieving All Records](#retrieving-all-records)
  - [Retrieving the First Record](#retrieving-the-first-record)
  - [Retrieving a Record by ID](#retrieving-a-record-by-id)
  - [Retrieving a Record or Multiple Records by a Column Value](#retrieving-a-record-or-multiple-records-by-a-column-value)
- [Step 3 — Filtering Records Using Logical Conditions](#step-3--filtering-records-using-logical-conditions)
  - [Equals](#equals)
  - [Not Equals](#not-equals)
  - [Less Than](#less-than)
  - [Greater Than](#greater-than)
  - [In](#in)
  - [Not In](#not-in)
  - [And](#and)
  - [Or](#or)
- [Step 4 — Ordering, Limiting, and Counting Results](#step-4--ordering-limiting-and-counting-results)
  - [Ordering Results](#ordering-results)
  - [Limiting Results](#limiting-results)
  - [Counting Results](#counting-results)
- [Step 5 — Displaying Long Record Lists on Multiple Pages](#step-5--displaying-long-record-lists-on-multiple-pages)
- [Conclusion](#conclusion-11)
- [How To Structure a Large Flask Application with Flask Blueprints and Flask-SQLAlchemy](#how-to-structure-a-large-flask-application-with-flask-blueprints-and-flask-sqlalchemy)
  - [Introduction](#introduction-12)
- [Prerequisites](#prerequisites-12)
- [The Target Application Structure](#the-target-application-structure)
- [Step 1 — Installing Flask and Flask-SQLAlchemy](#step-1--installing-flask-and-flask-sqlalchemy-2)
- [Step 2 — Creating a Configuration File](#step-2--creating-a-configuration-file)
- [Step 3 — Creating a Flask Application Factory](#step-3--creating-a-flask-application-factory)
- [Step 4 — Creating Flask Blueprints](#step-4--creating-flask-blueprints)
  - [Creating the Main Blueprint and Rendering its Templates](#creating-the-main-blueprint-and-rendering-its-templates)
  - [Creating the Posts Blueprint and Rendering its Templates](#creating-the-posts-blueprint-and-rendering-its-templates)
  - [Creating the Questions Blueprint and Rendering its Templates](#creating-the-questions-blueprint-and-rendering-its-templates)
- [Step 5 — Adding Flask-SQLAlchemy Models to your Flask Application](#step-5--adding-flask-sqlalchemy-models-to-your-flask-application)
  - [Creating a File for Managing Flask Extensions and Integrating Flask-SQLAlchemy](#creating-a-file-for-managing-flask-extensions-and-integrating-flask-sqlalchemy)
  - [Creating and Interacting with the Post Model](#creating-and-interacting-with-the-post-model)
  - [Creating and Interacting with the Question Model](#creating-and-interacting-with-the-question-model)
- [Conclusion](#conclusion-12)

## How To Create Your First Web Application Using Flask and Python 3

*The author selected the [Free and Open Source Fund](https://www.brightfunds.org/funds/foss-nonprofits) to receive a donation as part of the [Write for DOnations](https://do.co/w4do-cta) program.*



### Introduction



[Flask](http://flask.pocoo.org/) is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. It gives developers flexibility and is an accessible framework for new developers because you can build a web application quickly using only a single Python file. Flask is also extensible and doesn't force a particular directory structure or require complicated boilerplate code before getting started.



Learning Flask will allow you to quickly create web applications in Python. You can take advantage of Python libraries to add advanced features to your web application, like storing your data in a database, or validating web forms.



In this tutorial, you'll build a small web application that renders HTML text on the browser. You'll  install Flask, write and run a Flask application, and run the application in development mode. You'll  use routing to display various web pages that serve different purposes in your web application. You'll also use view functions to allow users to interact with the application through dynamic routes. Finally, you'll use the debugger to troubleshoot errors.



## Prerequisites



* A local Python 3 programming environment. Follow the tutorial for your distribution in [How To Install and Set Up a Local Programming Environment for Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-python-3) series. In this tutorial we’ll call our project directory `flask_app`.

* An understanding of basic Python 3 concepts, such as [data types](https://www.digitalocean.com/community/tutorials/understanding-data-types-in-python-3), [lists](https://www.digitalocean.com/community/tutorials/understanding-lists-in-python-3), [functions](https://www.digitalocean.com/community/tutorials/how-to-define-functions-in-python-3), and other such concepts. If you are not familiar with Python, check out our [How To Code in Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-code-in-python-3) series.



* An understanding of basic HTML concepts. You can review the [How To Build a Website with HTML](https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html) tutorial series for background knowledge.



## Step 1 — Installing Flask

In this step, you’ll activate your Python environment and install Flask using the [pip](https://pypi.org/project/pip/) package installer.



First, activate your programming environment if you haven't already:



```command

source env/bin/activate

```



Once you have activated your programming environment, install Flask using the `pip install` command:



```custom_prefix((env)sammy@localhost:$)

pip install flask

```



Once the installation is complete, you will see a list of installed packages in the last parts of the output, similar to the following:



```

[secondary_label Output]

...



Installing collected packages: Werkzeug, MarkupSafe, Jinja2, itsdangerous, click, flask

Successfully installed Jinja2-3.0.1 MarkupSafe-2.0.1 Werkzeug-2.0.1 click-8.0.1 flask-2.0.1 itsdangerous-2.0.1

```



This means that installing Flask also installed several other packages. These packages are dependencies Flask needs to perform different functions.



You’ve created the project folder, a virtual environment, and installed Flask. You can now move on to setting up a simple application.



## Step 2 — Creating a Simple Application

Now that you have your programming environment set up, you’ll start using Flask. In this step, you’ll make a small Flask web application inside a Python file, in which you'll write HTML code to display on the browser.



In your `flask_app` directory, open a file named `app.py` for editing, use `nano` or your favorite text editor:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Write the following code inside the `app.py` file:



```python

[label flask_app/app.py]



from flask import Flask



app = Flask(__name__)





@app.route('/')

def hello():

    return '<h1>Hello, World!</h1>'

```

Save and close the file.



In the above code block, you first import the `Flask` object from the `flask` package. You then use it to create your Flask application instance, giving it the name `app`. You pass the special variable `__name__`, which holds the name of the current Python module. This name tells the instance where it’s located; you need this because Flask sets up some paths behind the scenes.



Once you create the `app` instance, you can use it to handle incoming web requests and send responses to the user. `@app.route` is a [decorator](https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators) that turns a regular Python function into a Flask _view function_, which converts the function’s return value into an HTTP response to be displayed by an HTTP client, such as a web browser. You pass the value `'/'` to `@app.route()` to signify that this function will respond to web requests for the URL `/`, which is the main URL.



The `hello()` view function returns the string `'<h1>Hello, World!</h1>'` as an HTTP response.



You now have a simple Flask application in a Python file called `app.py`, in the next step, you will run the application to see the result of the `hello()` view function rendered in a web browser.



## Step 3 — Running the Application

After creating the file that contains the Flask application, you'll run it using the Flask command line interface to start the development server and render on the browser the HTML code you wrote as a return value for the `hello()` view function in the previous step.



First, while in your `flask_app` directory with your virtual environment activated, tell Flask where to find the application (`app.py` in your case) using the `FLASK_APP` environment variable with the following command (on Windows, use `set` instead of `export`):





```custom_prefix((env)sammy@localhost:$)

export FLASK_APP=app

```



Then specify that you want to run the application in development mode (so you can use the debugger to catch errors) with the `FLASK_ENV` environment variable:



```custom_prefix((env)sammy@localhost:$)

export FLASK_ENV=development

```



Lastly, run the application using the `flask run` command:



```custom_prefix((env)sammy@localhost:$)

flask run

```



Once the application is running, the output will be something like this:



```

[secondary_label Output]

 * Serving Flask app "app" (lazy loading)

 * Environment: development

 * Debug mode: on

 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)

 * Restarting with stat

 * Debugger is active!

 * Debugger PIN: 296-353-699

```



The preceding output has several pieces of information, such as:



* The name of the application you’re running (`"app"`).

* The environment in which the application is being run (`development`).

* `Debug mode: on` signifies that the Flask debugger is running. This is useful when developing because it provides detailed error messages when things go wrong, which makes troubleshooting easier.

* The application is running locally on the URL `http://127.0.0.1:5000/`. `127.0.0.1` is the IP that represents your machine’s `localhost` and `:5000` is the port number.



Open a browser and type in the URL `http://127.0.0.1:5000/`. You will see the text `Hello, World!` in an `<h1>` heading as a response. This confirms that your application is successfully running.



!["Hello, World!" in an H1 heading](https://assets.digitalocean.com/67944/5ZfzDxh.png)



If you want to stop the development server, press `CTRL+C`.



<$>[warning]

**Warning:** Flask uses a simple web server to serve your application in a development environment, which also means that the Flask debugger is running to make catching errors easier. You should not use this development server in a production deployment. See the [Deployment Options](https://flask.palletsprojects.com/en/2.0.x/deploying/) page on the Flask documentation for more information. You can also check out this [Flask deployment tutorial with Gunicorn](https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-gunicorn-and-nginx-on-ubuntu-20-04) or [this one with uWSGI](https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uwsgi-and-nginx-on-ubuntu-20-04) or you can use DigitalOcean App Platform to deploy your Flask application by following the [How To Deploy a Flask App Using Gunicorn to App Platform](https://www.digitalocean.com/community/tutorials/how-to-deploy-a-flask-app-using-gunicorn-to-app-platform) tutorial.

<$>



To continue developing the `app.py` application, leave the development server running and open another terminal window. Move into the `flask_app` directory, activate the virtual environment, set the environment variables `FLASK_ENV` and `FLASK_APP`, and continue to the next steps. (These commands are listed earlier in this step.)



<$>[note]

**Note:** When opening a new terminal, or when you close the one you are running the development server on and want to rerun it, it is important to remember activating the virtual environment and setting the environment variables `FLASK_ENV` and `FLASK_APP` for the `flask run` command to work properly.



You only need to run the server once in one terminal window.



While a Flask application’s development server is already running, it is not possible to run another Flask application with the same `flask run` command. This is because `flask run` uses the port number `5000` by default, and once it is taken, it becomes unavailable to run another application on so you would receive an error similar to the following:



```

[secondary_label Output]

OSError: [Errno 98] Address already in use

```



To solve this problem, either stop the server that’s currently running via `CTRL+C`, then run `flask run` again, or if you want to run both applications at the same time, you can pass a different port number to the `-p` argument, for example, to run another application on port `5001` use the following command:



```custom_prefix((env)sammy@localhost:$)

flask run -p 5001

```



With this you can have one application running on `http://127.0.0.1:5000/` and another one on `http://127.0.0.1:5001/` if you want to.

<$>



You now have a small Flask web application. You’ve run your application and displayed information on the web browser. Next, you'll learn about routes and how to use them to serve multiple web pages.



## Step 4 — Routes and View Functions

In this step, you'll add a few routes to your application to display different pages depending on the requested URL. You'll also learn about view functions and how to use them.



A *route* is a URL you can use to determine what the user receives when they visit your web application on their browser. For example, `http://127.0.0.1:5000/` is the main route that might be used to display an index page. The URL `http://127.0.0.1:5000/about` may be another route used for an about page that gives the visitor some information about your web application. Similarly, you can create a route that allows users to sign in to your application at `http://127.0.0.1:5000/login`.



Your Flask application currently has one route that serves users who request the main URL (`http://127.0.0.1:5000/`). To demonstrate how to add a new web page to your application, you will edit your application file to add another route that provides information on your web application at `http://127.0.0.1:5000/about`.



First, open your `app.py` file for editing:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Edit the file by adding the following highlighted code at the end of the file:



```python

[label flask_app/app.py]

from flask import Flask



app = Flask(__name__)





@app.route('/')

def hello():

    return '<h1>Hello, World!</h1>'





@app.route('/about/')

def about():

    return '<h3>This is a Flask web application.</h3>'

```



Save and close the file.



You added a new function called `about()`. This function is decorated with the `@app.route()` decorator that transforms it into a _view function_ that handles requests for the `http://127.0.0.1:5000/about` endpoint.



With the development server running, visit the following URL using your browser:



```

http://127.0.0.1:5000/about

```



You will see the text `This is a Flask web application.` rendered in an `<h3>` HTML heading.



You can also use multiple routes for one view function. For example, you can serve the index page at both `/` and `/index/`. To do this, open your `app.py` file for editing:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Edit the file by adding another decorator to the `hello()` view function:



```python

[label flask_app/app.py]

from flask import Flask



app = Flask(__name__)



@app.route('/')

@app.route('/index/')

def hello():

    return '<h1>Hello, World!</h1>'



@app.route('/about/')

def about():

    return '<h3>This is a Flask web application.</h3>'

```

Save and close the file.



After adding this new decorator, you can access the index page at both `http://127.0.0.1:5000/` and `http://127.0.0.1:5000/index`.



You now understand what routes are, how to use them to make view functions, and how to add new routes to your application. Next, you'll use dynamic routes to allow users to control the application's response.



## Step 5 — Dynamic Routes

In this step, you'll use dynamic routes to allow users to interact with the application. You'll make a route that capitalizes words passed through the URL, and a route that adds two numbers together and displays the result.



Normally, users don't interact with a web application by manually editing the URL. Rather, the user interacts with elements on the page that lead to different URLs depending on the user's input and action, but for the purposes of this tutorial, you will edit the URL to demonstrate how to make the application respond differently with different URLs.



First, open your `app.py` file for editing:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



If you allow the user to submit something to your web application, such as a value in the URL as you are going to do in the following edit, you should always keep in mind that your app should not directly display untrusted data (data the user submits). To display user data safely, use the `escape()` function that comes with the `markupsafe` package, which was installed along with Flask.



Edit `app.py` and add the following line to the top of the file, above the `Flask` import:



```python

[label flask_app/app.py]

from markupsafe import escape

from flask import Flask



# ...

```



Then, add the following route to the end of the file:



```python

[label flask_app/app.py]

# ...



@app.route('/capitalize/<word>/')

def capitalize(word):

    return '<h1>{}</h1>'.format(escape(word.capitalize()))

```



Save and close the file.



This new route has a variable section `<word>`. This tells Flask to take the value from the URL and pass it to the view function. The URL variable `<word>` passes a keyword argument to the `capitalize()` view function. The argument has the same name as the URL variable (`word` in this case). With this you can access the word passed through the URL and respond with a capitalized version of it using the `capitalize()` method in Python.



You use the `escape()` function you imported earlier to render the `word` string as text. This is important to avoid [Cross Site Scripting (XSS) attacks](https://owasp.org/www-community/attacks/xss/). If the user submits malicious JavaScript instead of a word, `escape()` will it render as text and the browser will not run it, keeping your web application safe.



To display the capitalized word inside an `<h1>` HTML heading, you use the `format()` Python method, for more on this method, see [How To Use String Formatters in Python 3](https://www.digitalocean.com/community/tutorials/how-to-use-string-formatters-in-python-3)



With the development server running, open your browser and visit the following URLs. You can replace the highlighted words with any word of your choice.



```

http://127.0.0.1:5000/capitalize/hello

http://127.0.0.1:5000/capitalize/flask

http://127.0.0.1:5000/capitalize/python

```

You can see the word in the URL capitalized in an `<h1>` tag on the page.



You can also use multiple variables in a route. To demonstrate this, you will add a route that adds two positive integer numbers together and displays the result.



Open your `app.py` file for editing:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Add the following route to the end of the file:



```python

[label flask_app/app.py]

# ...



@app.route('/add/<int:n1>/<int:n2>/')

def add(n1, n2):

    return '<h1>{}</h1>'.format(n1 + n2)

```

Save and close the file.



In this route, you use a [special converter](https://flask.palletsprojects.com/en/1.1.x/quickstart/#variable-rules) `int` with the URL variable (`/add/<int:n1>/<int:n2>/`) which only accepts positive integers. By default, URL variables are assumed to be strings and are treated as such.



With the development server running, open your browser and visit the following URL:



```

http://127.0.0.1:5000/add/5/5/

```



The result will be the sum of the two numbers (`10` in this case).



You now have an understanding of how to use dynamic routes to display different responses in a single route depending on the requested URL. Next, you'll learn how to troubleshoot and debug your Flask application in case of an error.



## Step 6 — Debugging A Flask Application

When developing a web application, you will frequently run into situations where the application displays an error instead of the behavior you expect. You may misspell a variable or forget to define or import a function. To make fixing these problems easier, Flask provides a debugger when running the application in development mode. In this step, you will learn how to fix errors in your application using the Flask debugger.



To demonstrate how to handle errors, you will create a route that greets a user from a list of usernames.



Open your `app.py` file for editing:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Add the following route to the end of the file:



```python

[label flask_app/app.py]

# ...



@app.route('/users/<int:user_id>/')

def greet_user(user_id):

    users = ['Bob', 'Jane', 'Adam']

    return '<h2>Hi {}</h2>'.format(users[user_id])

```



Save and close the file.



In the route above, the `greet_user()` view function receives a `user_id` argument from the `user_id` URL variable. You use the `int` converter to accept positive integers. Inside the function, you have a Python list called `users`, which contains three strings representing usernames. The view function returns a string that is constructed depending on the provided `user_id`. If the `user_id` is `0`, the response will be `Hi Bob` in an `<h2>` tag because `Bob` is the first item in the list (the value of `users[0]`).



With the development server running, open your browser and visit the following URLs:



```

http://127.0.0.1:5000/users/0

http://127.0.0.1:5000/users/1

http://127.0.0.1:5000/users/2

```



You will receive the following responses:



```

[secondary_label Output]

Hi Bob

Hi Jane

Hi Adam

```



This works well so far, but it can go wrong when you request a greeting for a user who doesn't exist. To demonstrate how the Flask debugger works, visit the following URL:



```

http://127.0.0.1:5000/users/3

```



You'll see a page that looks like this:



![Flask Debugger](https://assets.digitalocean.com/67944/YAU6iDI.png)



At the top, the page gives you the name of the Python exception, which is [`IndexError`](https://docs.python.org/3/library/exceptions.html#IndexError), indicating that the list index (`3` in this case) is out of the list's range (which is only from `0` to `2` because the list has only three items). In the debugger, you can see the traceback that tells you the lines of code that raised this exception.



The last two lines of the traceback usually give the source of the error. In your case the lines may be something like the following:



```

File "/home/USER/flask_app/app.py", line 28, in greet_user

    return '<h2>Hi {}</h2>'.format(users[user_id])

```



This tells you that the error originates from the `greet_user()` function inside the `app.py` file, specifically in the `return` line.



Knowing the original line that raises the exception will help you determine what went wrong in your code, and decide what to do to fix it.



In this case you can use a simple `try...except` clause to fix this error. If the requested URL has an index outside the list's range, the user will receive a [404 Not Found](https://en.wikipedia.org/wiki/HTTP_404) error, which is an HTTP error that tells the user the page they are looking for does not exist.



Open your `app.py` file for editing:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



To respond with an HTTP 404 error, you will need Flask's [`abort()`](https://flask.palletsprojects.com/en/1.1.x/api/#flask.abort) function, which can be used to make HTTP error responses. Change the second line in the file to also import this function:



```python

[label flask_app/app.py]

from markupsafe import escape

from flask import Flask, abort

```



Then edit the `greet_user()` view function to look as follows:



```python

[label flask_app/app.py]

# ...



@app.route('/users/<int:user_id>/')

def greet_user(user_id):

    users = ['Bob', 'Jane', 'Adam']

    try:

        return '<h2>Hi {}</h2>'.format(users[user_id])

    except IndexError:

        abort(404)

```



You use `try` above to test the `return` expression for errors. If there was no error, meaning that `user_id` has a value that matches an index in the `users` list, the application will respond with the appropriate greeting. If the value of `user_id` is outside the list's range, an `IndexError` exception will be raised, and you use `except` to catch the error and respond with an HTTP 404 error using the `abort()` Flask helper function.



Now, with the development server running, visit the URL again:

```

http://127.0.0.1:5000/users/3

```



This time you'll see a standard 404 error page informing the user that the page does not exist.



By the end of this tutorial, your `app.py` file will look like this:



```python

[label flask_app/app.py]

from markupsafe import escape

from flask import Flask, abort



app = Flask(__name__)





@app.route('/')

@app.route('/index/')

def hello():

    return '<h1>Hello, World!</h1>'





@app.route('/about/')

def about():

    return '<h3>This is a Flask web application.</h3>'



@app.route('/capitalize/<word>/')

def capitalize(word):

    return '<h1>{}</h1>'.format(escape(word.capitalize()))



@app.route('/add/<int:n1>/<int:n2>/')

def add(n1, n2):

    return '<h1>{}</h1>'.format(n1 + n2)



@app.route('/users/<int:user_id>/')

def greet_user(user_id):

    users = ['Bob', 'Jane', 'Adam']

    try:

        return '<h2>Hi {}</h2>'.format(users[user_id])

    except IndexError:

        abort(404)

```



You now have a general idea of how to use the Flask debugger to troubleshoot your errors and help you determine the appropriate course of action to fix them.



## Conclusion

You now have a general understanding of what Flask is, how to install it, and how to use it to write a web application, how to run the development server, and how to use routes and view functions to display different web pages that serve specific purposes. You've also learned how to use dynamic routes to allow users to interact with your web application via the URL, and how to use the debugger to troubleshoot errors.



If you would like to read more about Flask, check out the [Flask topic page](https://www.digitalocean.com/community/tags/flask).





## How To Use Templates in a Flask Application

*The author selected the [Free and Open Source Fund](https://www.brightfunds.org/funds/foss-nonprofits) to receive a donation as part of the [Write for DOnations](https://do.co/w4do-cta) program.*



### Introduction



[Flask](http://flask.pocoo.org/) is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language.



When developing a web application, it is important to separate _business logic_ from _presentation logic_. _Business logic_ is what handles user requests and talks to the database to build an appropriate response. _Presentation logic_ is how the data is presented to the user, typically using HTML files to build the basic structure of the response web page, and CSS styles to style HTML components. For example, in a social media application, you might have a username field and a password field that can be displayed only when the user is not logged in. If the user is logged in, you display a logout button instead. This is the presentation logic. If a user types in their username and password, you can use Flask to perform business logic: You extract the data (the username and password) from the request, log the user in if the credentials are correct or respond with an error message. How the error message is displayed will be handled by the presentation logic.



In Flask, you can use the [Jinja](https://jinja.palletsprojects.com/en/3.0.x/) templating language to render HTML templates. A *template* is a file that can contain both fixed and dynamic content. When a user requests something from your application (such as an index page, or a login page), Jinja allows you to respond with an HTML template where you can use many features that are not available in standard HTML, such as variables, `if` statements, `for` loops, filters, and template inheritance. These features allow you to efficiently write easy-to-maintain HTML pages. Jinja also automatically escapes HTML to prevent [Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/) attacks.



In this tutorial, you'll build a small web application that renders several HTML files. You'll use variables to pass data from the server to the templates. Template inheritance will help you avoid repetition. You'll use logic in templates such as conditionals and loops, use filters to modify text, and use the [Bootstrap toolkit](https://getbootstrap.com/) to style your application.



## Prerequisites



* A local Python 3 programming environment. Follow the tutorial for your distribution in [How To Install and Set Up a Local Programming Environment for Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-python-3) series. In this tutorial we’ll call our project directory `flask_app`.



* Flask installed on your programming environment as covered in Step 1 of [How to Create Your First Web Application Using Flask and Python](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3).



* An understanding of basic Flask concepts, such as routes and view functions. If you are not familiar with Flask, check out [How to Create Your First Web Application Using Flask and Python](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3).



* An understanding of basic HTML concepts. You can review our [How To Build a Website with HTML](https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html) tutorial series for background knowledge.



## Step 1 — Rendering a Template and Using Variables

Make sure you have activated your environment and have Flask installed, and then you can start building your application. The first step is to display a message that greets visitors on the index page. You'll use Flask's `render_template()` helper function to serve an HTML template as the response. You will also see how to pass variables from your application side to your templates.



First, in your `flask_app` directory, open a file named `app.py` for editing. Use `nano` or your favorite text editor:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Add the following code inside the `app.py` file:



```python

[label flask_app/app.py]



from flask import Flask, render_template



app = Flask(__name__)





@app.route('/')

def hello():

    return render_template('index.html')

```

Save and close the file.



In this code block, you import the `Flask` class and the [`render_template()`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.render_template) function from the `flask` package. You use the `Flask` class to create your Flask application instance named `app`. Then you define a _view function_ (which is a Python function that returns an HTTP response) called `hello()` using the `app.route()` decorator, which converts a regular function into a view function. This view function uses the `render_template()` function to render a template file called `index.html`.



Next, you'll have to create the `index.html` template file in a directory called `templates` inside your `flask_app` directory. Flask looks for templates in the _templates directory_, which is called `templates`, so the name is important. Make sure you're inside the `flask_app` directory and run the following command to create the `templates` directory:



```custom_prefix((env)sammy@localhost:$)

mkdir templates

```

Next, open a file called `index.html` inside the `templates` directory for editing. The name `index.html` here is not a standard required name; you can call it `home.html` or `homepage.html` or anything else if you want:



```custom_prefix((env)sammy@localhost:$)

nano templates/index.html

```



Add the following HTML code inside the `index.html` file:



```html

[label flask_app/templates/index.html]



<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>FlaskApp</title>

</head>

<body>

    <h1>Hello World!</h1>

    <h2>Welcome to FlaskApp!</h2>

</body>

</html>

```



Here, you set a title, added a `Hello World!` message as an `H1` heading, and created a `Welcome to FlaskApp!` message as an `H2` heading.



Save and close the file.





While in your `flask_app` directory with your virtual environment activated, tell Flask about the application (`app.py` in your case) using the `FLASK_APP` environment variable, and set the `FLASK_ENV` environment variable to `development` to run the application in development mode and get access to the debugger. Use the following commands to do this (on Windows, use `set` instead of `export`):



```custom_prefix((env)sammy@localhost:$)

export FLASK_APP=app

export FLASK_ENV=development

```



Then, run the application using the `flask run` command:



```custom_prefix((env)sammy@localhost:$)

flask run

```



With the development server running, visit the following URL using your browser:



```

http://127.0.0.1:5000/

```



You'll see the title of the page is set to `FlaskApp`, and the two headings are rendered HTML.



In web applications, you often need to pass data from your application's Python files to your HTML templates. To demonstrate how to do this in this application, you will pass a variable containing the current UTC date and time to the index template, and you'll display the value of the variable in the template.





Leave the server running, and open your `app.py` file for editing in a new terminal:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Import the [`datetime`](https://docs.python.org/3/library/datetime.html) module from the Python standard library and edit the `index()` function so the file looks as follows:



```

[label flask_app/app.py]

import datetime

from flask import Flask, render_template



app = Flask(__name__)





@app.route('/')

def hello():

    return render_template('index.html', utc_dt=datetime.datetime.utcnow())

```



Save and close the file.



Here you imported the `datetime` module and passed a variable called `utc_dt` to the `index.html` template with the value of `datetime.datetime.utcnow()`, which is the current UTC date and time.



Next, to display the variable's value on the index page, open the `index.html` file for editing:



```custom_prefix((env)sammy@localhost:$)

nano templates/index.html

```



Edit the file to look as follows:



```

[label flask_app/templates/index.html]

<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>FlaskApp</title>

</head>

<body>

    <h1>Hello World!</h1>

    <h2>Welcome to FlaskApp!</h2>

    <h3>{{ utc_dt }}</h3>

</body>

</html>

```



Save and close the file.



You added an H3 heading with the special `{{ ... }}` delimiter to print the value of the `utc_dt` variable.



Open your browser and visit the index page:



```

http://127.0.0.1:5000/

```



You'll see a page similar to the following image:



![The Index Page](https://assets.digitalocean.com/67945/HqVe3Qe.png)



You've now created an index page with an HTML template in your Flask application, rendered a template, and passed and displayed a variable value. Next you'll avoid code repetition by using template inheritance.



## Step 2 — Using Template Inheritance

In this step, you'll make a base template with content that can be shared with your other templates. You'll edit your index template to inherit from the base template. Then, you'll make a new page that will serve as your application's About page, where users can find more information about your application.



A _base template_ contains HTML components that are typically shared between all other templates, such as the application's title, navigation bars, and footers.



First, open a new file called `base.html` for editing inside your templates directory:



```custom_prefix((env)sammy@localhost:$)

nano templates/base.html

```



Write the following code inside your `base.html` file:



```html

[label flask_app/templates/base.html]



<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>{% block title %} {% endblock %} - FlaskApp</title>

    <style>

        nav a {

            color: #d64161;

            font-size: 3em;

            margin-left: 50px;

            text-decoration: none;

        }

    </style>

</head>

<body>

    <nav>

        <a href="#">FlaskApp</a>

        <a href="#">About</a>

    </nav>

    <hr>

    <div class="content">

        {% block content %} {% endblock %}

    </div>

</body>

</html>

```

Save and close the file.



Most of the code in this file is standard HTML, a title, some styling for the navigation links, a navigation bar with two links, one for the index page and one for the About page not yet created, and a `<div>` for the page's content. (The links don't work yet; the next step will demonstrate how to link between pages).



However, the following highlighted parts are specific to the Jinja template engine:



* `{% block title %} {% endblock %}`: A [block](https://jinja.palletsprojects.com/en/3.0.x/templates/#base-template) that serves as a placeholder for a title. You’ll later use it in other templates to provide a custom title for each page in your application without rewriting the entire `<head>` section each time.



* `{% block content %} {% endblock %}`: Another block that will be replaced by content depending on the _child template_ (a template that inherits from `base.html`) that will override it.



Now that you have a base template, you can take advantage of it using inheritance. Open the `index.html` file:



```custom_prefix((env)sammy@localhost:$)

nano templates/index.html

```



Then replace its contents with the following:



```html

[label flask_app/templates/index.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Index {% endblock %}</h1>

    <h1>Hello World!</h1>

    <h2>Welcome to FlaskApp!</h2>

    <h3>{{ utc_dt }}</h3>

{% endblock %}

```



Here, you use the `{% extends %}` tag to inherit from the `base.html` template. You then extend it via replacing the `content` block in the base template with what is inside the `content` block in the preceding code block.



This content block contains an `<h1>` tag with the text `Index` inside a title block, which in turn replaces the original `title` block in the `base.html` template with the text `Index` so that the complete title becomes `Index - FlaskApp`. This way, you can avoid repeating the same text twice, as it works both as a title for the page and a heading that appears below the navigation bar inherited from the base template.



Then you have a few more headings: one `<h1>` heading with the text `Hello World!`, an `<h2>` heading, and an `<h3>` heading containing the value of the `utc_dt` variable.



Template inheritance gives you the ability to reuse the HTML code you have in other templates (`base.html` in this case) without having to repeat it each time it is needed.



Save and close the file and refresh the index page on your browser. The page will look as follows:



![The Index Page After Inheritance](https://assets.digitalocean.com/67945/fSR6YKV.png)



Next, you'll create the About page. Open the `app.py` file to add a new route:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Add the following route at the end of the file:



```python

[label flask_app/app.py]



# ...

@app.route('/about/')

def about():

    return render_template('about.html')

```



Here you use the `app.route()` decorator to create a view function called `about()`. In it, you return the result of calling the `render_template()` function with the `about.html` template file name as an argument.



Save and close the file.



Open a template file called `about.html` for editing:



```custom_prefix((env)sammy@localhost:$)

nano templates/about.html

```



Add the following code to the file:



```html

[label flask_app/templates/about.html]



{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} About {% endblock %}</h1>

    <h3>FlaskApp is a Flask web application written in Python.</h3>

{% endblock %}

```



Here, you inherit from the base template using the `extends` tag, replace the base template's `content` block with an `<h1>` tag that also serves as the page's title, and add an `<h3>` tag with some information about the application.



Save and close the file.



With the development server running, visit the following URL using your browser:



```

http://127.0.0.1:5000/about

```



You'll see a page similar to the following:



![About Page](https://assets.digitalocean.com/67945/CO52vZM.png)



Notice how the navigation bar and part of the title are inherited from the base template.



You've now created a base template and used it in your index page and about page to avoid code repetition. The links in the navigation bar don't do anything at this point. In the next step, you'll learn how to link between routes in your templates by fixing the navigation bar links.



## Step 3 — Linking between Pages



In this step, you'll learn how to link between pages in your templates using the [`url_for()`](https://flask.palletsprojects.com/en/2.0.x/quickstart/#url-building) helper function. You will add two links to the navigation bar in your base template, one for the index page, and one for the About page.



First open your base template for editing:



```custom_prefix((env)sammy@localhost:$)

nano templates/base.html

```



Edit the file to look as follows:

```html

[label flask_app/templates/base.html]

<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>{% block title %} {% endblock %} - FlaskApp</title>

    <style>

        nav a {

            color: #d64161;

            font-size: 3em;

            margin-left: 50px;

            text-decoration: none;

        }

    </style>

</head>

<body>

    <nav>

        <a href="{{ url_for('hello') }}">FlaskApp</a>

        <a href="{{ url_for('about') }}">About</a>

    </nav>

    <hr>

    <div class="content">

        {% block content %} {% endblock %}

    </div>

</body>

</html>

```



Here, you use the special [`url_for()`](https://flask.palletsprojects.com/en/2.0.x/quickstart/#url-building) function that will return the URL for the view function you give it. The first link links to the route of the `hello()` view function (which is the index page). The second link links to the route of the `about()` view function. Notice that you pass the name of the view function, not the route (`/` or `/about`).



Using the `url_for()` function to build URLs helps you manage URLs better. If you hard-code URLs, your links will break if you edit the routes. With `url_for()` you can edit routes and guarantee that the links will still work as expected. The `url_for()` function also takes care of other things like escaping special characters.



Save and close the file.



Now go to the index page and try out the links in the navigation bar. You'll see that they work as expected.



You learned how to use the `url_for()` function to link to other routes in your templates. Next, you will add some conditional statements to control what is displayed in your templates depending on conditions you set, and use `for` loops in your templates to display list items.



## Step 4 — Using Conditionals and Loops

In this step, you'll use `if` statements in your templates to control what to display depending on certain conditions. You'll also use `for` loops to go through Python lists and display each item in the list. You'll add a new page that displays comments in a list. Comments with an even index number will have a blue background, and comments with an odd index number will be displayed with a gray background.



First, you will create a route for the comments page. Open your `app.py` file for editing:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Add the following route at the end of the file:



```python

[label flask_app/app.py]



# ...



@app.route('/comments/')

def comments():

    comments = ['This is the first comment.',

                'This is the second comment.',

                'This is the third comment.',

                'This is the fourth comment.'

                ]



    return render_template('comments.html', comments=comments)

```



In the route above, you have a Python list called `comments` that contains four items. (These comments would usually come from a database in a real-world scenario rather than being hard-coded like you've done here.) You return a template file called `comments.html` in the last line, passing a variable called `comments` containing the list to the template file.



Save and close the file.



Next, open a new `comments.html` file inside the `templates` directory for editing:



```custom_prefix((env)sammy@localhost:$)

nano templates/comments.html

```



Add the following code to the file:



```html

[label flask_app/templates/comments.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Comments {% endblock %}</h1>

    <div style="width: 50%; margin: auto">

        {% for comment in comments %}

        <div style="padding: 10px; background-color: #EEE; margin: 20px">

            <p style="font-size: 24px">{{ comment }}</p>

        </div>

        {% endfor %}

    </div>

{% endblock %}

```



Here, you extend the `base.html` template and replace the contents of the `content` block. First, you use an `<h1>` heading that also serves as the page's title. 



You use a Jinja `for` loop in the line `{% for comment in comments %}` to go through each comment in the `comments` list (which gets stored in the `comment` variable). You display the comment in the `<p style="font-size: 24px">{{ comment }}</p>` tag the same way you would normally display a variable in Jinja. You signal the ending of the `for` loop using the `{% endfor %}` keyword. This is different from the way Python `for` loops are constructed because there is no special indentation in Jinja templates.



Save and close the file.



With the development server running, open your browser and visit the comments page:



```

http://127.0.0.1:5000/comments

```



You will see a page similar to the following:



![Comments Page](https://assets.digitalocean.com/67945/1WZrtNc.png)



Now you will use the `if` conditional statement in your templates by displaying comments with an odd index number with a gray background, and comments with an even index number with a blue background.



Open your `comments.html` template file for editing:



```custom_prefix((env)sammy@localhost:$)

nano templates/comments.html

```



Edit it to look as follows:



```html

[label flask_app/templates/comments.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Comments {% endblock %}</h1>

    <div style="width: 50%; margin: auto">

        {% for comment in comments %}

            {% if loop.index % 2 == 0 %}

                {% set bg_color = '#e6f9ff' %}

            {% else %}

                {% set bg_color = '#eee' %}

            {% endif %}



            <div style="padding: 10px; background-color: {{ bg_color }}; margin: 20px">

                <p>#{{ loop.index }}</p>

                <p style="font-size: 24px">{{ comment }}</p>

            </div>

        {% endfor %}

    </div>

{% endblock %}

```



With this new edit, you added an `if` statement in the line `{% if loop.index % 2 == 0 %}`. The [`loop` variable](https://jinja.palletsprojects.com/en/3.0.x/templates/#loop-filtering) is a special Jinja variable that gives you access to information about the current loop. Here you use `loop.index` to get the index of the current item, which starts from `1`, not `0` as in Python lists. 



The `if` statement here checks whether the index is even using the `%` operator. It checks for the remainder of dividing the index number by `2`; if the remainder is `0` it means the index number is even, otherwise, the index number is odd. You use the `{% set %}` tag to declare a variable called `bg_color`. If the index number is even, you set it to a blueish color, otherwise, if the index number is odd, you set the `bg_color` variable to gray. You then use the `bg_color` variable to set a background color for the `<div>` tag that contains the comment. Above the comment's text, you use `loop.index` to display the current index number in a `<p>` tag.



Save and close the file.



Open your browser and visit the comments page:



```

http://127.0.0.1:5000/comments

```



You will see your new Comments page:



![Comments Page With Alternating Background Colors](https://assets.digitalocean.com/67945/ZbCctye.png)



This was a demonstration of how to use the `if` statement. But you can also achieve the same effect by using the special `loop.cycle()` Jinja helper. To demonstrate this, open the `comments.html` file:



```custom_prefix((env)sammy@localhost:$)

nano templates/comments.html

```



Edit it to look as follows:



```

[label flask_app/templates/comments.html]



{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Comments {% endblock %}</h1>

    <div style="width: 50%; margin: auto">

        {% for comment in comments %}

            <div style="padding: 10px;

                        background-color: {{ loop.cycle('#EEE', '#e6f9ff') }};

                        margin: 20px">

                <p>#{{ loop.index }}</p>

                <p style="font-size: 24px">{{ comment }}</p>

            </div>

        {% endfor %}

    </div>

{% endblock %}

```



Here, you removed the `if/else` statement and used the `loop.cycle('#EEE', '#e6f9ff')` helper to cycle between the two colors. The value of `background-color` will be `#EEE` one time and `#e6f9ff` another.



Save and close the file.



Open the comments page in your browser, refresh it, and you'll see that this has the same effect as the `if` statement.



You can use `if` statements for multiple purposes, including controlling what gets displayed on the page. For example, to display all comments except for the second one, you can use an `if` statement with the condition `loop.index != 2` to filter out the second comment.



Open the comments template:



```custom_prefix((env)sammy@localhost:$)

nano templates/comments.html

```



And edit it to look as follows:



```

[label flask_app/templates/comments.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Comments {% endblock %}</h1>

    <div style="width: 50%; margin: auto">

        {% for comment in comments %}

            {% if loop.index != 2 %}

                <div style="padding: 10px;

                            background-color: #EEE;

                            margin: 20px">

                    <p>#{{ loop.index }}</p>

                    <p style="font-size: 24px">{{ comment }}</p>

                </div>

            {% endif %}

        {% endfor %}

    </div>

{% endblock %}

```

Here, you use `{% if loop.index != 2 %}` to show only the comments that don't have the index `2`, which means all the comments except for the second one. You also use a hard-coded value for the background color instead of the `loop.cycle()` helper to make things simpler, and the rest is not changed. You end the `if` statement using `{% endif %}`.



Save and close the file.



Refresh the comments page and you'll see that the second comment is not displayed.



You now need to add a link that takes users to the Comments page in the navigation bar. Open the base template for editing:



```custom_prefix((env)sammy@localhost:$)

nano templates/base.html

```



Edit the contents of the `<nav>` tag by adding a new `<a>` link to it:



```html

[label flask_app/templates/base.html]

<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>{% block title %} {% endblock %} - FlaskApp</title>

    <style>

        nav a {

            color: #d64161;

            font-size: 3em;

            margin-left: 50px;

            text-decoration: none;

        }

    </style>

</head>

<body>

    <nav>

        <a href="{{ url_for('hello') }}">FlaskApp</a>

        <a href="{{ url_for('comments') }}">Comments</a>

        <a href="{{ url_for('about') }}">About</a>

    </nav>

    <hr>

    <div class="content">

        {% block content %} {% endblock %}

    </div>

</body>

</html>

```



Here, you use the `url_for()` helper to link to the `comments()` view function.



Save and close the file.



The navigation bar will now have a new link that links to the comments page.



You used `if` statements in your templates to control what to display depending on certain conditions. You used `for` loops to go through Python lists and display each item in the list, and you learned about the special `loop` variable in Jinja. Next, you'll use Jinja filters to control how variable data is displayed.



## Step 5 — Using Filters

In this step, you'll learn how to use Jinja filters in your templates. You'll use the `upper` filter to convert comments you added in the previous step to uppercase, you'll use the `join` filter to join a sequence of strings into one string, and you'll learn how to render trusted HTML code without escaping it using the `safe` filter.



First, you will convert the comments in the comments page to uppercase. Open the `comments.html` template for editing:



```custom_prefix((env)sammy@localhost:$)

nano templates/comments.html

```



Edit it to look as follows:



```html

[label flask_app/templates/comments.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Comments {% endblock %}</h1>

    <div style="width: 50%; margin: auto">

        {% for comment in comments %}

            {% if loop.index != 2 %}

                <div style="padding: 10px;

                            background-color: #EEE;

                            margin: 20px">

                    <p>#{{ loop.index }}</p>

                    <p style="font-size: 24px">{{ comment | upper }}</p>

                </div>

            {% endif %}

        {% endfor %}

    </div>

{% endblock %}

```



Here, you added the `upper` [filter](https://jinja.palletsprojects.com/en/2.11.x/templates/#filters) using the pipe symbol (`|`). This will modify the value of the `comment` variable to be uppercase.



Save and close the file.



With the development server running, open the comments page with your browser:



```

http://127.0.0.1:5000/comments

```



You can see that the comments are all in uppercase after applying the filter.



Filters can also take arguments in parentheses. To demonstrate this, you'll use the `join` filter to join all the comments in the `comments` list.



Open the comments template:



```custom_prefix((env)sammy@localhost:$)

nano templates/comments.html

```



Edit it to look as follows:



```html

[label flask_app/templates/comments.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Comments {% endblock %}</h1>

    <div style="width: 50%; margin: auto">

        {% for comment in comments %}

            {% if loop.index != 2 %}

                <div style="padding: 10px;

                            background-color: #EEE;

                            margin: 20px">

                    <p>#{{ loop.index }}</p>

                    <p style="font-size: 24px">{{ comment | upper }}</p>

                </div>

            {% endif %}

        {% endfor %}

        <hr>

        <div>

            <p>{{ comments | join(" | ") }}</p>

        </div>

    </div>

{% endblock %}

```



Here you added an `<hr>` tag and a `<div>` tag where you join all the comments in the `comments` list using the `join()` filter.



Save and close the file.



Refresh the comments page and you'll see a page similar to the following:



![Comments Page With Join Filter](https://assets.digitalocean.com/67945/pwTljCS.png)



As you can see, the `comments` list is displayed with the comments separated by a pipe symbol, which is what you passed to the `join()` filter.



Another important filter is the `safe` filter, which allows you to render trusted HTML on the browser. To illustrate this, you'll add some text containing an HTML tag to your comments template using the `{{ }}` Jinja delimiter. In a real-world scenario, this would come as a variable from the server. Then you'll edit the `join()` argument to be the `<hr>` tag instead of the pipe symbol.



Open the comments template:



```custom_prefix((env)sammy@localhost:$)

nano templates/comments.html

```



Edit it to look as follows:



```html

[label flask_app/templates/comments.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Comments {% endblock %}</h1>

    <div style="width: 50%; margin: auto">

        {% for comment in comments %}

            {% if loop.index != 2 %}

                <div style="padding: 10px;

                            background-color: #EEE;

                            margin: 20px">

                    <p>#{{ loop.index }}</p>

                    <p style="font-size: 24px">{{ comment | upper }}</p>

                </div>

            {% endif %}

        {% endfor %}

        <hr>

        <div>

            {{ "<h1>COMMENTS</h1>" }}

            <p>{{ comments | join(" <hr> ") }}</p>

        </div>

    </div>

{% endblock %}

```

Here, you added the value `"<h1>COMMENTS</h1>"` and changed the join argument to the `<hr>` tag.



Save and close the file.



Refresh the comments page and you'll see a page similar to the following:



![Comments Page With No Safe Filter](https://assets.digitalocean.com/67945/TDalMVf.png)



As you can see, the HTML tags were not rendered. This is a safety feature in Jinja, because some HTML tags can be harmful and may result in a [Cross Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/) attack. You should allow only trusted HTML to be rendered in the browser.



To render the HTML tags above, open the comments template file:



```custom_prefix((env)sammy@localhost:$)

nano templates/comments.html

```



Edit it by adding the `safe` filter:

```html

[label flask_app/templates/comments.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Comments {% endblock %}</h1>

    <div style="width: 50%; margin: auto">

        {% for comment in comments %}

            {% if loop.index != 2 %}

                <div style="padding: 10px;

                            background-color: #EEE;

                            margin: 20px">

                    <p>#{{ loop.index }}</p>

                    <p style="font-size: 24px">{{ comment | upper }}</p>

                </div>

            {% endif %}

        {% endfor %}

        <hr>

        <div>

            {{ "<h1>COMMENTS</h1>" | safe }}

            <p>{{ comments | join(" <hr> ") | safe }}</p>

        </div>

    </div>

{% endblock %}

```



You can see that you can also chain filters like in the line `<p>{{ comments | join(" <hr> ") | safe }}</p>`. Each filter gets applied to the result of the previous filtering.



Save and close the file.



Refresh the comments page and you'll see that the HTML tags are now rendered as expected:



![Comments Page With Safe Filter](https://assets.digitalocean.com/67945/4ipmbwb.png)



<$>[warning]

**Warning:** Using the `safe` filter on HTML from unknown data sources may open up your application to XSS attacks. Do not use it unless the HTML you are rendering is from a trusted source.

<$>



For more information, check out the [list of built-in Jinja filters](https://jinja.palletsprojects.com/en/3.0.x/templates/#list-of-builtin-filters).



You have now learned how to use filters in your Jinja templates to modify variable values. Next, you'll integrate the [Bootstrap toolkit](https://getbootstrap.com/) to style your application.



## Step 6 — Integrating Bootstrap

In this step, you'll learn how to use the [Bootstrap toolkit](https://getbootstrap.com/) to style your application. You'll add a Bootstrap navigation bar in the base template that will appear in all the pages that inherit from the base template.



The Bootstrap toolkit helps you style your application so it is more visually appealing. It will also help you incorporate responsive web pages in your web application so that it works well on mobile browsers without writing your own HTML, CSS, and JavaScript code to achieve these goals.



To use Bootstrap, you'll need to add it to the base template so you can use it in all other templates.



Open your `base.html` template, for editing:



```custom_prefix((env)sammy@localhost:$)

nano templates/base.html

```



Edit it to look as follows:



```

[label flask_app/templates/base.html]

<!doctype html>

<html lang="en">

  <head>

    <!-- Required meta tags -->

    <meta charset="utf-8">

    <meta name="viewport" content="width=device-width, initial-scale=1">



    <!-- Bootstrap CSS -->

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We" crossorigin="anonymous">



    <title>{% block title %} {% endblock %} - FlaskApp</title>

  </head>

  <body>

    <nav class="navbar navbar-expand-lg navbar-light bg-light">

    <div class="container-fluid">

        <a class="navbar-brand" href="{{ url_for('hello') }}">FlaskApp</a>

        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">

        <span class="navbar-toggler-icon"></span>

        </button>

        <div class="collapse navbar-collapse" id="navbarNav">

        <ul class="navbar-nav">

            <li class="nav-item">

              <a class="nav-link" href="{{ url_for('comments') }}">Comments</a>

            </li>

            <li class="nav-item">

              <a class="nav-link" href="{{ url_for('about') }}">About</a>

            </li>

        </ul>

        </div>

    </div>

    </nav>

    <div class="container">

        {% block content %} {% endblock %}

    </div>



    <!-- Optional JavaScript -->



    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-U1DAWAznBHeqEIlVSCgzq+c9gqGAJn5c/t99JyeKa9xxaYpSvHU5awsuZVVFIhvj" crossorigin="anonymous"></script>



  </body>

</html>

```



Most of the code above is Bootstrap boilerplate required to use it. You have some meta tags, a link to the Bootstrap CSS file in the `<head>` section, and at the bottom you have a link to optional JavaScript. The highlighted parts of the code contain Jinja code explained in the previous steps. Notice how you use specific tags and CSS classes to tell Bootstrap how to display each element.



In the `<nav>` tag above, you have an `<a>` tag with the class `navbar-brand`, which determines the brand link in the navigation bar. Inside the `<ul class="navbar-nav">` tag, you have regular navigation bar items inside an `<a>` tag in an `<li>` tag.



To learn more about these tags and CSS classes, see the [Bootstrap components](https://getbootstrap.com/docs/5.1/components).



Save and close the file.



With the development server running, open the index page with your browser:



```

http://127.0.0.1:5000/

```



You'll see a page similar to the following:



![Index Page with Bootstrap](https://i.imgur.com/haE7cO1.png)



You can now use Bootstrap components to style items in your Flask application in all of your templates.



## Conclusion

You now know how to use HTML templates in your Flask web application. You've used variables to pass data from the server to templates, employed template inheritance to avoid repetition, incorporated elements such as `if` conditionals and `for` loops, and linked between different pages. You learned about filters to modify text and display trusted HTML, and you integrated Bootstrap into your application.



If you would like to read more about Flask, check out the [Flask topic page](https://www.digitalocean.com/community/tags/flask).





## How To Handle Errors in a Flask Application

*The author selected the [Free and Open Source Fund](https://www.brightfunds.org/funds/foss-nonprofits) to receive a donation as part of the [Write for DOnations](https://do.co/w4do-cta) program.*



### Introduction



[Flask](http://flask.pocoo.org/) is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language.



When you're developing a web application, you will inevitably run into situations where your application behaves in a way contrary to what you expected. You might misspell a variable, misuse a `for` loop, or construct an `if` statement in a way that raises a Python exception, like calling a function before declaring it, or simply looking for a page that doesn't exist. You'll find it easier and smoother to develop your Flask applications if you learn how to handle errors and exceptions properly.



In this tutorial, you'll build a small web application that demonstrates how to handle common errors one encounters when developing a web application. You'll create custom error pages, use the Flask debugger to troubleshoot exceptions, and use logging to track events in your application.



## Prerequisites



* A local Python 3 programming environment. You can follow the tutorial for your distribution in [How To Install and Set Up a Local Programming Environment for Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-python-3) series. In this tutorial we’ll call our project directory `flask_app`.



* An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out [How to Create Your First Web Application Using Flask and Python](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3) and [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).



* An understanding of basic HTML concepts. You can review our [How To Build a Website with HTML](https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html) tutorial series for background knowledge.



## Step 1 — Using The Flask Debugger

In this step, you'll create an application that has a few errors and run it without debug mode to see how the application responds. Then you'll run it with debug mode on and use the debugger to troubleshoot application errors.



With your programming environment activated and Flask installed, open a file called `app.py` for editing inside your `flask_app` directory:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Add the following code inside the `app.py` file:



```python

[label flask_app/app.py]

from flask import Flask



app = Flask(__name__)





@app.route('/')

def index():

    return render_template('index.html')

```



In the above code, you first import the `Flask` class from the `flask` package. Then you create a Flask application instance called `app`. You use the `@app.route()` decorator to create a view function called `index()`, which calls the `render_template()` function as the return value, which in turn renders a template called `index.html`. There are two errors in this code: the first is that you did not import the `render_template()` function, and the second one is that the `index.html` template file does not exist.



Save and close the file.



Next, inform Flask about the application using the `FLASK_APP` environment variable using the following command (on Windows, use `set` instead of `export`):



```custom_prefix((env)sammy@localhost:$)

export FLASK_APP=app

```



Then run the application server using the `flask run` command:



```custom_prefix((env)sammy@localhost:$)

flask run

```



You will see the following information in your terminal:



```

[secondary_label Output]

 * Serving Flask app 'app' (lazy loading)

 * Environment: production

   WARNING: This is a development server. Do not use it in a production deployment.

   Use a production WSGI server instead.

 * Debug mode: off

 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)

```



This output provides the following information:

* The Flask application being served (`app.py` in this case)

* The environment, which is `production` here. The warning message stresses that this server is not for a production deployment. You're using this server for development, so you can ignore this warning, but for more information, see the [Deployment Options](https://flask.palletsprojects.com/en/2.0.x/deploying/) page on the Flask documentation. You can also check out this [Flask deployment tutorial with Gunicorn](https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-gunicorn-and-nginx-on-ubuntu-20-04), or [this one with uWSGI](https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uwsgi-and-nginx-on-ubuntu-20-04), or you can use DigitalOcean App Platform to deploy your Flask application by following the [How To Deploy a Flask App Using Gunicorn to App Platform](https://www.digitalocean.com/community/tutorials/how-to-deploy-a-flask-app-using-gunicorn-to-app-platform) tutorial.



* The debug mode is off, which means that the Flask debugger is not running, and you won't receive helpful error messages in your application. In a production environment, displaying detailed errors exposes your application to security vulnerabilities.

* The server is running on the `http://127.0.0.1:5000/` URL. To stop the server, use `CTRL+C`, but don't do that just yet.



Now, visit the index page using your browser:



```

http://127.0.0.1:5000/

```



You will see a message that looks like the following:





```

[secondary_label Output]

Internal Server Error



The server encountered an internal error and was unable to complete your request. Either the server is overloaded or there is an error in the application.

```

This is the [500 Internal Server Error](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500), which is a server error response that indicates that the server encountered an internal error in the application code.



In the terminal, you'll see the following output:



```

[secondary_label Output]

[2021-09-12 15:16:56,441] ERROR in app: Exception on / [GET]

Traceback (most recent call last):

  File "/home/abd/.local/lib/python3.9/site-packages/flask/app.py", line 2070, in wsgi_app

    response = self.full_dispatch_request()

  File "/home/abd/.local/lib/python3.9/site-packages/flask/app.py", line 1515, in full_dispatch_request

    rv = self.handle_user_exception(e)

  File "/home/abd/.local/lib/python3.9/site-packages/flask/app.py", line 1513, in full_dispatch_request

    rv = self.dispatch_request()

  File "/home/abd/.local/lib/python3.9/site-packages/flask/app.py", line 1499, in dispatch_request

    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)

  File "/home/abd/python/flask/series03/flask_app/app.py", line 8, in index

    return render_template('index.html')

NameError: name 'render_template' is not defined

127.0.0.1 - - [12/Sep/2021 15:16:56] "GET / HTTP/1.1" 500 -

```

The traceback above goes through the code that triggered the internal server error. The line `NameError: name 'render_template' is not defined` gives the root cause of the problem: the `render_template()` function has not been imported.



As you can see here, you have to go to the terminal to troubleshoot errors, which is not convenient.



You can have a better troubleshooting experience by enabling the debug mode in your development server. To do so, stop the server with `CTRL+C` and set the environment variable `FLASK_ENV` to `development`, so you can run the application in development mode (which enables the debugger), using the following command (on Windows, use `set` instead of `export`):



```custom_prefix((env)sammy@localhost:$)

export FLASK_ENV=development

```



Run the development server:



```custom_prefix((env)sammy@localhost:$)

flask run

```



You'll see an output similar to the following in the terminal:



```

[secondary_label Output]

 * Serving Flask app 'app' (lazy loading)

 * Environment: development

 * Debug mode: on

 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)

 * Restarting with stat

 * Debugger is active!

 * Debugger PIN: 120-484-907

```



Here you see that the environment is now `development`, debug mode is on, and the debugger is active. The `Debugger PIN` is a PIN you need to unlock the console in your browser (an interactive python shell you can access by clicking the little terminal icon encircled in the image below).



Refresh the index page on your browser and you'll see the following page:



![The Flask Debugger](https://assets.digitalocean.com/67983/4KjQjKS.png)



Here, you see the error message displayed in a manner that's easier to understand. The first heading gives you the name of the Python exception that caused the problem ([`NameError`](https://docs.python.org/3/library/exceptions.html#NameError) in this case). The second line gives you the direct reason (`render_template()` is not defined, which means it's not imported in this case). Following that, you have the traceback going through the inner Flask code that was executed. Read the traceback from the bottom upward, because the last line in the traceback usually has the most useful information.



<$>[note]

**Note:**

The circled terminal icon allows you to run Python code in the browser on different frames. This is useful for when you want to check the value of a variable the way you would do it in a Python interactive shell. When you click the terminal icon, you will need to type in the Debugger PIN code you got when you ran the server. You won't need this interactive shell in this tutorial.

<$>



To fix this `NameError` issue, leave the server running, open a new terminal window, activate your environment, and open your `app.py` file:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Modify the file to look as follows:



```python

[label flask_app/app.py]



from flask import Flask, render_template



app = Flask(__name__)





@app.route('/')

def index():

    return render_template('index.html')

```



Save and close the file.



Here you imported the `render_template()` function that was missing.



With the development server running, refresh the index page on your browser.



This time you'll see an error page with information that looks like so:



```

[secondary_label Output]

jinja2.exceptions.TemplateNotFound

jinja2.exceptions.TemplateNotFound: index.html

```



This error message indicates that the `index.html` template does not exist.



To fix this, you'll create a `base.html` template file other templates will inherit from to avoid code repetition, then an `index.html` template that extends the base template.



Create the `templates` directory, which is the directory where Flask looks for template files. Then open a `base.html` file using your favorite editor:



```custom_prefix((env)sammy@localhost:$)

mkdir templates

nano templates/base.html

```



Add the following code to your `base.html` file:



```html

[label flask_app/templates/base.html]



<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>{% block title %} {% endblock %} - FlaskApp</title>

    <style>

        nav a {

            color: #d64161;

            font-size: 3em;

            margin-left: 50px;

            text-decoration: none;

        }

    </style>

</head>

<body>

    <nav>

        <a href="{{ url_for('index') }}">FlaskApp</a>

        <a href="#">About</a>

    </nav>

    <hr>

    <div class="content">

        {% block content %} {% endblock %}

    </div>

</body>

</html>

```



Save and close the file.



This base template has all the HTML boilerplate you'll need to reuse in your other templates. The `title` block will be replaced to set a title for each page, and the `content` block will be replaced with the content of each page. The navigation bar has two links, one for the index page where you use the `url_for()` helper function to link to the `index()` view function, and the other for an About page if you choose to include one in your application.





Next, open a template file called `index.html`, which will inherit from the base template.



```custom_prefix((env)sammy@localhost:$)

nano templates/index.html

```



Add the following code to it:

```html

[label flask_app/templates/index.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Index {% endblock %}</h1>

    <h2>Welcome to FlaskApp!</h2>

{% endblock %}

```



Save and close the file.



In the code above, you extend the base template and override the `content` block. You then set a page title and display it in an `H1` header using the `title` block, and display a greeting in an `H2` header.



With the development server running, refresh the index page on your browser.



You'll see that the application displays no more errors and the index page is displayed as expected.



You've now used debug mode and seen how to handle error messages. Next, you'll abort a request to respond with an error message of your choice, and see how to respond with custom error pages.



## Step 2 — Creating Custom Error Pages

In this step, you'll learn how to abort requests and respond with a 404 HTTP error message for when the user requests data that does not exist on the server. You will also learn how to create custom error pages for common HTTP errors, such as the `404 Not Found` error, and the `500 Internal Server Error` error.



To demonstrate how to abort requests and respond with a custom 404 HTTP error page, you'll create a page that displays a few messages. If the requested message does not exist, you'll respond with a 404 error.



First, open your `app.py` file to add a new route for the messages page:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Add the following route at the end of the file:



```python

[label flask_app/app.py]

# ...



@app.route('/messages/<int:idx>')

def message(idx):

    messages = ['Message Zero', 'Message One', 'Message Two']

    return render_template('message.html', message=messages[idx])

```



Save and close the file.



In the route above, you have a URL variable `idx`. This is the index that will determine what message will be displayed. For example, if the URL is `/messages/0`, the first message (`Message Zero`) will be displayed. You use the [`int` converter](https://flask.palletsprojects.com/en/2.0.x/quickstart/#variable-rules) to accept only positive integers, because URL variables have string values by default. 



Inside the `message()` view function, you have a regular Python list called `messages` with three messages. (In a real-world scenario, these messages would come from a database, an API, or another external data source.) The function returns a call to the `render_template()` function with two arguments, `message.html` as the template file, and a `message` variable that will be passed to the template. This variable will have a list item from the `messages` list depending on the value of the `idx` variable in the URL.



Next open a new `message.html` template file:



```custom_prefix((env)sammy@localhost:$)

nano templates/message.html

```



Add the following code to it:



```html

[label flask_app/templates/message.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Messages {% endblock %}</h1>

    <h2>{{ message }}</h2>

{% endblock %}

```



Save and close the file.



In the code above, you extend the base template and override the `content` block. You add a title (`Messages`) in an H1 heading, and display the value of the `message` variable in an H2 heading.



With the development server running, visit the following URLs on your browser:



```

http://127.0.0.1:5000/messages/0

http://127.0.0.1:5000/messages/1

http://127.0.0.1:5000/messages/2

http://127.0.0.1:5000/messages/3

```



You'll see that the `H2` contains the text `Message Zero`, `Message One`, or  `Message Two` respectively on each one of the first three URLs. However, on the fourth URL, the server will respond with an `IndexError: list index out of range` error message. In a production environment, the response would've been a `500 Internal Server Error`, but the proper response here is a `404 Not Found` to indicate that the server can't find a message with an index of `3`.



You can respond with a `404` error using Flask's `abort()` helper function. To do so, open the `app.py` file:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Edit the first line to import the `abort()` function. Then edit the `message()` view function by adding a [`try ... except` clause](https://docs.python.org/3/tutorial/errors.html) as shown in the highlighted parts below:



```python

[label flask_app/app.py]

from flask import Flask, render_template, abort



# ...

# ...





@app.route('/messages/<int:idx>')

def message(idx):

    messages = ['Message Zero', 'Message One', 'Message Two']

    try:

        return render_template('message.html', message=messages[idx])

    except IndexError:

        abort(404)

```



Save and close the file.



In the code above, you import the [`abort()`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.abort) function, which you use to abort the request and respond with an error. In the `message()` view function, you use a `try ... except` clause to wrap the function. You first try to return the `messages` template with the message that corresponds to the index in the URL. If the index has no corresponding message, the `IndexError` exception will be raised. You then use the `except` clause to catch that error, and you use `abort(404)` to abort the request and respond with a `404 Not Found` HTTP error.



With the development server running, use your browser to revisit the URL that responded with an `IndexError` earlier (or visit any URL with an index greater than 2):



```

http://127.0.0.1:5000/messages/3

```



You will see the following response:



```

Not Found



The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.

```



You now have a better error message that indicates that the server could not find the requested message.



Next, you'll make a template for the 404 error page and one for the 500 error page.



First, you'll register a function with the special `@app.errorhandler()` decorator as a handler for the `404` error. Open the `app.py` file for editing:



```

nano app.py

```



Edit the file by adding the highlighted part as follows:



```python

[label flask_app/app.py]

from flask import Flask, render_template, abort



app = Flask(__name__)





@app.errorhandler(404)

def page_not_found(error):

    return render_template('404.html'), 404





@app.route('/')

def index():

    return render_template('index.html')





@app.route('/messages/<int:idx>')

def message(idx):

    messages = ['Message Zero', 'Message One', 'Message Two']

    try:

        return render_template('message.html', message=messages[idx])

    except IndexError:

        abort(404)

```

Save and close the file.



Here you use the `@app.errorhandler()` decorator to register the function `page_not_found()` as a custom error handler. The function takes the error as an argument, and it returns a call to the `render_template()` function with a template called `404.html`. You will create this template later, and you can use another name if you want. You also return the integer `404` after the `render_template()` call. This tells Flask that the status code in the response should be `404`. If you don't add it, the default status code response will be [`200`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200), which means that the request has succeeded.



Next, open a new `404.html` template:



```custom_prefix((env)sammy@localhost:$)

nano templates/404.html

```



Add the following code to it:



```html

[label flask_app/templates/404.html]

{% extends 'base.html' %}



{% block content %}

        <h1>{% block title %} 404 Not Found. {% endblock %}</h1>

        <p>OOPS! Sammy couldn't find your page; looks like it doesn't exist.</p>

        <p>If you entered the URL manually, please check your spelling and try again.</p>

{% endblock %}

```

Save and close the file.



Just like any other template, you extend the base template, you replace the content of the `content` and `title` blocks, and you add your own HTML code. Here you have an `<h1>` heading as the title, a `<p>` tag with a custom error message telling the user the page was not found, and a helpful message for users who might have entered the URL manually.



You can use whatever HTML, CSS, and JavaScript you want in your error pages in the same way you would in other templates.



With the development server running, use your browser to revisit the following URL:



```

http://127.0.0.1:5000/messages/3

```



You'll see the page now has the navigation bar that's in the base template and the custom error message.



Similarly, you can add a custom error page for your `500 Internal Server Error` errors. Open the `app.py` file:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Add the following error handler below the `404` error handler:



```python

[label flask_app/app.py]

# ...



@app.errorhandler(404)

def page_not_found(error):

    return render_template('404.html'), 404





@app.errorhandler(500)

def internal_error(error):

    return render_template('500.html'), 500



# ...

```



Here you use the same pattern as you did for the `404` error handler. You use the `app.errorhandler()` decorator with a `500` argument to make a function called `internal_error()` into an error handler. You render a template called `500.html`, and respond with a status code of `500`.



Then to demonstrate how the custom error will be presented, add a route that responds with a `500` HTTP error at the end of the file. This route will always give a `500 Internal Server Error` regardless of whether the debugger is running or not:



```python

[label flask_app/app.py]



# ...

@app.route('/500')

def error500():

    abort(500)

```



Here you make a route `/500` and use the `abort()` function to respond with a `500` HTTP error.



Save and close the file.



Next, open the new `500.html` template:



```custom_prefix((env)sammy@localhost:$)

nano templates/500.html

```



Add the following code to it:



```html

[label flask_app/templates/500.html]

{% extends 'base.html' %}



{% block content %}

        <h1>{% block title %} 500 Internal Server Error {% endblock %}</h1>

        <p>OOOOPS! Something went wrong on the server.</p>

        <p>Sammy is currently working on this issue. Please try again later.</p>

{% endblock %}

```



Save and close the file.



Here, you do the same thing you did with the `404.html` template. You extend the base template, and replace the content block with a title and two custom messages informing the user about the internal server error.



With the development server running, visit the route that responds with a `500` error:



```

http://127.0.0.1:5000/500

```



Your custom page will appear instead of the generic error page.



You now know how to use custom error pages for HTTP errors in your Flask application. Next, you'll learn how to use logging to track events in your application. Tracking events helps you understand how your code behaves, which in turn helps with development and troubleshooting.



## Step 3 — Using Logging to Track Events in Your Application



In this step, you will use logging to track events that happen when the server is running and the application is being used, which helps you see what is going on in your application code so you can troubleshoot errors easier.



You have already seen logs whenever the development server is running, which typically look like this:



```

127.0.0.1 - - [21/Sep/2021 14:36:45] "GET /messages/1 HTTP/1.1" 200 -

127.0.0.1 - - [21/Sep/2021 14:36:52] "GET /messages/2 HTTP/1.1" 200 -

127.0.0.1 - - [21/Sep/2021 14:36:54] "GET /messages/3 HTTP/1.1" 404 -

```



In these logs, you can see the following information:



* `127.0.0.1`: The host the server was running on.

* `[21/Sep/2021 14:36:45]`: The date and time of the request.

* `GET`: The [HTTP request method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET). In this case, `GET` is used to retrieve data.

* `/messages/2`: The path the user requested.

* `HTTP/1.1`: The HTTP version.

* `200` or `404`: The status code of the response.



These logs help you diagnose problems that occur in your application. You can log more information when you want to know more details about certain requests using the logger `app.logger` Flask provides.



With logging, you can use different functions to report information on different logging levels. Each level indicates an event happened with a certain degree of severity. The following functions can be used:



* `app.logger.debug()`: For detailed information about the event.

* `app.logger.info()`: Confirmation that things are working as expected.

* `app.logger.warning()`: Indication that something unexpected happened (such as "disk space low"), but the application is working as expected.

* `app.logger.error()`: An error occurred in some part of the application.

* `app.logger.critical()`: A critical error; the entire application might stop working.



To demonstrate how to use the Flask logger, open your `app.py` file for editing to log a few events:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Edit the `message()` view function to look as follows:



```python

[label flask_app/app.py]



# ...



@app.route('/messages/<int:idx>')

def message(idx):

    app.logger.info('Building the messages list...')

    messages = ['Message Zero', 'Message One', 'Message Two']

    try:

        app.logger.debug('Get message with index: {}'.format(idx))

        return render_template('message.html', message=messages[idx])

    except IndexError:

        app.logger.error('Index {} is causing an IndexError'.format(idx))

        abort(404)



# ...

```

Save and close the file.



Here, you logged a few events on different levels. You use `app.logger.info()` to log an event that's working as expected (which is an `INFO` level). You use `app.logger.debug()` for detailed information (`DEBUG` level), mentioning that the application is now getting a message with a specific index. Then you use `app.logger.error()` to log the fact that an `IndexError` exception has been raised with the specific index that caused the issue (`ERROR` level, because an error occurred).



Visit the following URL:



```

http://127.0.0.1:5000/messages/1

```



You'll see the following information in the terminal where your server is running:

```

[secondary_label Output]



[2021-09-21 15:17:02,625] INFO in app: Building the messages list...

[2021-09-21 15:17:02,626] DEBUG in app: Get message with index: 1

127.0.0.1 - - [21/Sep/2021 15:17:02] "GET /messages/1 HTTP/1.1" 200 -

```

Here you see the `INFO` message `app.logger.info()` logs, and the `DEBUG` message with the index number that you logged using `app.logger.debug()`.



Now visit a URL for a message that does not exist:



```

http://127.0.0.1:5000/messages/3

```



You'll see the following information in the terminal:



```

[secondary_label Output]

[2021-09-21 15:33:43,899] INFO in app: Building the messages list...

[2021-09-21 15:33:43,899] DEBUG in app: Get message with index: 3

[2021-09-21 15:33:43,900] ERROR in app: Index 3 is causing an IndexError

127.0.0.1 - - [21/Sep/2021 15:33:43] "GET /messages/3 HTTP/1.1" 404 -

```

As you can see, you have `INFO` and `DEBUG` logs that you've seen before, and a new `ERROR` log because a message with an index of `3` does not exist.



Logging events, detailed information, and errors helps you identify where something went wrong and makes troubleshooting easier.



You've learned in this step how to use the Flask logger. Check out [How To Use Logging in Python 3](https://www.digitalocean.com/community/tutorials/how-to-use-logging-in-python-3) for a better understanding of logging. For an in-depth look at logging, see [the Flask logging documentation](https://flask.palletsprojects.com/en/2.0.x/logging/) and [the Python documentation for logging](https://docs.python.org/3/library/logging.html).



## Conclusion

You now know how to use debug mode in Flask, and how to troubleshoot and fix some common errors you may encounter when developing a Flask web application. You've also created custom error pages for common HTTP errors, and you've used the Flask logger to track events in your application to help you inspect and figure out how your application behaves.



If you would like to read more about Flask, check out [the Flask topic page](https://www.digitalocean.com/community/tags/flask).





## How To Use Web Forms in a Flask Application

_The author selected the [Free and Open Source Fund](https://www.brightfunds.org/funds/foss-nonprofits) to receive a donation as part of the [Write for DOnations](https://do.co/w4do-cta) program._



### Introduction



Web forms, such as text fields and text areas, give users the ability to send data to your application to use it to perform an action, or to send larger areas of text to the application. For example, in a social media application, you might give users a box where they can add new content to their pages. Another example is a login page, where you would give the user a text field to enter their username and a password field to enter their password. The server (your Flask application in this case) uses the data the user submits and either signs them in if the data is valid, or responds with a message like `Invalid credentials!` to inform the user that the data they submitted is not correct.



[Flask](http://flask.pocoo.org/) is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. In this tutorial, you'll build a small web application that demonstrates how to use web forms. The application will have a page for displaying messages that are stored in a Python list, and a page for adding new messages. You'll also use [_message flashing_](https://flask.palletsprojects.com/en/2.0.x/patterns/flashing/) to inform users of an error when they submit invalid data.



## Prerequisites



* A local Python 3 programming environment, follow the tutorial for your distribution in [How To Install and Set Up a Local Programming Environment for Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-python-3) series. In this tutorial, we’ll call the project directory `flask_app`.



* An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out [How to Create Your First Web Application Using Flask and Python](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3) and [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).



* An understanding of basic HTML concepts. You can review our [How To Build a Website with HTML](https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html) tutorial series for background knowledge.



## Step 1 — Displaying Messages

In this step, you'll create a Flask application with an index page for displaying messages that are stored in a list of Python dictionaries.



First open a new file called `app.py` for editing:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Add the following code inside the `app.py` file to create a Flask server with a single route:



```python

[label flask_app/app.py]

from flask import Flask, render_template



app = Flask(__name__)



messages = [{'title': 'Message One',

             'content': 'Message One Content'},

            {'title': 'Message Two',

             'content': 'Message Two Content'}

            ]



@app.route('/')

def index():

    return render_template('index.html', messages=messages)

```



Save and close the file.



In this file, you first import the `Flask` class and the `render_template()` function from the `flask` package. You then use the `Flask` class to create a new _application instance_ called `app`, passing the special `__name__` variable, which is needed for Flask to set up some paths behind the scenes.  Rendering templates is covered in the tutorial [How To Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).



You then create a global Python list called `messages`, which has Python dictionaries inside it. Each dictionary has two keys: `title` for the title of the message, and `content` for the message content. This is a simplified example of a data storage method; in a real-world scenario, you'd use a database that permanently saves the data and allows you to manipulate it more efficiently.



After creating the Python list, you use the `@app.route()` decorator to create a _view function_ called `index()`. In it, you return a call to the `render_template()` function, which indicates to Flask that the route should display an HTML template. You name this template `index.html` (you'll create it later), and you pass a variable called `messages` to it. This variable holds the `messages` list you previously declared as a value and makes it available to the HTML template. View functions are covered in the tutorial [How To Create Your First Web Application Using Flask and Python 3](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3).



Next, create a `templates` folder in your `flask_app` directory where Flask searches for templates, then open a template file called `base.html`, which will have code that other templates will inherit to avoid code repetition:



```custom_prefix((env)sammy@localhost:$)

mkdir templates

nano templates/base.html

```



Add the following code inside the `base.html` file to create the base template with a navbar and a content block:



```html

[label flask_app/templates/base.html]



<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>{% block title %} {% endblock %} - FlaskApp</title>

    <style>

        .message {

            padding: 10px;

            margin: 5px;

            background-color: #f3f3f3

        }

        nav a {

            color: #d64161;

            font-size: 3em;

            margin-left: 50px;

            text-decoration: none;

        }



    </style>

</head>

<body>

    <nav>

        <a href="{{ url_for('index') }}">FlaskApp</a>

        <a href="#">About</a>

    </nav>

    <hr>

    <div class="content">

        {% block content %} {% endblock %}

    </div>

</body>

</html>

```

Save and close the file.



This base template has all the HTML boilerplate you’ll need to reuse in your other templates. The `title` block will be replaced to set a title for each page, and the `content` block will be replaced with the content of each page. The navigation bar has two links, one for the index page where you use the `url_for()` helper function to link to the `index()` view function, and the other for an About page if you choose to include one in your application.



Next, open a template called `index.html`. This is the template you referenced in the `app.py` file:



```custom_prefix((env)sammy@localhost:$)

nano templates/index.html

```



Add the following code to it:



```html

[label flask_app/templates/index.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Messages {% endblock %}</h1>

    {% for message in messages %}

        <div class='message'>

            <h3>{{ message['title'] }}</h3>

            <p>{{ message['content'] }}</p>

        </div>

    {% endfor %}

{% endblock %}

```

Save and close the file.



In this code, you extend the `base.html` template and replace the contents of the `content` block. You use an `<h1>` heading that also serves as a title.



You use a [Jinja `for` loop](https://jinja.palletsprojects.com/en/3.0.x/templates/#for) in the line `{% for message in messages %}` to go through each message in the `messages` list. You use a `<div>` tag to contain the message's title and content. You display the title in an `<h3>` heading and the content in a `<p>` tag.



While in your `flask_app` directory with your virtual environment activated, tell Flask about the application (`app.py` in this case) using the `FLASK_APP` environment variable:



```custom_prefix((env)sammy@localhost:$)

export FLASK_APP=app

```



Then set the `FLASK_ENV` environment variable to `development` to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see [How To Handle Errors in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-handle-errors-in-a-flask-application). Use the following commands to do this (on Windows, use  `set` instead of `export`):



```custom_prefix((env)sammy@localhost:$)

export FLASK_ENV=development

```



Next, run the application:



```custom_prefix((env)sammy@localhost:$)

flask run

```



With the development server running, visit the following URL using your browser:



```

http://127.0.0.1:5000/

```



You'll see the messages in the `messages` list displayed on the index page:



![Index Page](https://assets.digitalocean.com/68050/hFm7YKr.png)



Now that you have set up your web application and displayed the messages, you'll need a way to allow users to add new messages to the index page. This is done through web forms, which you'll set up in the next step.



## Step 2 — Setting Up Forms

In this step, you will create a page in your application that allows users to add new messages into the list of messages via a web form.



Leave the development server running and open a new terminal window.



First, open your `app.py` file:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Add the following route to the end of the file:

```python

[label flask_app/app.py]

# ...



@app.route('/create/', methods=('GET', 'POST'))

def create():

    return render_template('create.html')

```



Save and close the file.



This `/create` route has the `methods` parameter with the tuple `('GET', 'POST')` to accept both `GET` and `POST` requests. `GET` and `POST` are [HTTP methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods). By default, only `GET` requests are accepted,  which are used to retrieve data, such as asking the server for an index page or an About page. `POST` requests are used to submit data to a specific route, which often changes the data on the server. 



In this example, you will ask for the `create` page using a `GET` request. The Create page will have a web form with input fields and a Submit button. When a user fills in the web form and clicks the Submit button, a `POST` request gets sent to the `/create` route. There you handle the request, validate the submitted data to ensure the user has not submitted an empty form, and add it to the `messages` list.



The `create()` view function currently does only one thing: render a template called `create.html` when it receives a regular GET request. You will now create this template, then edit the function to handle `POST` requests in the next step.



Open a new template file called `create.html`:



```custom_prefix((env)sammy@localhost:$)

nano templates/create.html

```



Add the following code to it:



```html

[label flask_app/templates/create.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Add a New Message {% endblock %}</h1>

    <form method="post">

        <label for="title">Title</label>

        <br>

        <input type="text" name="title"

               placeholder="Message title"

               value="{{ request.form['title'] }}"></input>

        <br>



        <label for="content">Message Content</label>

        <br>

        <textarea name="content"

                  placeholder="Message content"

                  rows="15"

                  cols="60"

                  >{{ request.form['content'] }}</textarea>

        <br>

        <button type="submit">Submit</button>

    </form>

{% endblock %}



```

Save and close the file.



In this code, you extend the `base.html` template and replace the `content` block with an `<h1>` heading that serves as a title for the page. In the `<form>` tag, you set the `method` attribute to `post` so the form data gets sent to the server as a `POST` request. 



In the form, you have a text input field named `title`; this is the name you'll use on the application to access the title form data. You give the `<input>` tag a `value` of `{{ request.form['title'] }}`. This is useful to restore the data the user enters so it does not get lost when things go wrong. For example, if the user forgets to fill in the required `content` text area, a request gets sent to the server and an error message will come back as a response, but the data in the title will not be lost because it will be saved on the `request` global object, and can be accessed via `request.form['title']`.



After the title input field, you add a text area named `content` with the value `{{ request.form['content'] }}` for the same reasons mentioned previously.



Last, you have a Submit button at the end of the form.



Now, with the development server running, use your browser to navigate to the `/create` route:



```

http://127.0.0.1:5000/create

```



You will see an "Add a New Message" page with an input field for a message title, a text area for the message's content, and a Submit button.



![Add a new message](https://assets.digitalocean.com/68050/YxB8Khp.png)



This form submits a `POST` request to your `create()` view function. However, there is no code to handle a `POST` request in the function yet, so nothing happens after filling in the form and submitting it. In the next step, you'll handle the incoming `POST` request when a form is submitted. You'll check whether the submitted data is valid (not empty), and add the message title and content to the `messages` list.



## Step 3 — Handling Form Requests

In this step, you will handle form requests on the application side. You'll access the form data the user submits via the form you created in the previous step and add it to the list of messages. You'll also use [_message flashing_](https://flask.palletsprojects.com/en/2.0.x/patterns/flashing/) to inform users when they submit invalid data. The _flash message_ will only be shown once and will disappear on the next request (if you navigate to another page for example).



Open the `app.py` file for editing:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



First, you’ll import the following from the Flask framework:



* The global [`request`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.request) object to access incoming request data that will be submitted via the HTML form you built in the last step.

* The [`url_for()`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.url_for) function to generate URLs.

* The [`flash()`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.flash) function to flash a message when a request is processed (to inform the user that everything went well, or to inform them of an issue if the submitted data is not valid).

* The [`redirect()`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.redirect) function to redirect the client to a different location.



Add these imports to the first line in the file:



```python

[label flask_app/app.py]

from flask import Flask, render_template, request, url_for, flash, redirect



# ...

```



The `flash()` function stores flashed messages in the client’s browser session, which requires setting a _secret key_. This secret key is used to secure sessions, which allow Flask to remember information from one request to another, such as moving from the new message page to the index page. The user can access the information stored in the session, but cannot modify it unless they have the secret key, so you must never allow anyone to access your secret key. See [the Flask documentation for sessions](https://flask.palletsprojects.com/en/2.0.x/api/#sessions) for more information.



The secret key should be a long random string. You can generate a secret key using the `os` module with the [`os.urandom()`](https://docs.python.org/3.8/library/os.html#os.urandom) method, which returns a string of random bytes suitable for cryptographic use. To get a random string using it, open a new terminal and open the Python interactive shell using the following command:



```custom_prefix((env)sammy@localhost:$)

python

```



In the Python interactive shell, import the `os` module from the standard library and call the `os.urandom()` method as follows:



```custom_prefix(>>>)

import os

os.urandom(24).hex()

```



You'll get a string similar to the following:



```

[secondary_label Output]



'df0331cefc6c2b9a5d0208a726a5d1c0fd37324feba25506'

```



You can use the string you get as your secret key.



To set the secret key, add a `SECRET_KEY` configuration to your application via the `app.config` object. Add it directly following the `app` definition before defining the `messages` variable:



```python

[label flask_app/app.py]



# ...

app = Flask(__name__)

app.config['SECRET_KEY'] = 'your secret key'





messages = [{'title': 'Message One',

             'content': 'Message One Content'},

            {'title': 'Message Two',

             'content': 'Message Two Content'}

            ]

# ...

```



Next, modify the `create()` view function to look exactly as follows:



```python

[label flask_app/app.py]

# ...



@app.route('/create/', methods=('GET', 'POST'))

def create():

    if request.method == 'POST':

        title = request.form['title']

        content = request.form['content']



        if not title:

            flash('Title is required!')

        elif not content:

            flash('Content is required!')

        else:

            messages.append({'title': title, 'content': content})

            return redirect(url_for('index'))



    return render_template('create.html')

```



In the `if` statement you ensure that the code following it is only executed when the request is a `POST` request via the comparison `request.method == 'POST'`.



You then extract the submitted title and content from the `request.form` object that gives you access to the form data in the request. If the title is not provided, the condition `if not title` would be fulfilled. In that case, you display a message to the user informing them that the title is required using the `flash()` function. This adds the message to a _flashed messages_ list. You will later display these messages on the page as part of the `base.html` template.  Similarly, if the content is not provided, the condition `elif not content` will be fulfilled. If so, you add the `'Content is required!'`  message to the list of flashed messages. 



If the title and the content of the message are properly submitted, you use the line `messages.append({'title': title, 'content': content})` to add a new dictionary to the `messages` list, with the title and content the user provided. Then you use the `redirect()` function to redirect users to the index page. You use the `url_for()` function to link to the index page.



Save and close the file.



Now, navigate to the `/create` route using your web browser:



```

http://127.0.0.1:5000/create

```



Fill in the form with a title of your choice and some content. Once you submit the form, you will see the new message listed on the index page.



Lastly, you’ll display flashed messages and add a link for the "New Message" page to the navigation bar in the `base.html` template to have easy access to this new page. Open the base template file:



```custom_prefix((env)sammy@localhost:$)

nano templates/base.html

```



Edit the file by adding a new `<a>` tag after the FlaskApp link in the navigation bar inside the `<nav>` tag. Then add a new `for` loop directly above the `content` block to display the flashed messages below the navigation bar. These messages are available in the special `get_flashed_messages()` function Flask provides. Then add a class attribute called `alert` to each message and give it some CSS properties inside the `<style>` tag:



```html

[label flask_app/templates/base.html]

<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>{% block title %} {% endblock %} - FlaskApp</title>

    <style>

        .message {

            padding: 10px;

            margin: 5px;

            background-color: #f3f3f3

        }

        nav a {

            color: #d64161;

            font-size: 3em;

            margin-left: 50px;

            text-decoration: none;

        }



        .alert {

            padding: 20px;

            margin: 5px;

            color: #970020;

            background-color: #ffd5de;

        }



    </style>

</head>

<body>

    <nav>

        <a href="{{ url_for('index') }}">FlaskApp</a>

        <a href="{{ url_for('create') }}">Create</a>

        <a href="#">About</a>

    </nav>

    <hr>

    <div class="content">

        {% for message in get_flashed_messages() %}

            <div class="alert">{{ message }}</div>

        {% endfor %}

        {% block content %} {% endblock %}

    </div>

</body>

</html>

```



Save and close the file, and then reload `https://127.0.0.1:5000` in your browser. The navigation bar will now have a "Create" item that links to the `/create` route.



To see how flash messages work, go to the "Create" page, and click the Submit button without filling the two fields. You'll receive a message that looks like this:



![No title no content flash message](https://assets.digitalocean.com/68050/XoTXYvD.png)



Go back to the index page and you'll see that the flashed messages below the navigation bar disappear, even though they are displayed as part of the base template. If they weren't flashed messages, they would be displayed on the index page too, because it also inherits from the base template.



Try submitting the form with a title but no content. You'll see the message "Content is required!". Click the FlaskApp link in the navigation bar to go back to the index page, then click the Back button to come back to the Create page. You'll see that the message content is still there. This only works if you click the Back button, because it saves the previous request. Clicking the Create link in the navigation bar will send a new request, which clears the form, and as a result, the flashed message will disappear.



You now know how to receive user input, how to validate it, and how to add it to a data source.



<$>[note]

**Note:**

The messages you add to the `messages` list will disappear whenever the server is stopped, because Python lists are only saved in memory, to save your messages permanently, you will need to use a database like SQLite. Check out [How To Use the sqlite3 Module in Python 3](https://www.digitalocean.com/community/tutorials/how-to-use-the-sqlite3-module-in-python-3) to learn how to use SQLite with Python.

<$>



## Conclusion



You created a Flask application where users can add messages to a list of messages displayed on the index page. You created a web form, handled the data the user submits via the form, and added it to your messages list. You also used flash messages to inform the user when they submit invalid data.



If you would like to read more about Flask, check out [the other tutorials in the Flask series](https://www.digitalocean.com/community/tutorial_series/how-to-create-web-sites-with-flask).





## How To Use and Validate Web Forms with Flask-WTF

*The author selected the [Free and Open Source Fund](https://www.brightfunds.org/funds/foss-nonprofits) to receive a donation as part of the [Write for DOnations](https://do.co/w4do-cta) program.*



### Introduction



Web forms, such as text fields and text areas, give users the ability to send data to your application, whether that's a drop-down or a radio button that the application will use to perform an action, or to send large areas of text to be processed or displayed. For example, in a social media application, you might give users a box where they can add new content to their pages.



[Flask](http://flask.pocoo.org/) is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. To render and validate web forms in a safe and flexible way in Flask, you'll use [Flask-WTF](https://flask-wtf.readthedocs.io/en/1.0.x/), which is a Flask extension that helps you use the [WTForms](https://wtforms.readthedocs.io/en/3.0.x/) library in your Flask application.



[WTForms](https://wtforms.readthedocs.io/en/3.0.x/) is a Python library that provides flexible web form rendering. You can use it to render text fields, text areas, password fields, radio buttons, and others. WTForms also provides powerful data validation using different _validators_, which validate that the data the user submits meets certain criteria you define. For example, if you have a required field, you can ensure data the user submits is provided, or has a certain length.



WTForms also uses a CSRF token to provide protection from [CSRF attacks](https://owasp.org/www-community/attacks/csrf), which are attacks that allows the attacker to execute unwanted actions on a web application in which the user is authenticated. A successful CSRF attack can force the user to perform state-changing requests like transferring funds to the attacker's bank account in a banking application, changing the user's email address, and so forth. If the victim is an administrative account, CSRF can compromise the entire web application.



In this tutorial, you’ll build a small web application that demonstrates how to render and validate web forms using Flask-WTF. The application will have a page for displaying courses that are stored in a Python list, and the index page will have a form for entering the course title, its description, price, availability, and level (beginner, intermediate, or advanced).



## Prerequisites



* A local Python 3 programming environment. Follow the tutorial for your operating system in the [How To Install and Set Up a Local Programming Environment for Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-python-3) series. In this tutorial you’ll call the project directory `flask_app`.



* An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out [How to Create Your First Web Application Using Flask and Python](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3) and [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).



* An understanding of basic HTML concepts. You can review our [How To Build a Website with HTML](https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html) tutorial series for background knowledge.



* (_optional_) An understanding of basic web form usage in Flask. See [How To Use Web Forms in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-web-forms-in-a-flask-application).



## Step 1 — Installing Flask and Flask-WTF

In this step, you'll install Flask and Flask-WTF, which also installs the WTForms library automatically.



With your virtual environment activated, use `pip` to install Flask and Flask-WTF:



```custom_prefix((env)sammy@localhost:$)

pip install Flask Flask-WTF

```



Once the installation is successfully finished, you'll see a line similar to the following at the end of the output:



```

[secondary_label Output]

Successfully installed Flask-2.0.2 Flask-WTF-1.0.0 Jinja2-3.0.3 MarkupSafe-2.0.1 WTForms-3.0.0 Werkzeug-2.0.2 click-8.0.3 itsdangerous-2.0.1

```



As you can see, the [WTForms](https://wtforms.readthedocs.io/en/3.0.x/) library was also installed as a dependency of the Flask-WTF package. The rest of the packages are Flask dependencies.



Now that you've installed the required Python packages, you'll set up a web form next.



## Step 2 — Setting up Forms

In this step, you'll set up a web form using fields and validators you'll import from the WTForms library.



You'll set up the following fields:



* **Title:** A text input field for the course title.

* **Description:** A text area field for the course description.

* **Price:** An integer field for the price of the course.

* **Level:** A radio field for the course level with three choices: Beginner, Intermediate, and Advanced.

* **Available:** A checkbox field that indicates whether the course is currently available.



First, open a new file called `forms.py` in your `flask_app` directory. This file will have the forms you'll need in your application:



```custom_prefix((env)sammy@localhost:$)

nano forms.py

```



This file will have a class that represents your web form. Add the following imports at the top:



```python

[label flask_app/forms.py]

from flask_wtf import FlaskForm

from wtforms import (StringField, TextAreaField, IntegerField, BooleanField,

                     RadioField)

from wtforms.validators import InputRequired, Length



```

To build a web form, you will create a subclass of the `FlaskForm` base class, which you import from the `flask_wtf` package. You also need to specify the fields you use in your form, which you will import from the `wtforms` package.



You import the following [fields](https://wtforms.readthedocs.io/en/3.0.x/fields/) from the WTForms library:



* [`StringField`](https://wtforms.readthedocs.io/en/3.0.x/fields/#wtforms.fields.StringField): A text input.

* [`TextAreaField`](https://wtforms.readthedocs.io/en/3.0.x/fields/#wtforms.fields.TextAreaField): A text area field.

* [`IntegerField`](https://wtforms.readthedocs.io/en/3.0.x/fields/#wtforms.fields.IntegerField): A field for integers.

* [`BooleanField`](https://wtforms.readthedocs.io/en/3.0.x/fields/#wtforms.fields.BooleanField): A checkbox field.

* [`RadioField`](https://wtforms.readthedocs.io/en/3.0.x/fields/#wtforms.fields.RadioField): A field for displaying a list of radio buttons for the user to choose from.



In the line `from wtforms.validators import InputRequired, Length`, you import validators to use on the fields to make sure the user submits valid data. [`InputRequired`](https://wtforms.readthedocs.io/en/3.0.x/validators/#wtforms.validators.InputRequired) is a validator you'll use to ensure the input is provided, and [`Length`](https://wtforms.readthedocs.io/en/3.0.x/validators/#wtforms.validators.Length) is for validating the length of a string to ensure it has a minimum number of characters, or that it doesn't exceed a certain length.



Next, add the following [class](https://www.digitalocean.com/community/tutorials/how-to-construct-classes-and-define-objects-in-python-3) after the `import` statements:



```python

[label flask_app/forms.py]



class CourseForm(FlaskForm):

    title = StringField('Title', validators=[InputRequired(),

                                             Length(min=10, max=100)])

    description = TextAreaField('Course Description',

                                validators=[InputRequired(),

                                            Length(max=200)])

    price = IntegerField('Price', validators=[InputRequired()])

    level = RadioField('Level',

                       choices=['Beginner', 'Intermediate', 'Advanced'],

                       validators=[InputRequired()])

    available = BooleanField('Available', default='checked')

```

Save and close the file.



In this `CourseForm` class, you inherit from the `FlaskForm` base class you imported earlier. You define a collection of form fields as class variables using the form fields you imported from the WTForms library. When you instantiate a field, the first argument is the field's label.



You define the validators for each field by passing a list of the validators you import from the `wtforms.validators` module. The title field, for example, has the string `'Title'` as a label, and two validators:



* `InputRequired`: To indicate that the field should not be empty.

* `Length`: Takes two arguments; `min` is set to `10` to make sure that the title is at least 10 characters long, and `max` is set to `100` to ensure it doesn't exceed 100 characters.



The description text area field has an `InputRequired` validator and a `Length` validator with the `max` parameter set to `200`, with no value for the `min` parameter, which means the only requirement is that it doesn't exceed 200 characters.



Similarly you define a required integer field for the price of the course called `price`.



The `level` field is a radio field with multiple choices. You define the choices in a Python list and pass it to the `choices` parameter. You also define the field as required using the `InputRequired` validator.



The `available` field is a check box field. You set a default `'checked'` value by passing it to the `default` parameter. This means the check box will be checked when adding new courses unless the user unchecks it, meaning courses are available by default.



For more on how to use the WTForms library, see the [Crash Course page](https://wtforms.readthedocs.io/en/3.0.x/crash_course/) on the WTForms documentation. See the [Fields page](https://wtforms.readthedocs.io/en/3.0.x/fields/) for more fields, and the [Validators page](https://wtforms.readthedocs.io/en/3.0.x/validators/) for more validators to validate form data.



You've configured your web form in a `forms.py` file. Next, you'll create a Flask application, import this form, and display its fields on the index page. You'll also display a list of courses on another page.



## Step 3 — Displaying the Web Form and Courses

In this step, you'll create a Flask application, display the web form you created in the previous step on the index page, and also create a list of courses and a page for displaying the courses on it.



With your programming environment activated and Flask installed, open a file called `app.py` for editing inside your `flask_app` directory:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



This file will import the necessary class and helpers from Flask, and the `CourseForm` from the `forms.py` file. You'll build a list of courses, then instantiate the form and pass it to a template file. Add the following code to `app.py`:



```python

[label flask_app/app.py]

from flask import Flask, render_template, redirect, url_for

from forms import CourseForm



app = Flask(__name__)

app.config['SECRET_KEY'] = 'your secret key'





courses_list = [{

    'title': 'Python 101',

    'description': 'Learn Python basics',

    'price': 34,

    'available': True,

    'level': 'Beginner'

    }]





@app.route('/', methods=('GET', 'POST'))

def index():

    form = CourseForm()

    return render_template('index.html', form=form)

```

Save and close the file.



Here you import the following from Flask:

* The `Flask` class to create a Flask application instance.

* The `render_template()` function to render the index template.

* The `redirect()` function to redirect the user to the courses page once a new course is added.

* The `url_for()` function for building URLs.



First you import the `CourseForm()` class from the `forms.py` file, then you create a Flask application instance called `app`.



You set up a _secret key_ configuration for WTForms to use when generating a CSRF token to secure your web forms. The secret key should be a long random string. See Step 3 of [How To Use Web Forms in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-web-forms-in-a-flask-application#step-3-%E2%80%94-handling-form-requests) for more information on how to obtain a secret key.



Then you create a list of dictionaries called `courses_list`, which currently has one dictionary with a sample course titled `'Python 101'`. Here, you use a Python list as a data store for demonstration purposes. In a real world scenario, you'll use a database such as SQLite. See [How To Use an SQLite Database in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-an-sqlite-database-in-a-flask-application) to learn how to use a database to store your courses' data.



You create a `/` main route using the `app.route()` decorator on the `index()` view function. It accepts both `GET` and `POST` [HTTP methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) in the `methods` parameter. GET methods are for retrieving data, and POST requests are for sending data to the server, through a web form for example. For more, see [How To Use Web Forms in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-web-forms-in-a-flask-application).



You instantiate the `CourseForm()` class that represents the web form and save the instance in a variable called `form`. You then return a call to the `render_template()` function, passing it a template file called `index.html` and the form instance.



To display the web form on the index page, you will first create a base template, which will have all the basic HTML code other templates will also use to avoid code repetition. Then you’ll create the `index.html` template file you rendered in your `index()` function. To learn more about templates, see [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).



Create a `templates` folder in your `flask_app` directory where Flask searches for templates, then open a template file called `base.html`, which will be the base template for other templates:



```custom_prefix((env)sammy@localhost:$)

mkdir templates

nano templates/base.html

```



Add the following code inside the `base.html` file to create the base template with a navbar and a content block:



```html

[label flask_app/templates/base.html]

<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>{% block title %} {% endblock %} - FlaskApp</title>

    <style>

        nav a {

            color: #d64161;

            font-size: 3em;

            margin-left: 50px;

            text-decoration: none;

        }

    </style>

</head>

<body>

    <nav>

        <a href="{{ url_for('index') }}">FlaskApp</a>

        <a href="#">About</a>

    </nav>

    <hr>

    <div class="content">

        {% block content %} {% endblock %}

    </div>

</body>

</html>

```



This base template has all the HTML boilerplate you’ll need to reuse in your other templates. The `title` block will be replaced to set a title for each page, and the `content` block will be replaced with the content of each page. The navigation bar has two links, one for the index page where you use the `url_for()` helper function to link to the `index()` view function, and the other for an About page if you choose to include one in your application.



Save and close the file.



Next, open a template called `index.html`. This is the template you referenced in the `app.py` file:



```custom_prefix((env)sammy@localhost:$)

nano templates/index.html

```



This file will have the web form you passed to the `index.html` template via the `form` variable. Add the following code to it:



```html

[label flask_app/templates/index.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Add a New Course {% endblock %}</h1>



    <form method="POST" action="/">

        {{ form.csrf_token }}

        <p>

            {{ form.title.label }}

            {{ form.title(size=20) }}

        </p>



        {% if form.title.errors %}

            <ul class="errors">

                {% for error in form.title.errors %}

                    <li>{{ error }}</li>

                {% endfor %}

            </ul>

        {% endif %}



        <p>

            {{ form.description.label }}

        </p>

        {{ form.description(rows=10, cols=50) }}



        {% if form.description.errors %}

            <ul class="errors">

                {% for error in form.description.errors %}

                    <li>{{ error }}</li>

                {% endfor %}

            </ul>

        {% endif %}



        <p>

            {{ form.price.label }}

            {{ form.price() }}

        </p>



        {% if form.price.errors %}

            <ul class="errors">

                {% for error in form.price.errors %}

                    <li>{{ error }}</li>

                {% endfor %}

            </ul>

        {% endif %}



        <p>

            {{ form.available() }} {{ form.available.label }}

        </p>



        {% if form.available.errors %}

            <ul class="errors">

                {% for error in form.available.errors %}

                    <li>{{ error }}</li>

                {% endfor %}

            </ul>

        {% endif %}



        <p>

            {{ form.level.label }}

            {{ form.level() }}

        </p>



        {% if form.level.errors %}

            <ul class="errors">

                {% for error in form.level.errors %}

                    <li>{{ error }}</li>

                {% endfor %}

            </ul>

        {% endif %}



        <p>

            <input type="submit" value="Add">

        </p>

    </form>



{% endblock %}

```



Save and close the file.



You extend the base template, and set a title in an `<h1>` tag. Then you render the web form fields inside a `<form>` tag, setting its method to `POST` and the action to the `/` main route, which is the index page. You first render the CSRF token WTForms uses to protect your form from CSRF attacks using the line `{{ form.csrf_token }}`. This token gets sent to the server with the rest of the form data. Remember to always render this token to secure your forms.



You render each field using the syntax `form.field()` and you render its label using the syntax `form.field.label`. You can pass arguments to the field to control how it is displayed. For example, you set the size of the title input field in `{{ form.title(size=20) }}`, and you set the numbers of rows and columns for the description text area via the parameters `rows` and `cols` the same way you would do normally in HTML. You can use the same method to pass additional HTML attributes to a field such as the `class` attribute to set a CSS class.



You check for validation errors using the syntax `if form.field.errors`. If a field has errors, you loop through them with a `for` loop and display them in a list below the field.



While in your `flask_app` directory with your virtual environment activated, tell Flask about the application (`app.py` in this case) using the `FLASK_APP` environment variable. Then set the `FLASK_ENV` environment variable to `development` to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see [How To Handle Errors in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-handle-errors-in-a-flask-application). Use the following commands to do this (on Windows, use `set` instead of `export`):



```custom_prefix((env)sammy@localhost:$)

export FLASK_APP=app

export FLASK_ENV=development

```



Next, run the application:



```custom_prefix((env)sammy@localhost:$)

flask run

```



With the development server running, visit the following URL using your browser:



```

http://127.0.0.1:5000/

```



You'll see the web form displayed on the index page:



![Index Page](https://assets.digitalocean.com/68100/28ijxDu.png)



Try to submit the form without filling in the title. You'll see an error message informing you that the title is required. Experiment with the form by submitting invalid data (such as a short title less than 10 characters long, or a description over 200 characters long) to see other error messages.



Filling the form with valid data does nothing so far because you don't have code that handles form submission. You'll add the code for that later.



For now, you need a page to display the courses you have in your list. Later, handling the web form data will add a new course to the list and redirect the user to the courses page to see the new course added to it.



Leave the development server running and open another terminal window.



Next, open `app.py` to add the courses route:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Add the following route at the end of the file:



```python

[label flask_app/app.py]

# ...



@app.route('/courses/')

def courses():

    return render_template('courses.html', courses_list=courses_list)

```



Save and close the file.



This route renders a template called `courses.html`, passing it the `courses_list` list.



Then create the `courses.html` template to display courses:

```custom_prefix((env)sammy@localhost:$)

nano templates/courses.html

```



Add the following code to it:



```html

[label flask_app/templates/courses.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Courses {% endblock %}</h1>

    <hr>

    {% for course in courses_list %}

        <h2> {{ course['title'] }} </h2>

        <h4> {{ course['description'] }} </h4>

        <p> {{ course['price'] }}$ </p>

        <p><i>({{ course['level'] }})</i></p>

        <p>Availability:

            {% if course['available'] %}

                Available

            {% else %}

                Not Available

            {% endif %}</p>

        <hr>

    {% endfor %}

{% endblock %}

```

Save and close the file.



You set a title and loop through the items of the `courses_list` list. You display the title in an `<h2>` tag, the description in an `<h4>` tag, and the price and course level in a `<p>` tag.

You check whether the course is available using the condition `if course['available']`. You display the text "Available" if the course is available, and the text "Not Available" if it's not available.



Use your browser to go to the courses page:



```

http://127.0.0.1:5000/courses/

```



You'll see a page with one course displayed, because you only have one course in your course list so far:



![Courses Page](https://assets.digitalocean.com/68100/mx2PZOk.png)



Next, open `base.html` to add a link to the courses page in the navigation bar:



```custom_prefix((env)sammy@localhost:$)

nano templates/base.html

```



Edit it to look as follows:



```html

[label flask_app/templates/base.html]

<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>{% block title %} {% endblock %} - FlaskApp</title>

    <style>

        nav a {

            color: #d64161;

            font-size: 3em;

            margin-left: 50px;

            text-decoration: none;

        }

    </style>

</head>

<body>

    <nav>

        <a href="{{ url_for('index') }}">FlaskApp</a>

        <a href="{{ url_for('courses') }}">Courses</a>

        <a href="#">About</a>

    </nav>

    <hr>

    <div class="content">

        {% block content %} {% endblock %}

    </div>

</body>

</html>

```



Save and close the file.



Refresh the index page, and you'll see a new **Courses** link in the navigation bar.



You've created the pages you need for your application: An index page with a web form for adding new courses and a page for displaying the courses you have in your list.



To make the application functional, you need to handle the web form data when the user submits it by validating it and adding it to the courses list. You'll do this next.



## Step 4 — Accessing Form Data

In this step, you'll access data the user submits, validate it, and add it to the list of courses.



Open `app.py` to add code for handling the web form data inside the `index()` function:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Edit the `index()` function to look as follows:



```python

[label flask_app/app.py]

# ...

@app.route('/', methods=('GET', 'POST'))

def index():

    form = CourseForm()

    if form.validate_on_submit():

        courses_list.append({'title': form.title.data,

                             'description': form.description.data,

                             'price': form.price.data,

                             'available': form.available.data,

                             'level': form.level.data

                             })

        return redirect(url_for('courses'))

    return render_template('index.html', form=form)

```

Save and close the file.

Here, you call the `validate_on_submit()` method on the `form` object, which checks that the request is a POST request, and runs the validators you configured for each field. If at least one validator returns an error, the condition will be `False`, and each error will be displayed below the field that caused it.



If the submitted form data is valid, the condition is `True`, and the code below the `if` statement will be executed. You build a course dictionary, and use the `append` method to add the new course to the `courses_list` list. You access the value of each field using the syntax `form.field.data`. After you add the new course dictionary to the courses list, you redirect the user to the `Courses` page.



With the development server running, visit the index page:



```

http://127.0.0.1:5000/

```



Fill the form with valid data and submit it. You'll be redirected to the `Courses` page, and you'll see the new course displayed on it.



## Conclusion

You made a Flask application that has a web form you built using the Flask-WTF extension and the WTForms library. The form has several types of fields to receive data from the user, validate it using special WTForms validators, and add it to a data store.



If you would like to read more about Flask, check out the other tutorials in the [How To Create Web Sites with Flask](https://www.digitalocean.com/community/tutorial_series/how-to-create-web-sites-with-flask) series.





## How To Use an SQLite Database in a Flask Application

_The author selected the [Free and Open Source Fund](https://www.brightfunds.org/funds/foss-nonprofits) to receive a donation as part of the [Write for DOnations](https://do.co/w4do-cta) program._



### Introduction



In web applications, you usually need a _database_, which is an organized collection of data. You use a database to store and maintain persistent data that can be retrieved and manipulated efficiently. For example, in a social media application, you have a database where user data (personal information, posts, comments, followers) is stored in a way that can be efficiently manipulated. You can add data to a database, retrieve it, modify it, or delete it, depending on different requirements and conditions. In a web application, these requirements might be a user adding a new post, deleting a post, or deleting their account, which might or might not delete their posts. The actions you perform to manipulate data will depend on specific features in your application. For example, you might not want users to add posts with no titles.



[Flask](http://flask.pocoo.org/) is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. [SQLite](https://www.sqlite.org/index.html) is a simple and fast open source [SQL engine](https://en.wikipedia.org/wiki/Database_engine) that can be used with Python to store and manipulate application data. SQLite works well with Python because the Python standard library provides the [`sqlite3` module](https://docs.python.org/3/library/sqlite3.html), which you can use to interact with any SQLite database without having to install anything. Using SQLite with Python also requires minimal setup compared to other database engines.



In this tutorial, you'll build a small web application that demonstrates how to use SQLite with Flask to perform basic data manipulation covering CRUD: Create, Read, Update, and Delete. The web application will be a basic blog that displays posts on the index page. Users can create, edit, and delete individual posts.



## Prerequisites



* A local Python 3 programming environment, follow the tutorial for your distribution in [How To Install and Set Up a Local Programming Environment for Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-python-3) series. In this tutorial we’ll call our project directory `flask_app`.



* An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out [How to Create Your First Web Application Using Flask and Python](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3) and [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).



* An understanding of basic HTML concepts. You can review our [How To Build a Website with HTML](https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html) tutorial series for background knowledge.



* A basic understanding of how to use SQLite. See [How To Install and Use SQLite on Ubuntu 20.04](https://www.digitalocean.com/community/tutorials/how-to-install-and-use-sqlite-on-ubuntu-20-04).



## Step 1 — Setting up the Database

In this step, you'll set up the SQLite database you'll use to store your data (the blog posts for your application). You'll then populate the database with a few example entries.



You will use the [`sqlite3`](https://www.digitalocean.com/community/tutorials/how-to-use-the-sqlite3-module-in-python-3) module to interact with the database, which is readily available in the standard Python library.



Data in SQLite is stored in tables and columns, so you first need to create a table called `posts` with the necessary columns. You’ll create a `.sql` file that contains SQL commands to create the `posts` table with a few columns. You’ll then use this *schema file* to create the database.



Open a database schema file called `schema.sql` inside your `flask_app` directory:



```command

nano schema.sql

```



Type the following SQL commands inside this file:



```sql

[label flask_app/schema.sql]

DROP TABLE IF EXISTS posts;



CREATE TABLE posts (

    id INTEGER PRIMARY KEY AUTOINCREMENT,

    created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    title TEXT NOT NULL,

    content TEXT NOT NULL

);

```



Save and close the file.



In this schema file, you first delete the `posts` table if it already exists. This avoids the possibility of another table named `posts` existing, which might result in confusing behavior (for example, if it has different columns). This isn't the case here, because you haven't created the table yet, so the SQL command won't be executed. Note that this will delete all of the existing data whenever you execute this schema file. For our purposes, you will only execute this schema once, but you might want to execute it again to delete whatever data you inserted and start with an empty database again.



Next, you use `CREATE TABLE posts` to create the `posts` table with the following columns:



* `id`: An integer that represents a _primary key_. This key will get assigned a unique value by the database for each entry (that is, each blog post). `AUTOINCREMENT` automatically increments the post IDs, so that the first post will have an ID of `1`, and the post added after it will have an ID of `2`, and so on. Each post will always have the same ID, even if other posts are deleted.

* `created`: The time the blog post was created. `NOT NULL` signifies that this column should not be empty, and the `DEFAULT` value is the `CURRENT_TIMESTAMP` value, which is the time at which the post was added to the database. Just like `id`, you don’t need to specify a value for this column, as it will be automatically filled in.

* `title`: The post title. `NOT NULL` signifies that this column can't be empty.

* `content`: The post content. `NOT NULL` signifies that this column can't be empty.



Now, you'll use the `schema.sql` file to create the database. To do so, you'll create a Python file that will generate an SQLite `.db` database file based on this `schema.sql` file. Open a file named `init_db.py` inside your `flask_app` directory:



```command

nano init_db.py

```



Add the following code to it:



```python

[label flask_app/init_db.py]

import sqlite3



connection = sqlite3.connect('database.db')





with open('schema.sql') as f:

    connection.executescript(f.read())



cur = connection.cursor()



cur.execute("INSERT INTO posts (title, content) VALUES (?, ?)",

            ('First Post', 'Content for the first post')

            )



cur.execute("INSERT INTO posts (title, content) VALUES (?, ?)",

            ('Second Post', 'Content for the second post')

            )



connection.commit()

connection.close()

```



You first import the `sqlite3` module. You open a connection to a database file named `database.db`, which will be created once you run the Python file. Then you use the `open()` function to open the `schema.sql` file. Next you execute its contents using the [`executescript()`](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.executescript) method that executes multiple SQL statements at once, which will create the `posts` table. You create a [Cursor object](https://docs.python.org/3/library/sqlite3.html#cursor-objects) that allows you to process rows in a database. In this case, you'll use the cursor's [`execute()`](https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.execute) method to execute two `INSERT` SQL statements to add two blog posts to your `posts` table. Finally, you commit the changes and close the connection.



Save and close the file and then run it in the terminal using the `python` command:



```command

python init_db.py

```



Once the file finishes execution, a new file called `database.db` will appear in your `flask_app` directory. This means you've successfully set up your database.



Next, you'll create a small Flask application, retrieve the two posts you inserted into the database, and display them on the index page.



## Step 2 — Displaying Posts

In this step, you will create a Flask application with an index page where the blog posts you have in your database are displayed.



With your programming environment activated and Flask installed, open a file called `app.py` for editing inside your `flask_app` directory:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



This file will set up your database connection and create a single Flask route to use that connection. Add the following code to the file:



```python

[label flask_app/app.py]

import sqlite3

from flask import Flask, render_template



app = Flask(__name__)



def get_db_connection():

    conn = sqlite3.connect('database.db')

    conn.row_factory = sqlite3.Row

    return conn





@app.route('/')

def index():

    conn = get_db_connection()

    posts = conn.execute('SELECT * FROM posts').fetchall()

    conn.close()

    return render_template('index.html', posts=posts)

```



Save and close the file.



In the code above, you first import the `sqlite3` module to use it to connect to your database. Then you import the `Flask` class and the `render_template()` function from the `flask` package. You make a Flask application instance called `app`. You define a function called `get_db_connection()`, which opens a connection to the `database.db` database file you created earlier, and sets the [`row_factory`](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.row_factory) attribute to `sqlite3.Row` so you can have name-based access to columns. This means that the database connection will return rows that behave like regular Python dictionaries. Lastly, the function returns the `conn` connection object you’ll be using to access the database.



You then use the `app.route()` decorator to create a [Flask view function](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3#step-2-%E2%80%94-creating-a-simple-application) called `index()`. You use the `get_db_connection()` function to open a database connection. Then you execute an SQL query to select all entries from the posts table. You use the [`fetchall()`](https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.fetchall) method to fetch all the rows of the query result, this will return a list of the posts you inserted into the database in the previous step.



You close the database connection using the `close()` method and return the result of rendering the `index.html` template. You also pass the `posts` object as an argument, which contains the results you got from the database. This will allow you to access the blog posts in the `index.html` template.



To display the posts you have in your database on the index page, you will first create a base template, which will have all the basic HTML code other templates will also use to avoid code repetition. Then you'll create the `index.html` template file you rendered in your `index()` function. To learn more about templates, see [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).



Create a templates directory, then open a new template called `base.html`:



```custom_prefix((env)sammy@localhost:$)

mkdir templates

nano templates/base.html

```



Add the following code inside the `base.html` file:



```html

[label flask_app/templates/base.html]

<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>{% block title %} {% endblock %}- FlaskApp</title>

    <style>

        .post {

            padding: 10px;

            margin: 5px;

            background-color: #f3f3f3

        }



        nav a {

            color: #d64161;

            font-size: 3em;

            margin-left: 50px;

            text-decoration: none;

        }

    </style>

</head>

<body>

    <nav>

        <a href="{{ url_for('index') }}">FlaskApp</a>

        <a href="#">About</a>

    </nav>

    <hr>

    <div class="content">

        {% block content %} {% endblock %}

    </div>

</body>

</html>

```



Save and close the file.



This base template has all the HTML boilerplate you’ll need to reuse in your other templates. The `title` block will be replaced to set a title for each page, and the `content` block will be replaced with the content of each page. The navigation bar has two links, one for the index page where you use the `url_for()` helper function to link to the `index()` view function, and the other for an About page if you choose to include one in your application.



Next, open a template called `index.html`. This is the template you referenced in the `app.py` file:



```custom_prefix((env)sammy@localhost:$)

nano templates/index.html

```



Add the following code to it:



```html

[label flask_app/templates/index.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Posts {% endblock %}</h1>

    {% for post in posts %}

        <div class='post'>

            <p>{{ post['created'] }}</p>

            <h2>{{ post['title'] }}</h2>

            <p>{{ post['content'] }}</p>

        </div>

    {% endfor %}

{% endblock %}

```



Save and close the file.



In the code above, you extend the `base.html` template and replace the contents of the `content` block. You use an `<h1>` heading that also serves as a title.



You use a [Jinja `for` loop](https://jinja.palletsprojects.com/en/3.0.x/templates/#for) in the line `{% for post in posts %}` to go through each post in the `posts` list. You access the creation date via `{{ post['created'] }}`, the title via `{{ post['title'] }}`, and the post content via `{{ post['content'] }}`.



While in your `flask_app` directory with your virtual environment activated, tell Flask about the application (`app.py` in this case) using the `FLASK_APP` environment variable:



```custom_prefix((env)sammy@localhost:$)

export FLASK_APP=app

```



Then set the `FLASK_ENV` environment variable to `development` to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see [How To Handle Errors in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-handle-errors-in-a-flask-application). Use the following commands to do this (on Windows, use  `set` instead of `export`):



```custom_prefix((env)sammy@localhost:$)

export FLASK_ENV=development

```



Next, run the application:



```custom_prefix((env)sammy@localhost:$)

flask run

```



With the development server running, visit the following URL using your browser:



```

http://127.0.0.1:5000/

```



You'll see the posts you added to the database on the first initiation.



![Index Page](https://assets.digitalocean.com/68071/aPJIqxK.png)



You've displayed the posts in your database on the index page. You now need to allow users to add new posts. You'll add a new route for adding posts in the next step.



## Step 3 — Creating Posts

In this step, you will add a new route to your Flask application that allows users to add new blog posts to the database, which will then appear on the index page.



You'll add a page with a web form where users enter the post title and post content. This form will be validated to make sure users don't submit an empty form. To inform users the form is invalid, you'll use a [_flash message_](https://flask.palletsprojects.com/en/2.0.x/patterns/flashing/) which will only be shown once and will disappear on the next request (if you navigate to another page for example).



Leave the development server running and open a new terminal window.



First, open your `app.py` file:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



For handling the web form, you'll need to import a few things from the `flask` package:



* The global [`request`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.request) object to access submitted data.

* The [`url_for()`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.url_for) function to generate URLs.

* The [`flash()`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.flash) function to flash a message if a request is invalid.

* The [`redirect()`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.redirect) function to redirect users to the index page after adding the posts to the database.



Add these imports to the first line in the file:



```python

[label flask_app/app.py]

from flask import Flask, render_template, request, url_for, flash, redirect



# ...

```



The `flash()` function stores flashed messages in the client’s browser session, which requires setting a _secret key_ to secure sessions that remember information from one request to another. You must never allow anyone to access your secret key. See [the Flask documentation for sessions](https://flask.palletsprojects.com/en/2.0.x/api/#sessions) for more information.



Set a _secret key_ by adding a `SECRET_KEY` configuration to your application via the `app.config` object. Add it next to the `app` instance definition.



```python

[label flask_app/app.py]



# ...

app = Flask(__name__)

app.config['SECRET_KEY'] = 'your secret key'

```



Remember that the secret key should be a long random string. For more on web forms and the secret key configuration, see [How To Use Web Forms in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-web-forms-in-a-flask-application#step-3-%E2%80%94-handling-form-requests).



Next, add the following route at the end of the `app.py` file:



```python

[label flask_app/app.py]

# ...



@app.route('/create/', methods=('GET', 'POST'))

def create():

    return render_template('create.html')

```



Save and close the file.



In this route, you pass the tuple `('GET', 'POST')` to the `methods` parameter to allow both GET and POST requests. GET requests are used to retrieve data from the server. POST requests are used to post data to a specific route. By default, only GET requests are allowed. When the user first requests the `/create` route using a GET request, a template file called `create.html` will be rendered. You will later edit this route to handle POST requests for when users fill and submit the web form for creating new posts.



Open the new `create.html` template:



```custom_prefix((env)sammy@localhost:$)

nano templates/create.html

```



Add the following code to it:



```html

[label flask_app/templates/create.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Add a New Post {% endblock %}</h1>

    <form method="post">

        <label for="title">Title</label>

        <br>

        <input type="text" name="title"

               placeholder="Post title"

               value="{{ request.form['title'] }}"></input>

        <br>



        <label for="content">Post Content</label>

        <br>

        <textarea name="content"

                  placeholder="Post content"

                  rows="15"

                  cols="60"

                  >{{ request.form['content'] }}</textarea>

        <br>

        <button type="submit">Submit</button>

    </form>

{% endblock %}

```

Save and close the file.



You extend the base template, set a heading as a title, and use a `<form>` tag with the attribute `method` set to `post` to indicate that the form will submit a POST request. You have a text field with the name `title`, which you'll use to access the title data in your `/create` route. You set the value of the text field to `request.form['title']` which is either empty or a saved version of the title if the form is invalid, so that the title does not get lost when things go wrong.



After the title input field, you add a text area named `content` with the value `{{ request.form['content'] }}` to restore post content if the form is invalid.



Last, you have a Submit button at the end of the form.



Now, with the development server running, use your browser to navigate to the `/create` route:



```

http://127.0.0.1:5000/create

```



You will see an **Add a New Post** page with an input field for a post title, a text area for the post's content, and a **Submit** button.



![Add New Post](https://assets.digitalocean.com/68071/UPBjbVS.png)



If you fill in the form and submit it, sending a POST request to the server, nothing happens because you did not handle POST requests on the `/create` route.



Open `app.py` to handle the POST request the user submits:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Edit the `/create` route to look as follows:



```python

[label flask_app/app.py]

# ...



@app.route('/create/', methods=('GET', 'POST'))

def create():

    if request.method == 'POST':

        title = request.form['title']

        content = request.form['content']



        if not title:

            flash('Title is required!')

        elif not content:

            flash('Content is required!')

        else:

            conn = get_db_connection()

            conn.execute('INSERT INTO posts (title, content) VALUES (?, ?)',

                         (title, content))

            conn.commit()

            conn.close()

            return redirect(url_for('index'))



    return render_template('create.html')

```

Save and close the file.



You handle POST requests inside the `if request.method == 'POST'` condition. You extract the title and content the user submits from the `request.form` object. If the title is empty, you use the `flash()` function to flash the message `Title is required!`. You do the same in case of empty content.



If both the title and the content are supplied, you open a database connection using the `get_db_connection()` function. You use the `execute()` method to execute an `INSERT INTO` SQL statement to add a new post to the `posts` table with the title and content the user submits as values. You use the `?` placeholder to insert data into the table safely. You commit the transaction and close the connection. Lastly, you redirect the user to the index page where they can see their new post below existing posts.



<$>[warning]

**Warning:** Never use Python string operations to dynamically create an SQL statement string. Always use the `?` placeholder in your SQL statements to dynamically substitute values. Pass a tuple of values as the second argument to the `execute()` method to bind your values to the SQL statement. This prevents [SQL injection attacks](https://en.wikipedia.org/wiki/SQL_injection).

<$>



With the development server running, use your browser to navigate to the `/create` route:



```

http://127.0.0.1:5000/create

```



Fill the form and submit it.



You'll be redirected to the index page where you'll see your new post.



If you submit a form without a title or one without any content, your post won't be added to the database, you won't be redirected to the index page, and you won't receive any feedback for why that is. This is because you haven't set up flashed messages to be displayed anywhere yet.



Open `base.html` to add a link to the Create page in the navigation bar, and to display flashed messages below it.



```custom_prefix((env)sammy@localhost:$)

nano templates/base.html

```

Edit the file to look as follows:



```html

[label flask_app/templates/base.html]

<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>{% block title %} {% endblock %} - FlaskApp</title>

    <style>

        .post {

            padding: 10px;

            margin: 5px;

            background-color: #f3f3f3

        }



        nav a {

            color: #d64161;

            font-size: 3em;

            margin-left: 50px;

            text-decoration: none;

        }



        .alert {

            padding: 20px;

            margin: 5px;

            color: #970020;

            background-color: #ffd5de;

        }

    </style>

</head>

<body>

    <nav>

        <a href="{{ url_for('index') }}">FlaskApp</a>

        <a href="{{ url_for('create') }}">Create</a>

        <a href="#">About</a>

    </nav>

    <hr>

    <div class="content">

        {% for message in get_flashed_messages() %}

            <div class="alert">{{ message }}</div>

        {% endfor %}



        {% block content %} {% endblock %}

    </div>

</body>

</html>

```



Save and close the file.



Here, you add a new `<a>` link to the navigation bar that points to the Create page.



You use a Jinja `for` loop to go through the flashed messages. These are available in the `get_flashed_messages()` special function. Each message is displayed in a `<div>` tag with a CSS class called `alert`. You style this `<div>` tag inside the `<style>` tag in the `<head>` section.



Refresh your index page and you'll see the new link in the navigation bar.



Click the **Create** link, and submit an empty form. You'll receive the flashed message "Title is required!"



Fill in the title field and leave the content text area empty. Submit the form again, and you'll receive a "Content is required!" message. Notice how the "Title is required!" message is gone. This is because it's a _flashed message_ and not a permanent one.



You now have a way of adding new posts. Next, you'll add a new route for allowing users to edit existing posts.



## Step 4 — Editing Posts

In this step, you will add a new route to the application to allow users to edit existing posts.



First, to avoid code repetition and to isolate code and make it easier to maintain, you'll add a new function that takes an ID and retrieves a post associated with it from the database. You'll use this function to get the post data you want to edit, and you'll use it to get the post for when you want to delete it in the next step.



Open `app.py`:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



The function you'll use to retrieve a post will respond with a `404 Not Found` error if the ID of the requested post does not correspond with any of the existing posts. To do this, you'll use the [`abort()`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.abort) function, which aborts a request and responds with an error message. For more, see [How To Handle Errors in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-handle-errors-in-a-flask-application).



Add the `abort()` function to the imports:



```python

[label flask_app/app.py]

from flask import Flask, render_template, request, url_for, flash, redirect, abort

```



Add a new function called `get_post()` below your `get_db_connection()` function:



```python

[label flask_app/app.py]



# ...



def get_db_connection():

    conn = sqlite3.connect('database.db')

    conn.row_factory = sqlite3.Row

    return conn



def get_post(post_id):

    conn = get_db_connection()

    post = conn.execute('SELECT * FROM posts WHERE id = ?',

                        (post_id,)).fetchone()

    conn.close()

    if post is None:

        abort(404)

    return post



# ...

```



This new function has a `post_id` argument that determines what post to retrieve and return. You open a database connection with `get_db_connection()` and execute an SQL query to get the post associated with the given `post_id` value. You get the post with the `fetchone()` method, store it in the `post` variable, and close the connection.



If the `post` variable has the value `None`, meaning no result was found in the database, you use the `abort()` function you imported earlier to respond with a `404` error code and the function will finish execution. If, however, a post was found, you return the value of the `post` variable.



Next, add a new route for editing posts at the end of the file:



```python

[label flask_app/app.py]

# ...



@app.route('/<int:id>/edit/', methods=('GET', 'POST'))

def edit(id):

    post = get_post(id)



    if request.method == 'POST':

        title = request.form['title']

        content = request.form['content']



        if not title:

            flash('Title is required!')



        elif not content:

            flash('Content is required!')



        else:

            conn = get_db_connection()

            conn.execute('UPDATE posts SET title = ?, content = ?'

                         ' WHERE id = ?',

                         (title, content, id))

            conn.commit()

            conn.close()

            return redirect(url_for('index'))



    return render_template('edit.html', post=post)

```



Save and close the file.



You use the route `/<int:id>/edit/`, with `int:` being a [converter](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3#step-5-%E2%80%94-dynamic-routes) that accepts positive integers. And `id` is the URL variable that will determine the post you want to edit. For example, `/2/edit/` will allow you to edit the post with the ID of `2`. The ID is passed from the URL to the `edit()` view function. You pass the value of the `id` argument to the `get_post()` function to fetch the post associated with the provided ID from the database. Remember that this will respond with a `404 Not Found` error if no post with the given ID exists.



The last line renders a template file called `edit.html`, and passes in the `post` variable that has the post data. You’ll use this to display the existing title and content on the Edit page.



The `if request.method == 'POST'` block handles the new data the user submits. Similar to adding a new post, you extract the title and content. You flash a message if the title or the content is not provided.



If the form is valid, you open a database connection and use the `UPDATE` SQL statement to update the `posts` table by setting the new title and new content, where the ID of the post in the database is equal to the ID that was in the URL. You commit the transaction, close the connection, and redirect to the index page.



Next you need to create a page where users can do the editing. Open a new `edit.html` template:



```custom_prefix((env)sammy@localhost:$)

nano templates/edit.html

```



Add the following code to it:



```html

[label flask_app/templates/edit.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Edit "{{ post['title'] }}" {% endblock %}</h1>

    <form method="post">

        <label for="title">Title</label>

        <br>

        <input type="text" name="title"

               placeholder="Post title"

               value="{{ request.form['title'] or post['title'] }}"></input>

        <br>



        <label for="content">Post Content</label>

        <br>

        <textarea name="content"

                  placeholder="Post content"

                  rows="15"

                  cols="60"

                  >{{ request.form['content'] or post['content'] }}</textarea>

        <br>

        <button type="submit">Submit</button>

    </form>

{% endblock %}

```

Save and close the file.



This is similar to the code in the `create.html` template, except for displaying the post title inside the page's title in the line `{% block title %} Edit "{{ post['title'] }}" {% endblock %}`, the value of the input in `{{ request.form['title'] or post['title'] }}`, and the value of the text area in `{{ request.form['content'] or post['content'] }}`. This displays the data stored in the request if it exists; otherwise it displays the data from the `post` variable that was passed to the template containing current database data.



With the development server running, use your browser to navigate to the following URL to edit the first post:



```

http://127.0.0.1:5000/1/edit

```



You'll see a page that looks as follows:



![Edit Post](https://assets.digitalocean.com/68071/03JjJZL.png)



Edit the post and submit the form. You'll see your changes applied on the index page. If you submit a form without a title or without any content, you'll receive a flashed message.



You now need to add a link that points to the Edit page for each post on the index page. Open the `index.html` template file:



```custom_prefix((env)sammy@localhost:$)

nano templates/index.html

```



Edit the file to look exactly like the following:



```html

[label flask_app/templates/index.html]



{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Posts {% endblock %}</h1>

    {% for post in posts %}

        <div class='post'>

            <p>{{ post['created'] }}</p>

            <h2>{{ post['title'] }}</h2>

            <p>{{ post['content'] }}</p>

            <a href="{{ url_for('edit', id=post['id']) }}">Edit</a>

        </div>

    {% endfor %}

{% endblock %}

````

Save and close the file.



You added an `<a>` tag that links to the `edit()` view function. You pass the post ID you have in `post['id'])` to the `url_for()` function to generate the post's edit link. This adds a link to the Edit page of each post below it.



Refresh the index page and click the **Edit** link to edit a post.



You can now add new posts and edit existing ones. Next, you'll add a button to allow users to delete existing posts.



## Step 5 — Deleting Posts

In this step, you will add a Delete button to the Edit page to allow users to delete a post.



First, you’ll add a new `/id/delete` route that accepts POST requests, similar to the `edit()` view function. Your new `delete()` view function will receive the ID of the post to be deleted from the URL, retrieve it using the `get_post()` function, and then delete it from the database if it exists.



Open the `app.py` file:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Add the following route at the end:



```python

[label flask_app/app.py]

# ...



@app.route('/<int:id>/delete/', methods=('POST',))

def delete(id):

    post = get_post(id)

    conn = get_db_connection()

    conn.execute('DELETE FROM posts WHERE id = ?', (id,))

    conn.commit()

    conn.close()

    flash('"{}" was successfully deleted!'.format(post['title']))

    return redirect(url_for('index'))

```



Save and close the file.



This view function only accepts POST requests in the `methods` parameter. This means that navigating to the `/ID/delete` route on your browser will return a `405 Method Not Allowed` error, because web browsers default to GET requests. To delete a post, the user clicks on a button that sends a POST request to this route.



The function receives the ID of the post to be deleted. You use this ID to retrieve the post using the `get_post()` function. This responds with a `404 Not Found` error if no post with the given ID exists. You open a database connection and execute a `DELETE FROM` SQL command to delete the post. You use `WHERE id = ?` to specify the post you want to delete.



You commit the change to the database and close the connection. You flash a message to inform the user that the post was successfully deleted and redirect them to the index page.



Note that you don’t render a template file. This is because you’ll just add a Delete button to the Edit page.



Open the `edit.html` template file:



```custom_prefix((env)sammy@localhost:$)

nano templates/edit.html

```



Then add the following `<hr>` and `<form>` tags directly before the `{% endblock %}` line:



```html

[label flask_app/templates/edit.html]

        <button type="submit">Submit</button>

    </form>





    <hr>

    <form action="{{ url_for('delete', id=post['id']) }}" method="POST">

        <input type="submit" value="Delete Post"

                onclick="return confirm('Are you sure you want to delete this post?')">

    </form>

{% endblock %}

```

Save and close the file.



Here, you have a web form that submits a POST request to the `delete()` view function. You pass `post['id']` to specify the post that will be deleted. You use the [`confirm()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm) method available in web browsers to display a confirmation message before submitting the request.



Now navigate again to the Edit page of a post and try deleting it:



```

http://127.0.0.1:5000/1/edit

```



After you confirm the deletion, you'll be redirected to the index page, and the post will no longer be there. A flash message will appear below the navigation bar informing you that the post was successfully deleted.



You now have a way of deleting unwanted posts from the database in your Flask application.



## Conclusion

You built a small web blog that communicates with an SQLite database. You have basic functionalities in your Flask application, such as adding new data to the database, retrieving data and displaying it on a page, and editing and deleting existing data.



For more on how to use SQLite with Python and Flask, see the following tutorials:



* [How To Use the sqlite3 Module in Python 3](https://www.digitalocean.com/community/tutorials/how-to-use-the-sqlite3-module-in-python-3)

* [How To Use One-to-Many Database Relationships with Flask and SQLite](https://www.digitalocean.com/community/tutorials/how-to-use-one-to-many-database-relationships-with-flask-and-sqlite)

* [How To Modify Items in a One-to-Many Database Relationships with Flask and SQLite](https://www.digitalocean.com/community/tutorials/how-to-modify-items-in-a-one-to-many-database-relationships-with-flask-and-sqlite)

* [How To Use Many-to-Many Database Relationships with Flask and SQLite](https://www.digitalocean.com/community/tutorials/how-to-use-many-to-many-database-relationships-with-flask-and-sqlite)



If you would like to read more about Flask, check out [the other tutorials in the Flask series](https://www.digitalocean.com/community/tutorial_series/how-to-create-web-sites-with-flask).





## How To Use a PostgreSQL Database in a Flask Application

_The author selected the [Free and Open Source Fund](https://www.brightfunds.org/funds/foss-nonprofits) to receive a donation as part of the [Write for DOnations](https://do.co/w4do-cta) program._



### Introduction



In web applications, you usually need a database, which is an organized collection of data. You use a database to store and maintain persistent data that can be retrieved and manipulated efficiently. For example, in a social media application, you have a database where user data (personal information, posts, comments, followers) is stored in a way that can be efficiently manipulated. You can add data to a database, retrieve it, modify it, or delete it, depending on different requirements and conditions. In a web application, these requirements might be a user adding a new post, deleting a post, or deleting their account, which might or might not delete their posts. The actions you perform to manipulate data will depend on specific features in your application. For example, you might not want users to add posts with no titles.



Flask is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. [PostgreSQL](https://www.postgresql.org/), or Postgres, is a relational database management system that provides an implementation of the [SQL](https://en.wikipedia.org/wiki/SQL) querying language. It’s standards-compliant and has many advanced features such as reliable transactions and concurrency without read locks.



In this tutorial, you’ll build a small book review web application that demonstrates how to use the [`psycopg2`](https://www.psycopg.org/docs/) library, a PostgreSQL database adapter that allows you to interact with your PostgreSQL database in Python. You'll use it with Flask to perform basic tasks, such as connecting to a database server, creating tables, inserting data to a table, and retrieving data from a table.



## Prerequisites



* A local Python 3 programming environment. Follow the tutorial for your distribution in [How To Install and Set Up a Local Programming Environment for Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-python-3) series. In this tutorial the project directory is called `flask_app`.



* An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out [How to Create Your First Web Application Using Flask and Python](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3) and [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).



* An understanding of basic HTML concepts. You can review our [How To Build a Website with HTML](https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html) tutorial series for background knowledge.



* PostgreSQL installed on your local machine, and access to the PostgreSQL prompt. Follow [How To Install and Use PostgreSQL on Ubuntu 20.04](https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-ubuntu-20-04) to set up your PostgreSQL database.



## Step 1 — Creating the PostgreSQL Database and User



In this step, you'll create a database called `flask_db` and a database user called `sammy` for your Flask application.



During the Postgres installation, an operating system user named `postgres` was created to correspond to the `postgres` PostgreSQL administrative user. You need to use this user to perform administrative tasks. You can use `sudo` and pass in the username with the `-iu` option.



Log in to an interactive Postgres session using the following command:



```custom_prefix(sammy@localhost:$)

sudo -iu postgres psql

```



You will be given a PostgreSQL prompt where you can set up your requirements.



First, create a database for your project:



```custom_prefix(postgres=#)

CREATE DATABASE flask_db;

```



<$>[note]

**Note:** Every Postgres statement must end with a semi-colon, so make sure that your command ends with one if you are experiencing issues.

<$>



Next, create a database user for our project. Make sure to select a secure password:



```custom_prefix(postgres=#)

CREATE USER sammy WITH PASSWORD 'password';

```



Then give this new user access to administer your new database:



```custom_prefix(postgres=#)

GRANT ALL PRIVILEGES ON DATABASE flask_db TO sammy;

```



To confirm the database was created, get the list of databases by typing the following command:



```custom_prefix(postgres=#)

\l

```



You'll see `flask_db` in the list of databases.



When you are finished, exit out of the PostgreSQL prompt by typing:



```custom_prefix(postgres=#)

\q

```



Postgres is now set up so that you can connect to and manage its database information via Python using the `psycopg2` library. Next, you'll install this library alongside the Flask package.



## Step 2 — Installing Flask and psycopg2



In this step, you will install Flask and the `psycopg2` library so that you can interact with your database using Python.



With your virtual environment activated, use `pip` to install Flask and the `psycopg2` library:



```custom_prefix((env)sammy@localhost:$)

pip install Flask psycopg2-binary

```



Once the installation is successfully finished, you'll see a line similar to the following at the end of the output:



```

[secondary_label Output]



Successfully installed Flask-2.0.2 Jinja2-3.0.3 MarkupSafe-2.0.1 Werkzeug-2.0.2 click-8.0.3 itsdangerous-2.0.1 psycopg2-binary-2.9.2

```



You now have the required packages installed on your virtual environment. Next, you'll connect to and set up your database.



## Step 3 — Setting up a Database



In this step, you'll create a Python file in your `flask_app` project directory to connect to the `flask_db` database, create a table for storing books, and insert some books with reviews into it.



First with your programming environment activated, open a new file called `init_db.py` in your `flask_app` directory.



```custom_prefix((env)sammy@localhost:$)

nano init_db.py

```



This file will open a connection to the `flask_db` database, create a table called `books`, and populate the table using sample data. Add the following code to it:



```python

[label flask_app/init_db.py]

import os

import psycopg2



conn = psycopg2.connect(

        host="localhost",

        database="flask_db",

        user=os.environ['DB_USERNAME'],

        password=os.environ['DB_PASSWORD'])



# Open a cursor to perform database operations

cur = conn.cursor()



# Execute a command: this creates a new table

cur.execute('DROP TABLE IF EXISTS books;')

cur.execute('CREATE TABLE books (id serial PRIMARY KEY,'

                                 'title varchar (150) NOT NULL,'

                                 'author varchar (50) NOT NULL,'

                                 'pages_num integer NOT NULL,'

                                 'review text,'

                                 'date_added date DEFAULT CURRENT_TIMESTAMP);'

                                 )



# Insert data into the table



cur.execute('INSERT INTO books (title, author, pages_num, review)'

            'VALUES (%s, %s, %s, %s)',

            ('A Tale of Two Cities',

             'Charles Dickens',

             489,

             'A great classic!')

            )





cur.execute('INSERT INTO books (title, author, pages_num, review)'

            'VALUES (%s, %s, %s, %s)',

            ('Anna Karenina',

             'Leo Tolstoy',

             864,

             'Another great classic!')

            )



conn.commit()



cur.close()

conn.close()

```



Save and close the file.



In this file, you first import the [`os`](https://docs.python.org/3/library/os.html) module you'll use to access environment variables where you'll store your database username and password so that they are not visible in your source code.



You import the `psycopg2` library. Then you open a connection to the `flask_db` database using the `psycopg2.connect()` function. You specify the host, which is the localhost in this case. You pass the database name to the `database` parameter.



You provide your username and password via the `os.environ` object, which gives you access to environment variables you set in your programming environment. You will store the database username in an environment variable called `DB_USERNAME` and the password in an environment variable called `DB_PASSWORD`. This allows you to store your username and password outside your source code, so that your sensitive information is not leaked when the source code is saved in source control or uploaded to a server on the internet. Even if an attacker gains access to your source code, they will not gain access to the database.



You create a cursor called `cur` using the [`connection.cursor()`](https://www.psycopg.org/docs/connection.html#connection.cursor) method, which allows Python code to execute PostgreSQL commands in a database session.



You use the cursor's `execute()` method to delete the `books` table if it already exists. This avoids the possibility of another table named `books` existing, which might result in confusing behavior (for example, if it has different columns). This isn't the case here, because you haven’t created the table yet, so the SQL command won’t be executed. Note that this will delete all of the existing data whenever you execute this `init_db.py` file. For our purposes, you will only execute this file once to initiate the database, but you might want to execute it again to delete whatever data you inserted and start with the initial sample data again.



Then you use `CREATE TABLE books` to create a table named `books` with the following columns:



* `id`: An ID of the `serial` type, which is an autoincrementing integer. This column represents a _primary key_ you specify using the `PRIMARY KEY` keywords. The database will assign a unique value to this key for each entry.

* `title`: The book's title of the `varchar` type, which is a character type of variable length with a limit. `varchar (150)` means that the title can be up to 150 characters long. `NOT NULL` signifies that this column can’t be empty.

* `author`: The book's author, with a limit of 50 characters. `NOT NULL` signifies that this column can’t be empty.

* `pages_num`: An integer representing the number of pages the book has. `NOT NULL` signifies that this column can’t be empty.

* `review`: The book review. The `text` type signifies that the review can be text of any length.

* `date_added`: The date the book was added to the table. `DEFAULT` sets the default value of the column to `CURRENT_TIMESTAMP`, which is the time at which the book was added to the database. Just like `id`, you don’t need to specify a value for this column, as it will be automatically filled in.



After creating the table, you use the cursor's `execute()` method to insert two books into the table, *A Tale of Two Cities* by Charles Dickens, and *Anna Karenina* by Leo Tolstoy. You use the `%s` placeholder to pass the values to the SQL statement. `psycopg2` handles the insertion in the background in a way that prevents [SQL Injection attacks](https://en.wikipedia.org/wiki/SQL_injection).



Once you finish inserting book data into your table, you use the [`connection.commit()`](https://www.psycopg.org/docs/connection.html#connection.commit) method to commit the transaction and apply the changes to the database. Then you clean things up by closing the cursor with `cur.close()`, and the connection with `conn.close()`.



For the database connection to be established, set the `DB_USERNAME` and `DB_PASSWORD` environment variables by running the following commands. Remember to use your own username and password:



```custom_prefix((env)sammy@localhost:$)

export DB_USERNAME="sammy"

export DB_PASSWORD="password"

```



Now, run your `init_db.py` file in the terminal using the `python` command:



```custom_prefix((env)sammy@localhost:$)

python init_db.py

```



Once the file finishes execution with no errors, a new `books` table will be added to your `flask_db` database.



Log in to an interactive Postgres session to check out the new `books` table.



```custom_prefix(sammy@localhost:$)

sudo -iu postgres psql

```



Connect to the `flask_db` database using the `\c` command:



```custom_prefix(postgres=#)

\c flask_db

```



Then use a `SELECT` statement to get the titles and authors of books from the `books` table:



```custom_prefix(postgres=#)

SELECT title, author FROM books;

```



You'll see an output like the following:



```

        title         |      author

----------------------+------------------

 A Tale of Two Cities | Charles Dickens

 Anna Karenina        | Leo Tolstoy

```



Quit the interactive session with `\q`.



Next, you'll create a small Flask application, connect to the database, retrieve the two book reviews you inserted into the database, and display them on the index page.



## Step 4 — Displaying Books



In this step, you'll create a Flask application with an index page that retrieves the books that are in the database, and display them.



With your programming environment activated and Flask installed, open a file called `app.py` for editing inside your `flask_app` directory:



```custom_prefix(sammy@localhost:$)

nano app.py

```



This file will set up your database connection and create a single Flask route to use that connection. Add the following code to the file:



```python

[label flask_app/app.py]

import os

import psycopg2

from flask import Flask, render_template



app = Flask(__name__)



def get_db_connection():

    conn = psycopg2.connect(host='localhost',

                            database='flask_db',

                            user=os.environ['DB_USERNAME'],

                            password=os.environ['DB_PASSWORD'])

    return conn





@app.route('/')

def index():

    conn = get_db_connection()

    cur = conn.cursor()

    cur.execute('SELECT * FROM books;')

    books = cur.fetchall()

    cur.close()

    conn.close()

    return render_template('index.html', books=books)

```



Save and close the file.



Here, you import the `os` module, the `psycopg2` library, and the `Flask` class and the `render_template()` from the `flask` package. You make a Flask application instance called `app`.



You define a function called `get_db_connection()`, which opens a connection to the `flask_db` database using the user and password you store in your `DB_USERNAME` and `DB_PASSWORD` environment variables. The function returns the `conn` connection object you’ll be using to access the database.



Then you create a main `/` route and an `index()` view function using the `app.route()` decorator. In the `index()` view function, you open a database connection using the `get_db_connection()` function, you create a cursor, and execute the `SELECT * FROM books;` SQL statement to get all the books that are in the database. You use the `fetchall()` method to save the data in a variable called `books`. Then you close the cursor and the connection. Lastly, you return a call to the `render_template()` function to render a template file called `index.html` passing it the list of books you fetched from the database in the `books` variable.



To display the books you have in your database on the index page, you will first create a base template, which will have all the basic HTML code other templates will also use to avoid code repetition. Then you’ll create the `index.html` template file you rendered in your `index()` function. To learn more about templates, see [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).



Create a `templates` directory, then open a new template called `base.html`:



```custom_prefix(sammy@localhost:$)

mkdir templates

nano templates/base.html

```



Add the following code inside the `base.html` file:



```html

[label flask_app/templates/base.html]

<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>{% block title %} {% endblock %}- FlaskApp</title>

    <style>

        nav a {

            color: #d64161;

            font-size: 3em;

            margin-left: 50px;

            text-decoration: none;

        }



        .book {

            padding: 20px;

            margin: 10px;

            background-color: #f7f4f4;

        }



        .review {

                margin-left: 50px;

                font-size: 20px;

        }



    </style>

</head>

<body>

    <nav>

        <a href="{{ url_for('index') }}">FlaskApp</a>

        <a href="#">About</a>

    </nav>

    <hr>

    <div class="content">

        {% block content %} {% endblock %}

    </div>

</body>

</html>

```



Save and close the file.



This base template has all the HTML boilerplate you’ll need to reuse in your other templates. The `title` block will be replaced to set a title for each page, and the `content` block will be replaced with the content of each page. The navigation bar has two links, one for the index page where you use the `url_for()` helper function to link to the `index()` view function, and the other for an **About** page if you choose to include one in your application.



Next, open a template called `index.html`. This is the template you referenced in the `app.py` file:



```custom_prefix(sammy@localhost:$)

nano templates/index.html

```



Add the following code to it:



```html

[label flask_app/templates/index.html]



{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Books {% endblock %}</h1>

    {% for book in books %}

        <div class='book'>

            <h3>#{{ book[0] }} - {{ book[1] }} BY {{ book[2] }}</h3>

            <i><p>({{ book[3] }} pages)</p></i>

            <p class='review'>{{ book[4] }}</p>

            <i><p>Added {{ book[5] }}</p></i>

        </div>

    {% endfor %}

{% endblock %}

```



Save and close the file.



In this file, you extend the base template, and replace the contents of the `content` block. You use an `<h1>` heading that also serves as a title.



You use a [Jinja `for` loop](https://jinja.palletsprojects.com/en/3.0.x/templates/#for) in the line `{% for book in books %}` to go through each book in the `books` list. You display the book ID, which is the first item using `book[0]`. You then display the book title, author, number of pages, review, and the date the book was added.



While in your `flask_app` directory with your virtual environment activated, tell Flask about the application (`app.py` in this case) using the `FLASK_APP` environment variable. Then set the `FLASK_ENV` environment variable to `development` to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see [How To Handle Errors in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-handle-errors-in-a-flask-application). Use the following commands to do this:



```custom_prefix((env)sammy@localhost:$)

export FLASK_APP=app

export FLASK_ENV=development

```



Make sure you set the `DB_USERNAME` and `DB_PASSWORD` environment variables if you haven't already:



```custom_prefix((env)sammy@localhost:$)

export DB_USERNAME="sammy"

export DB_PASSWORD="password"

```



Next, run the application:



```custom_prefix((env)sammy@localhost:$)

flask run

```



With the development server running, visit the following URL using your browser:



```

http://127.0.0.1:5000/

```



You'll see the books you added to the database on the first initiation.



![Index Page](https://assets.digitalocean.com/68125/V5uBvuu.png)



You've displayed the books in your database on the index page. You now need to allow users to add new books. You’ll add a new route for adding books in the next step.



## Step 5 — Adding New Books



In this step, you'll create a new route for adding new books and reviews to the database.



You’ll add a page with a web form where users enter the book title, book author, the number of pages, and the book review.



Leave the development server running and open a new terminal window.



First, open your `app.py` file:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



For handling the web form, you’ll need to import a few things from the `flask` package:



* The global [`request`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.request) object to access submitted data.

* The [`url_for()`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.url_for) function to generate URLs.

* The [`redirect()`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.redirect) function to redirect users to the index page after adding a book to the database.



Add these imports to the first line in the file:



```python

[label flask_app/app.py]



from flask import Flask, render_template, request, url_for, redirect



# ...

```



Then add the following route at the end of the `app.py` file:



```python

[label flask_app/app.py]



# ...





@app.route('/create/', methods=('GET', 'POST'))

def create():

    return render_template('create.html')

```



Save and close the file.



In this route, you pass the tuple `('GET', 'POST')` to the `methods` parameter to allow both GET and POST requests. GET requests are used to retrieve data from the server. POST requests are used to post data to a specific route. By default, only GET requests are allowed. When the user first requests the `/create` route using a GET request, a template file called `create.html` will be rendered. You will later edit this route to handle POST requests for when users fill and submit the web form for adding new books.



Open the new `create.html` template:



```custom_prefix((env)sammy@localhost:$)

nano templates/create.html

```



Add the following code to it:



```html

[label flask_app/templates/create.html]

{% extends 'base.html' %}



{% block content %}

    <h1>{% block title %} Add a New Book {% endblock %}</h1>

    <form method="post">

        <p>

            <label for="title">Title</label>

            <input type="text" name="title"

                   placeholder="Book title">

            </input>

        </p>



        <p>

            <label for="author">Author</label>

            <input type="text" name="author"

                   placeholder="Book author">

            </input>

        </p>



        <p>

            <label for="pages_num">Number of pages</label>

            <input type="number" name="pages_num"

                   placeholder="Number of pages">

            </input>

        </p>

        <p>

        <label for="review">Review</label>

        <br>

        <textarea name="review"

                  placeholder="Review"

                  rows="15"

                  cols="60"

                  ></textarea>

        </p>

        <p>

            <button type="submit">Submit</button>

        </p>

    </form>

{% endblock %}

```



Save and close the file.



You extend the base template, set a heading as a title, and use a `<form>` tag with the attribute `method` set to `post` to indicate that the form will submit a POST request.



You have a text field with the name `title`, which you’ll use to access the title data in your `/create` route.



You have a text field for the author, a number field for the number of pages, and a text area for the book review.



Last, you have a **Submit** button at the end of the form.



Now, with the development server running, use your browser to navigate to the `/create` route:



```

http://127.0.0.1:5000/create

```



You will see an **Add a New Book** page with an input field for a book title, one for its author, and one for the number of pages the book has, a text area for the book's review, and a **Submit** button.



![Add a New Book](https://assets.digitalocean.com/68125/CSqIQ7h.png)





If you fill in the form and submit it, sending a POST request to the server, nothing happens because you did not handle POST requests on the `/create` route.



Open `app.py` to handle the POST request the user submits:



```custom_prefix((env)sammy@localhost:$)

nano app.py

```



Edit the `/create` route to look as follows:



```python

[label flask_app/app.py]



# ...



@app.route('/create/', methods=('GET', 'POST'))

def create():

    if request.method == 'POST':

        title = request.form['title']

        author = request.form['author']

        pages_num = int(request.form['pages_num'])

        review = request.form['review']



        conn = get_db_connection()

        cur = conn.cursor()

        cur.execute('INSERT INTO books (title, author, pages_num, review)'

                    'VALUES (%s, %s, %s, %s)',

                    (title, author, pages_num, review))

        conn.commit()

        cur.close()

        conn.close()

        return redirect(url_for('index'))



    return render_template('create.html')

```



Save and close the file.



You handle POST requests inside the `if request.method == 'POST'` condition. You extract the title, author, number of pages, and the review the user submits from the `request.form` object.



You open a database using the `get_db_connection()` function, and create a cursor. Then you execute an `INSERT INTO` SQL statement to insert the title, author, number of pages, and review the user submitted into the `books` table.



You commit the transaction and close the cursor and connection.



Lastly, you redirect the user to the index page where they can see the newly added book below the existing books.



With the development server running, use your browser to navigate to the `/create` route:



```

http://127.0.0.1:5000/create

```



Fill in the form with some data and submit it.



You’ll be redirected to the index page where you’ll see your new book review.



Next, you'll add a link to the Create page in the navigation bar. Open `base.html`:



```custom_prefix((env)sammy@localhost:$)

nano templates/base.html

```



Edit the file to look as follows:



```html

[label flask_app/templates/base.html]



<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>{% block title %} {% endblock %} - FlaskApp</title>

    <style>

        nav a {

            color: #d64161;

            font-size: 3em;

            margin-left: 50px;

            text-decoration: none;

        }



        .book {

            padding: 20px;

            margin: 10px;

            background-color: #f7f4f4;

        }



        .review {

                margin-left: 50px;

                font-size: 20px;

        }



    </style>

</head>

<body>

    <nav>

        <a href="{{ url_for('index') }}">FlaskApp</a>

        <a href="{{ url_for('create') }}">Create</a>

        <a href="#">About</a>

    </nav>

    <hr>

    <div class="content">

        {% block content %} {% endblock %}

    </div>

</body>

</html>

```



Save and close the file.



Here, you add a new `<a>` link to the navigation bar that points to the Create page.



Refresh your index page and you’ll see the new link in the navigation bar.



You now have a page with a web form for adding new book reviews. For more on web forms, see [How To Use Web Forms in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-web-forms-in-a-flask-application). For a more advanced and more secure method of managing web forms, see [How To Use and Validate Web Forms with Flask-WTF](https://www.digitalocean.com/community/tutorials/how-to-use-and-validate-web-forms-with-flask-wtf).



## Conclusion



You built a small web application for book reviews that communicates with a PostgreSQL database. You have basic database functionality in your Flask application, such as adding new data to the database, retrieving data, and displaying it on a page.



If you would like to read more about Flask, check out the other tutorials in [the Flask series](https://www.digitalocean.com/community/tutorial_series/how-to-create-web-sites-with-flask).





## How To Use MongoDB in a Flask Application

*The author selected the [Free and Open Source Fund](https://www.brightfunds.org/funds/foss-nonprofits) to receive a donation as part of the [Write for DOnations](https://do.co/w4do-cta) program.*

### Introduction

In web applications, you usually need a database, which is an organized collection of data. You use a database to store and maintain persistent data that can be retrieved and manipulated efficiently. For example, in a social media application, you have a database where user data (personal information, posts, comments, followers) is stored in a way that can be efficiently manipulated. You can add data to a database, retrieve it, modify it, or delete it, depending on different requirements and conditions. In a web application, these requirements might be a user adding a new post, deleting a post, or deleting their account, which may or may not delete their posts. The actions you perform to manipulate data will depend on specific features in your application. For example, you might not want users to add posts with no titles.

Flask is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. [MongoDB](https://www.mongodb.com/) is a general-purpose, document-oriented, [NoSQL](https://www.digitalocean.com/community/tutorials/what-is-nosql) database program that uses [JSON](https://www.digitalocean.com/community/tutorials/an-introduction-to-json)-like documents to store data. Unlike tabular relations used in relational databases, JSON-like documents allow for flexible and dynamic schemas while maintaining simplicity. In general, NoSQL databases have the ability to scale horizontally, making them suitable for big data and real-time applications.

In this tutorial, you’ll build a small todo list web application that demonstrates how to use the [PyMongo](https://pymongo.readthedocs.io/en/stable/index.html) library, a MongoDB database driver that allows you to interact with your MongoDB database in Python. You'll use it with Flask to perform basic tasks, such as connecting to a database server, creating collections that store a group of documents in MongoDB, inserting data to a collection, and retrieving and deleting data from a collection.

## Prerequisites

* A local Python 3 programming environment, follow the tutorial for your distribution in [How To Install and Set Up a Local Programming Environment for Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-python-3) series. In this tutorial we’ll call our project directory `flask_app`.

* MongoDB installed on your local machine. Follow the [How To Install MongoDB on Ubuntu 20.04 guide](https://www.digitalocean.com/community/tutorials/how-to-install-mongodb-on-ubuntu-20-04) to set up your MongoDB database.

* An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out [How to Create Your First Web Application Using Flask and Python](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3) and [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).

* An understanding of basic HTML concepts. You can review our [How To Build a Website with HTML](https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html) tutorial series for background knowledge.

## Step 1 — Setting Up PyMongo and Flask
In this step, you will install Flask and the PyMongo library.

With your virtual environment activated, use `pip` to install Flask and PyMongo:

```custom_prefix((env)sammy@localhost:$)
pip install Flask pymongo
```

Once the installation is successfully finished, you'll see a line similar to the following at the end of the output:

```
[secondary_label Output]

Successfully installed Flask-2.0.2 Jinja2-3.0.3 MarkupSafe-2.0.1 Werkzeug-2.0.2 click-8.0.3 itsdangerous-2.0.1 pymongo-4.0.1
```

Now that you've installed the required Python packages, you’ll connect to your MongoDB Server and create a collection.

## Step 2 — Connecting to the MongoDB Server and Creating a Collection
In this step, you'll use the PyMongo library to create a client you'll use to interact with your MongoDB server, create a database, and then create a collection to store your todos.

With your programming environment activated, open a file called `app.py` for editing inside your `flask_app` directory:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

This file will import the necessary class and helpers from Flask and the PyMongo library. You'll interact with your MongoDB server to create a database and create a collection for todos. Add the following code to `app.py`:

```python
[label flask_app/app.py]
from flask import Flask
from pymongo import MongoClient

app = Flask(__name__)

client = MongoClient('localhost', 27017)

db = client.flask_db
todos = db.todos
```

Save and close the file.

Here you import the `Flask` class, which you use to create a Flask application instance called `app`.

You import the `MongoClient` which you use to create a client object for a MongoDB instance called `client`, which allows you to connect and interact with your MongoDB server. When you instantiate the `MongoClient()`, you pass it the host of your MongoDB server, which is `localhost` in our case, and the port, which is `27017` here.


<$>[note]
**Note:**

It is **strongly** recommended that you harden your MongoDB installation's security by following our guide on [How To Secure MongoDB on Ubuntu 20.04](https://www.digitalocean.com/community/tutorials/how-to-secure-mongodb-on-ubuntu-20-04). Once it’s secured, you could then [configure MongoDB to accept remote connections](https://www.digitalocean.com/community/tutorials/how-to-configure-remote-access-for-mongodb-on-ubuntu-20-04).

Once you enable authentication in MongoDB, you'll need to pass additional `username` and `password` parameters when creating an instance of `MongoClient()` like so:

```python
client = MongoClient('localhost', 27017, username='username', password='password')
```
<$>

You then use the `client` instance to create a MongoDB database called `flask_db` and save a reference to it in a variable called `db`.

Then you create a collection called `todos` on the `flask_db` database using the `db` variable. Collections store a group of documents in MongoDB, like tables in relational databases.

In MongoDB, databases and collections are created lazily. This means that even if you execute the `app.py` file, none of the code related to the database will actually be executed until the first document is created. You will create a small Flask application with a page that allows users to insert todo documents into your `todos` collection in the next step. Once the first todo document is added, the `flask_db` database and the `todos` collection will be created on your MongoDB server.

To get a list of your current databases, open a new terminal, and start the `mongo` shell using the following command:

```custom_prefix((env)sammy@localhost:$)
mongo
```

A prompt will be opened, you can check your databases using the following command:

```custom_prefix(>)
show dbs
```

The output, if this is a new installation of MongoDB, will list the `admin`, `config`, and `local` databases.

You'll notice that the `flask_db` doesn't exist yet. Leave the `mongo` shell running in a terminal window and continue to the next step.

## Step 3 — Creating a Web Page for Adding and Displaying Todos
In this step, you'll create a web page with a web form that allows users to add todos, and display them on the same page.

With your programming environment activated, open your `app.py` file for editing:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

First, add the following imports from `flask`:

```python
[label flask_app/app.py]
from flask import Flask, render_template, request, url_for, redirect
from pymongo import MongoClient

# ...
```

Here, you import the `render_template()` helper function you'll use to render an HTML template, the `request` object to access data the user will submit, the `url_for()` function to generate URLs, and the `redirect()` function to redirect the user back to the index page after adding a todo.

Then add the following route at the end of the file:

```python
[label flask_app/app.py]
# ...


@app.route('/', methods=('GET', 'POST'))
def index():
    return render_template('index.html')
```
Save and close the file.

In this route, you pass the tuple `('GET', 'POST')` to the `methods` parameter to allow both GET and POST requests. GET requests are used to retrieve data from the server. POST requests are used to post data to a specific route. By default, only GET requests are allowed. When the user first requests the `/` route using a GET request, a template file called `index.html` will be rendered. You will later edit this route to handle POST requests for when users fill and submit the web form for creating new todos.

Next create a templates folder in your `flask_app` directory, and the `index.html` template you referenced in the preceding route:
```custom_prefix((env)sammy@localhost:$)
mkdir templates
nano templates/index.html
```

Add the following code inside the `index.html` file:

```html
[label flask_app/templates/index.html]
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FlaskApp</title>
    <style>
        .todo {
            padding: 20px;
            margin: 10px;
            background-color: #eee;
        }
    </style>
</head>
<body>
    <h1>FlaskTODO</h1>
    <hr>
    <div class="content">
    <form method="post">
        <p>
            <b><label for="content">Todo content</label></b>
        </p>
        <p>
            <input type="text" name="content"
                placeholder="Todo Content"></input>
        </p>

        <p>
            <b><label for="degree">Degree</label></b>
        </p>
        <p>
            <input id="degree-0" name="degree" required type="radio" value="Important">
            <label for="degree-0">Important</label>
        </p>
        <p>
            <input id="degree-1" name="degree" required type="radio" value="Unimportant">
            <label for="degree-1">Unimportant</label>
        </p>
        <button type="submit">Submit</button>
    </form>
    </div>
</body>
</html>
```
Save and close the file.

Here you have a basic HTML page with a title, some styles, a heading, and a web form. In the web form, you set the `method` attribute to `post` to indicate that the form will submit a POST request. You have a text input field for the todo content with the name `content`, which you’ll use to access the title data in your `/` route. You also have two HTML radio buttons with the name `degree`, which allows the user to specify the degree of importance for each todo item: they can select either the **Important** option or the **Unimportant** option when creating a todo. Last, you have a **Submit** button at the end of the form.

While in your `flask_app` directory with your virtual environment activated, tell Flask about the application (`app.py` in this case) using the `FLASK_APP` environment variable. Then set the `FLASK_ENV` environment variable to `development` to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see [How To Handle Errors in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-handle-errors-in-a-flask-application). Use the following commands to do this:

```custom_prefix((env)sammy@localhost:$)
export FLASK_APP=app
export FLASK_ENV=development
```

Next, run the application:

```custom_prefix((env)sammy@localhost:$)
flask run
```

<$>[note]
**Note:**
You might receive a `ModuleNotFoundError: No module named 'pymongo'` error when attempting to run the application. To fix this, deactivate your virtual environment and reactivate it. Then run the `flask run` command again.
<$>

With the development server running, visit the following URL using your browser:

```
http://127.0.0.1:5000/
```

You will see the index page with an input field for todo content, two radio buttons for the degree of importance, and a **Submit** button.

![The Index Page](https://assets.digitalocean.com/68140/hWvln4m.png)

For more on web forms, see [How To Use Web Forms in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-web-forms-in-a-flask-application). For a more advanced and more secure method of managing web forms, see [How To Use and Validate Web Forms with Flask-WTF](https://www.digitalocean.com/community/tutorials/how-to-use-and-validate-web-forms-with-flask-wtf).

If you fill in the form and submit it, sending a POST request to the server, nothing happens because you did not handle POST requests on the `/` route.

Leave the server running and open a new terminal window.

Open `app.py` to handle the POST request the user submits, add them to the todos collection, and display them on the index page:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Edit the `/` route to look as follows:

```python
[label flask_app/app.py]

@app.route('/', methods=('GET', 'POST'))
def index():
    if request.method=='POST':
        content = request.form['content']
        degree = request.form['degree']
        todos.insert_one({'content': content, 'degree': degree})
        return redirect(url_for('index'))

    all_todos = todos.find()
    return render_template('index.html', todos=all_todos)
```
Save and close the file.

In these changes, you handle POST requests inside the `if request.method == 'POST'` condition. You extract the todo content and degree of importance the user submits from the `request.form` object.

You use the [`insert_one()`](https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.insert_one) method on the todos collection to add a todo document into it. You provide todo data in a Python dictionary, setting the `'content'` to the value the user submitted in the text field for the todo content, and setting the `'degree'` key to the value of the radio button the user selects. You then redirect to the index page, which will refresh the page and display the newly added todo item.

To display all the saved todos, you use the [`find()`](https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.find) method outside the code responsible for handling POST requests, which returns all the todo documents available in the `todos` collection. You save the todos you get from the database in a variable called `all_todos`, and then you edit the `render_template()` function call to pass the list of todo documents to the `index.html` template, which will be available in the template in a variable called `todos`.

If you refresh the index page, you might receive a message from the browser asking you to confirm form resubmission. If you accept, the todo item you previously submitted before handling POST requests will then be added to the database, because the code for handling forms now exists in the route.

Because the index page has no code to display todo items yet, the item you added will not be visible. If you allowed the browser to resubmit your form, you can see the newly added data by opening your mongo shell, and connecting to the `flask_db` database using the following command:

```custom_prefix(>)
use flask_db
```

Then use the `find()` function to get all the todo items in the database:

```custom_prefix(>)
db.todos.find()
```

If any data was resubmitted, you'll see it here in your output.

Next, open the `index.html` template to display the contents of the `todos` list you passed to it:

```custom_prefix((env)sammy@localhost:$)
nano templates/index.html
```

Edit the file by adding an `<hr>` break and a [Jinja `for` loop](https://jinja.palletsprojects.com/en/3.0.x/templates/#for) after the form, so that the file looks as follows:

```html
[label flask_app/templates/index.html]
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FlaskApp</title>
    <style>
        .todo {
            padding: 20px;
            margin: 10px;
            background-color: #eee;
        }
    </style>
</head>
<body>
    <h1>FlaskTODO</h1>
    <hr>
    <div class="content">
    <form method="post">
        <p>
            <b><label for="content">Todo content</label></b>
        </p>
        <p>
            <input type="text" name="content"
                placeholder="Todo Content"></input>
        </p>

        <p>
            <b><label for="degree">Degree</label></b>
        </p>
        <p>
            <input id="degree-0" name="degree" required type="radio" value="Important">
            <label for="degree-0">Important</label>
        </p>
        <p>
            <input id="degree-1" name="degree" required type="radio" value="Unimportant">
            <label for="degree-1">Unimportant</label>
        </p>
        <button type="submit">Submit</button>
    </form>
    <hr>
    {% for todo in todos %}
        <div class="todo">
            <p>{{ todo['content'] }} <i>({{ todo['degree']}})</i></p>
        </div>
    {% endfor %}

    </div>
</body>
</html>
```

Save and close the file.

In this file, you add an `<hr>` tag to separate the web form and the list of todos.

You use a `for` loop in the line `{% for todo in todos %}` to go through each todo item in the `todos` list. You display the todo content and the degree of importance inside a `<p>` tag.

Now refresh your index page, fill in the web form, and submit it. You'll see the todo you added below the form. Next, you'll add a button to allow users to delete existing todos.

## Step 4 — Deleting Todos
In this step, you'll add a route that allows users to delete todos using a button.

First, you'll add a new `/id/delete` route that accepts POST requests. Your new `delete()` view function will receive the ID of the todo to be deleted from the URL, then use that ID to delete it.

To delete a todo, you get its ID as a string, and you must convert it to an [ObjectId](https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId) before passing it to the collection's delete method. So you need to import the `ObjectId()` class from the [`bson` module](https://pymongo.readthedocs.io/en/stable/api/bson/index.html), which handles BSON (Binary JSON) encoding and decoding.

Open `app.py` for editing:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

First, add the following import at the top of the file:

```python
[label flask_app/app.py]
from bson.objectid import ObjectId

# ...
```

This is the `ObjectId()` class you'll use to convert string IDs to ObjectId objects.

Then add the following route at the end:

```python
[label flask_app/app.py]

# ...


@app.post('/<id>/delete/')
def delete(id):
    todos.delete_one({"_id": ObjectId(id)})
    return redirect(url_for('index'))
```

Save and close the file.

Here, instead of using the usual `app.route` decorator, you use the [`app.post`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.Flask.post) decorator introduced in [Flask version 2.0.0](https://flask.palletsprojects.com/en/2.0.x/changes/#version-2-0-0), which added shortcuts for common HTTP methods. For example, `@app.post("/login")` is a shortcut for `@app.route("/login", methods=["POST"])`. This means that this view function only accepts POST requests, and navigating to the `/ID/delete` route on your browser will return a `405 Method Not Allowed` error, because web browsers default to GET requests. To delete a todo, the user clicks on a button that sends a POST request to this route.

The function receives the ID of the todo document to be deleted. You pass this ID to the [`delete_one()`](https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.delete_one) method on the `todos` collection, and you convert the string ID you receive to an ObjectId using the `ObjectId()` class you imported earlier.

After deleting the todo document, you redirect the user to the index page.

Next, edit the `index.html` template to add a **Delete Todo** button:

```custom_prefix((env)sammy@localhost:$)
nano templates/index.html
```

Edit the `for` loop by adding a new `<form>` tag:

```html
[label flask_app/templates/index.html]

    {% for todo in todos %}
        <div class="todo">
            <p>{{ todo['content'] }} <i>({{ todo['degree']}})</i></p>
            <form method="POST" action="{{ url_for('delete', id=todo['_id']) }}" >
                <input type="submit" value="Delete Todo"
                       onclick="return confirm('Are you sure you want to delete this entry?')">
            </form>
        </div>
    {% endfor %}
```
Save and close the file.

Here, you have a web form that submits a POST request to the `delete()` view function. You pass `todo['_id']` to specify the todo that will be deleted. You use the [`confirm()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm) method available in web browsers to display a confirmation message before submitting the request.

Now refresh your index page and you'll see a **Delete Todo** button below each todo item. Click on it, and confirm the deletion. You’ll be redirected to the index page, and the todo will no longer be there.

You now have a way of deleting unwanted todos from your mongoDB database in your Flask application.

To confirm the deletion, open your mongo shell and use the `find()` function:

```custom_prefix(>)
db.todos.find()
```

You should see that the items you've deleted are no longer in your `todos` collection.

## Conclusion
You built a small Flask web application for managing todos that communicates with a MongoDB database. You learned how to connect to a MongoDB database server, create collections that store a group of documents, insert data to a collection, and retrieve and delete data from a collection.

If you would like to read more about Flask, check out the other tutorials in the [How To Create Web Sites with Flask](https://www.digitalocean.com/community/tutorial_series/how-to-create-web-sites-with-flask) series.

For more on MongoDB, see our [How To Manage Data with MongoDB](https://www.digitalocean.com/community/tutorial_series/how-to-manage-data-with-mongodb) tutorial series.




## How to Use Flask-SQLAlchemy to Interact with Databases in a Flask Application

*The author selected the [Free and Open Source Fund](https://www.brightfunds.org/funds/foss-nonprofits) to receive a donation as part of the [Write for DOnations](https://do.co/w4do-cta) program.*

### Introduction

In web applications, you usually need a database, which is an organized collection of data. You use a database to store and maintain persistent data that can be retrieved and manipulated efficiently. For example, in a social media application, you have a database where user data (personal information, posts, comments, followers) is stored in a way that can be efficiently manipulated. You can add data to a database, retrieve it, modify it, or delete it, depending on different requirements and conditions. In a web application, these requirements might be a user adding a new post, deleting a post, or deleting their account, which may or may not delete their posts. The actions you perform to manipulate data will depend on specific features in your application. For example, you might not want users to add posts with no titles.

Flask is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. [SQLAlchemy](https://www.sqlalchemy.org/) is an SQL toolkit that provides efficient and high-performing database access for relational databases. It provides ways to interact with several database engines such as SQLite, MySQL, and PostgreSQL. It gives you access to the database's SQL functionalities. It also gives you an Object Relational Mapper (ORM), which allows you to make queries and handle data using simple Python objects and methods. [Flask-SQLAlchemy](https://flask-sqlalchemy.palletsprojects.com/) is a Flask extension that makes using SQLAlchemy with Flask easier, providing you tools and methods to interact with your database in your Flask applications through SQLAlchemy.

In this tutorial, you’ll build a small student management system that demonstrates how to use the Flask-SQLAlchemy extension. You'll use it with Flask to perform basic tasks, such as connecting to a database server, creating a table, adding data to your table, retrieving it, and updating and deleting items from your database. You'll use SQLAlchemy with [SQLite](https://sqlite.org/index.html), although you can use it with other database engines too, such as PostgreSQL and MySQL. SQLite works well with Python because the Python standard library provides the [`sqlite3` module](https://docs.python.org/3/library/sqlite3.html), which is used by SQLAlchemy behind the scenes to interact with SQLite databases without having to install anything. SQlite is installed on Linux systems by default, and is installed as part of the Python package on Windows.

## Prerequisites

* A local Python 3 programming environment. Follow the tutorial for your distribution in [How To Install and Set Up a Local Programming Environment for Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-python-3) series. In this tutorial we’ll call our project directory `flask_app`.

* An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out [How to Create Your First Web Application Using Flask and Python](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3) and [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).

* An understanding of basic HTML concepts. You can review our [How To Build a Website with HTML](https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html) tutorial series for background knowledge.


## Step 1 — Installing Flask and Flask-SQLAlchemy
In this step, you'll install the necessary packages for your application.

With your virtual environment activated, use `pip` to install Flask and Flask-SQLAlchemy:

```custom_prefix((env)sammy@localhost:$)
pip install Flask Flask-SQLAlchemy
```

Once the installation is successfully finished, you’ll see a line similar to the following at the end of the output:

```
[secondary_label Output]
Successfully installed Flask-2.0.3 Flask-SQLAlchemy-2.5.1 Jinja2-3.0.3 MarkupSafe-2.1.0 SQLAlchemy-1.4.31 Werkzeug-2.0.3 click-8.0.4 greenlet-1.1.2 itsdangerous-2.1.0
```

With the required Python packages installed, you'll set up the database next.

## Step 2 — Setting up the Database and Model
In this step, you'll set up your database connection, and create an SQLAlchemy [_database model_](https://flask-sqlalchemy.palletsprojects.com/en/2.x/models/), which is a Python class that represents the table that stores your data. You'll initiate the database, create a table for students based on the model you'll declare, and add a few students into your students table.

### Setting up The Database Connection

Open a file called `app.py` in your `flask_app` directory. This file will have code for setting up the database and your Flask routes:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

This file will connect to an SQLite database called `database.db`, and have a class called `Student` that represents your database students table for storing student information, in addition to your Flask routes. Add the following `import` statements at the top of `app.py`:

```python
[label flask_app/app.py]
import os
from flask import Flask, render_template, request, url_for, redirect
from flask_sqlalchemy import SQLAlchemy

from sqlalchemy.sql import func
```

Here, you import the [`os` module](https://docs.python.org/3/library/os.html), which gives you access to miscellaneous operating system interfaces. You'll use it to construct a file path for your `database.db` database file.

From the `flask` package, you then import the necessary helpers you need for your application: the `Flask` class to create a Flask application instance, the `render_template()` function to render templates, the `request` object to handle requests, the `url_for()` function to construct URLs for routes, and the `redirect()` function for redirecting users. For more information on routes and templates, see [How To Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).

You then import the `SQLAlchemy` class from the Flask-SQLAlchemy extension, which gives you access to all the functions and classes from SQLAlchemy, in addition to helpers, and functionality that integrates Flask with SQLAlchemy. You'll use it to create a database object that connects to your Flask application, allowing you to create and manipulate tables using Python classes, objects, and functions without needing to use the SQL language.

You also import the `func` helper from the `sqlalchemy.sql` module to access [SQL functions](https://docs.sqlalchemy.org/en/14/tutorial/data_select.html#working-with-sql-functions). You'll need it in your student management system to set a default creation date and time for when a student record is created.

Below the imports, you'll set up a database file path, instantiate your Flask application, and configure and connect your application with SQLAlchemy. Add the following code:

```python
[label flask_app/app.py]

basedir = os.path.abspath(os.path.dirname(__file__))

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] =\
        'sqlite:///' + os.path.join(basedir, 'database.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)
```

Here, you construct a path for your SQLite database file. You first define a base directory as the current directory. You use the [`os.path.abspath()`](https://docs.python.org/3.8/library/os.path.html#os.path.abspath) function to get the absolute path of the current file's directory. The special `__file__` variable holds the pathname of the current `app.py` file. You store the absolute path of the base directory in a variable called `basedir`.

You then create a Flask application instance called `app`, which you use to configure two Flask-SQLAlchemy [configuration keys](https://flask-sqlalchemy.palletsprojects.com/en/2.x/config/):

* `SQLALCHEMY_DATABASE_URI`: The database URI to specify the database you want to establish a connection with. In this case, the URI follows the format `sqlite:///path/to/database.db`. You use the [`os.path.join()`](https://docs.python.org/3.8/library/os.path.html#os.path.join) function to intelligently join the base directory you constructed and stored in the `basedir` variable, and the `database.db` file name. This will connect to a `database.db` database file in your `flask_app` directory. The file will be created once you initiate the database.

* `SQLALCHEMY_TRACK_MODIFICATIONS`: A configuration to enable or disable tracking modifications of objects. You set it to `False` to disable tracking and use less memory. For more, see [the configuration page](https://flask-sqlalchemy.palletsprojects.com/en/2.x/config/) in the Flask-SQLAlchemy documentation.

<$>[note]
**Note:**

If you want to use another database engine such as PostgreSQL or MySQL, you'll need to use the proper URI.

For PostgreSQL, use the following format:
```
postgresql://username:password@host:port/database_name
```

For MySQL:
```
mysql://username:password@host:port/database_name
```

For more, see the [SQLAlchemy documentation for engine configuration](https://docs.sqlalchemy.org/en/14/core/engines.html).
<$>

After configuring SQLAlchemy by setting a database URI and disabling tracking, you create a database object using the `SQLAlchemy` class, passing the application instance to connect your Flask application with SQLAlchemy. You store your database object in a variable called `db`. You'll use this `db` object to interact with your database.

### Declaring The Table

With the database connection established and the database object created, you'll use the database object to create a database table for students, which is represented by a _model_ — a Python class that inherits from a base class Flask-SQLAlchemy provides through the `db` database instance you created earlier. To define a student table as a model, add the following class to your `app.py` file:

```python
[label flask_app/app.py]
# ...

class Student(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    firstname = db.Column(db.String(100), nullable=False)
    lastname = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(80), unique=True, nullable=False)
    age = db.Column(db.Integer)
    created_at = db.Column(db.DateTime(timezone=True),
                           server_default=func.now())
    bio = db.Column(db.Text)

    def __repr__(self):
        return f'<Student {self.firstname}>'
```

Here, you create a `Student` model, which inherits from the `db.Model` class. This represents the student table. You use the [`db.Column`](https://docs.sqlalchemy.org/en/14/core/metadata.html#sqlalchemy.schema.Column) class to define columns for your table. The first argument represents the column type, and additional arguments represent column configuration.

You define the following columns for the `Student` model:

* `id`: The student ID. You define it as an integer with `db.Integer`. `primary_key=True` defines this column as a _primary key_, which will assign it a unique value by the database for each entry (that is a student).
* `firstname`: The student's first name. A string with a maximum length of `100` characters. `nullable=False` signifies that this column should not be empty.
* `lastname`: The student's last name. A string with a maximum length of `100` characters. `nullable=False` signifies that this column should not be empty.
* `email`: The student's email. A string with a maximum length of `80` characters. `unique=True` signifies that each email should be unique for each student. `nullable=False` signifies that this column should not be empty.
* `age`: The student's age.
* `created_at`: The time the student record was created at in the database. You use [`db.DateTime`](https://docs.sqlalchemy.org/en/14/core/type_basics.html#sqlalchemy.types.DateTime) to define it as a Python [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime) object. `timezone=True` enables timezone support. [`server_default`](https://docs.sqlalchemy.org/en/14/core/defaults.html#server-invoked-ddl-explicit-default-expressions) sets the default value in the database when creating the table, so that default values are handled by the database rather than the model. You pass it the [`func.now()`](https://docs.sqlalchemy.org/en/14/core/functions.html#sqlalchemy.sql.functions.now) function which calls the SQL `now()` datetime function. In SQLite, it is rendered as `CURRENT_TIMESTAMP` when creating the student table.
* `bio`: The student's bio. `db.Text()` indicates the column holds long texts.

See the [SQLAlchemy documentation](https://docs.sqlalchemy.org/en/14/core/type_basics.html) for column types other than the types you used in the preceding code block.

The special [`__repr__`](https://docs.python.org/3/reference/datamodel.html#object.__repr__) function allows you to give each object a string representation to recognize it for debugging purposes. In this case you use the student's first name.

The `app.py` file will now look as follows:

```python
[label flask_app/app.py]
import os
from flask import Flask, render_template, request, url_for, redirect
from flask_sqlalchemy import SQLAlchemy

from sqlalchemy.sql import func


basedir = os.path.abspath(os.path.dirname(__file__))

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] =\
        'sqlite:///' + os.path.join(basedir, 'database.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)


class Student(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    firstname = db.Column(db.String(100), nullable=False)
    lastname = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(80), unique=True, nullable=False)
    age = db.Column(db.Integer)
    created_at = db.Column(db.DateTime(timezone=True),
                           server_default=func.now())
    bio = db.Column(db.Text)

    def __repr__(self):
        return f'<Student {self.firstname}>'
```

Save and close `app.py`.

### Creating the Database

Now that you've set the database connection and the student model, you'll use the Flask shell to create your database and your student table based on the `Student` model.

With your virtual environment activated, set the `app.py` file as your Flask application using the `FLASK_APP` environment variable. Then open the Flask shell using the following command in your `flask_app` directory:

```custom_prefix((env)sammy@localhost:$)
export FLASK_APP=app
flask shell
```

A Python interactive shell will be opened. This special shell runs commands in the context of your Flask application, so that the Flask-SQLAlchemy functions you'll call are connected to your application.

Import the database object and the student model, and then run the `db.create_all()` function to create the tables that are associated with your models. In this case you only have one model, which means that the function call will only create one table in your database:

```custom_prefix(>>>)
from app import db, Student
db.create_all()
```

Leave the shell running, open another terminal window and navigate to your `flask_app` directory. You will now see a new file called `database.db` in `flask_app`.

<$>[note]
**Note:**

The `db.create_all()` function does not recreate or update a table if it already exists. For example, if you modify your model by adding a new column, and run the `db.create_all()` function, the change you make to the model will not be applied to the table if the table already exists in the database. The solution is to delete all existing database tables with the `db.drop_all()` function and then recreate them with the `db.create_all()` function like so:

```custom_prefix(>>>)
db.drop_all()
db.create_all()
```

This will apply the modifications you make to your models, but will also delete all the existing data in the database. To update the database and preserve existing data, you'll need to use [_schema migration_](https://en.wikipedia.org/wiki/Schema_migration), which allows you to modify your tables and preserve data. You can use the [`Flask-Migrate`](https://flask-migrate.readthedocs.io/en/latest/index.html) extension to perform SQLAlchemy schema migrations through the Flask command-line interface.
<$>

If you receive an error, make sure your database URI and your model declaration are correct.

### Populating the Table

After creating the database and student table, you'll use the flask shell to add some students to your database through the `Student` model.

Use the same flask shell you opened earlier, or open a new one with your virtual environment activated in your `flask_app` directory:

```custom_prefix((env)sammy@localhost:$)
flask shell
```

To add a student to your database, you'll import the database object and the `Student` model, and create an instance of the `Student` model, passing it student data through keyword arguments as follows:

```custom_prefix(>>>)
from app import db, Student
student_john = Student(firstname='john', lastname='doe',
                       email='jd@example.com', age=23,
                       bio='Biology student')
```

The `student_john` object represents a student that will be added to the database, but this object has not been written to the database yet. Check out the object in the flask shell to see its representation string you constructed with the `__repr__()` method:

```custom_prefix(>>>)
student_john
```

You'll receive the following output:

```
[secondary_label Output]
<Student john>
```

You can get the value of columns using the class attributes you defined in the `Student` model:

```custom_prefix(>>>)
student_john.firstname
student_john.bio
```
```
[secondary_label Output]
'john'
'Biology student'
```

Because this student has not been added to the database yet, its ID will be `None`:

```custom_prefix(>>>)
print(student_john.id)
```
```
[secondary_label Output]
None
```

To add this student to the database, you'll first need to add it to a _database session_, which manages a database transaction. Flask-SQLAlchemy provides the `db.session` object through which you can manage your database changes. Add the `student_john` object to the session using the `db.session.add()` method to prepare it to be written to the database:

```custom_prefix(>>>)
db.session.add(student_john)
```

This will issue an `INSERT` statement, but you won't get an ID back because the database transaction is still not committed. To commit the transaction and apply the change to database, use the `db.session.commit()` method:

```custom_prefix(>>>)
db.session.commit()
```

Now that student John is added to the database, you can get its ID:

```custom_prefix(>>>)
print(student_john.id)
```
```
[secondary_label Output]
1
```

You can also use the `db.session.add()` method to edit an item in the database. For example, you can modify the student's email like so:

```custom_prefix(>>>)
student_john.email = 'john_doe@example.com'
db.session.add(student_john)
db.session.commit()
```

Use the Flask shell to add a few more students to your database:

```custom_prefix(>>>)
sammy = Student(firstname='Sammy',
               lastname='Shark',
               email='sammyshark@example.com',
               age=20,
               bio='Marine biology student')

carl = Student(firstname='Carl',
               lastname='White',
               email='carlwhite@example.com',
               age=22,
               bio='Marine geology student')

db.session.add(sammy)
db.session.add(carl)
db.session.commit()
```

Now, you can query all the records in the student table using the `query` attribute with the `all()` method:

```custom_prefix(>>>)
Student.query.all()
```

You'll receive the following output:

```
[secondary_label Output]
[<Student john>, <Student Sammy>, <Student Carl>]
```

At this point, you have three students in your database. Next, you'll create a Flask route for the index page and display all of the students in your database on it.

## Step 3 — Displaying All Records
In this step, you'll create a route and a template to display all the students in the database on the index page.

Leave the Flask shell running and open a new terminal window.

Open your `app.py` file to add a route for the index page to it:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Add the following route at the end of the file:

```python
[label flask_app/app.py]

# ...

@app.route('/')
def index():
    students = Student.query.all()
    return render_template('index.html', students=students)
```

Save and close the file.

Here, you create an `index()` view function using the `app.route()` decorator. In this function, you query the database and get all the students using the `Student` model with the `query` attribute, which allows you to retrieve one or more items from the database using different methods. You use the `all()` method to get all student entries in the database. You store the query result in a variable called `students` and pass it to a template called `index.html` that you render using the `render_template()` helper function.

Before you create the `index.html` template file on which you'll display the existing students in the database, you'll first create a base template, which will have all the basic HTML code other templates will also use to avoid code repetition. Then you’ll create the `index.html` template file you rendered in your `index()` function. To learn more about templates, see [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).

Create a `templates` directory, then open a new template called `base.html`:

```custom_prefix(sammy@localhost:$)
mkdir templates
nano templates/base.html
```

Add the following code inside the `base.html` file:

```html
[label flask_app/templates/base.html]
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %} {% endblock %} - FlaskApp</title>
    <style>
        .title {
            margin: 5px;
        }

        .content {
            margin: 5px;
            width: 100%;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }

        .student {
            flex: 20%;
            padding: 10px;
            margin: 5px;
            background-color: #f3f3f3;
            inline-size: 100%;
        }

        .bio {
            padding: 10px;
            margin: 5px;
            background-color: #ffffff;
            color: #004835;
        }

        .name a {
            color: #00a36f;
            text-decoration: none;
        }

        nav a {
            color: #d64161;
            font-size: 3em;
            margin-left: 50px;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <nav>
        <a href="{{ url_for('index') }}">FlaskApp</a>
        <a href="#">Create</a>
        <a href="#">About</a>
    </nav>
    <hr>
    <div class="content">
        {% block content %} {% endblock %}
    </div>
</body>
</html>
```
Save and close the file.

This base template has all the HTML boilerplate you’ll need to reuse in your other templates. The `title` block will be replaced to set a title for each page, and the `content` block will be replaced with the content of each page. The navigation bar has three links: one for the index page, which links to the `index()` view function using the `url_for()` helper function, one for a **Create** page, and one for an **About** page if you choose to add one to your application. You'll edit this file later after you add a page for creating new students to make the **Create** link functional.

Next, open a new `index.html` template file. This is the template you referenced in the `app.py` file:

```custom_prefix((env)sammy@localhost:$)
nano templates/index.html
```

Add the following code to it:

```html
[label flask_app/templates/index.html]
{% extends 'base.html' %}

{% block content %}
    <h1 class="title">{% block title %} Students {% endblock %}</h1>
    <div class="content">
        {% for student in students %}
            <div class="student">
                <p><b>#{{ student.id }}</b></p>
                <b>
                    <p class="name">{{ student.firstname }} {{ student.lastname }}</p>
                </b>
                <p>{{ student.email }}</p>
                <p>{{ student.age }} years old.</p>
                <p>Joined: {{ student.created_at }}</p>
                <div class="bio">
                    <h4>Bio</h4>
                    <p>{{ student.bio }}</p>
                </div>
            </div>
        {% endfor %}
    </div>
{% endblock %}
```
Save and close the file.

Here, you extend the base template and replace the contents of the content block. You use an `<h1>` heading that also serves as a title. You use a [Jinja `for` loop](https://jinja.palletsprojects.com/en/3.0.x/templates/#for) in the line `{% for student in students %}` to go through each student in the `students` variable that you passed from the `index()` view function to this template. You display the student ID, their first and last name, email, age, the date at which they were added to the database, and their bio.

While in your `flask_app` directory with your virtual environment activated, tell Flask about the application (`app.py` in this case) using the `FLASK_APP` environment variable. Then set the `FLASK_ENV` environment variable to `development` to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see [How To Handle Errors in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-handle-errors-in-a-flask-application). Use the following commands to do this:

```custom_prefix((env)sammy@localhost:$)
export FLASK_APP=app
export FLASK_ENV=development
```

Next, run the application:

```custom_prefix((env)sammy@localhost:$)
flask run
```

With the development server running, visit the following URL using your browser:

```
http://127.0.0.1:5000/
```

You'll see the students you added to the database in a page similar to the following:

![Index Page](https://assets.digitalocean.com/68167/eP5CpNs.png)

You've displayed the students you have in your database on the index page. Next, you'll create a route for a student page, where you can display the details of each individual student.

## Step 4 — Displaying a Single Record
In this step, you'll use the Flask shell to query students by their ID, and create a route and a template to display the details of each student on a dedicated page.

By the end of this step, the URL `http://127.0.0.1:5000/1` will be a page that displays the first student (because it has the ID `1`). The URL `http://127.0.0.1:5000/ID` will display the post with the associated `ID` number, if it exists.

Leave the development server running and open a new terminal window.

Open the Flask shell for a demonstration of how to query students:

```custom_prefix((env)sammy@localhost:$)
flask shell
```

To query records and retrieve data from the database, Flask-SQLAlchemy provides a `query` attribute on the model class. You can use its methods to get records with a specific filter.

For example, you can use the `filter_by()` method with a parameter such as `firstname` that matches a column in the table with an argument to retrieve a specific student:

```custom_prefix(>>>)
from app import db, Student
Student.query.filter_by(firstname='Sammy').all()
```

```
[secondary_label Output]
[<Student Sammy>]
```

Here you retrieve all the students with `Sammy` as their first name. You use the `all()` method to get a list of all the results. To get the first result, which is the only result here, you can use the `first()` method:

```custom_prefix(>>>)
Student.query.filter_by(firstname='Sammy').first()
```

```
[secondary_label Output]
<Student Sammy>
```

To get a student by its ID, you can use `filter_by(id=ID)`:

```custom_prefix(>>>)
Student.query.filter_by(id=3).first()
```

Or, you can use the shorter `get()` method, which allows you to retrieve a specific item using its primary key:

```custom_prefix(>>>)
Student.query.get(3)
```
Both will give the same output:

```
[secondary_label Output]
<Student Carl>
```

You can now exit the shell:

```custom_prefix(>>>)
exit()
```

To retrieve a student by their ID, you'll create a new route that renders a page for each individual student. You'll use the `get_or_404()` method Flask-SQLAlchemy provides, which is a variant of the `get()` method. The difference is that `get()` returns the value `None` when no result matches the given ID, and `get_or_404()` returns a `404 Not Found` HTTP response. Open `app.py` for modification:

```custom_prefix(sammy@localhost:$)
nano app.py
```

Add the following route at the end of the file:

```python
[label flask_app/app.py]
# ...

@app.route('/<int:student_id>/')
def student(student_id):
    student = Student.query.get_or_404(student_id)
    return render_template('student.html', student=student)
```

Save and close the file.

Here, you use the route `'/<int:student_id>/'`, with `int:` being a [converter](https://flask.palletsprojects.com/en/2.0.x/quickstart/#variable-rules) that converts the default string in the URL into an integer. And `student_id` is the URL variable that will determine the student you'll display on the page.

The ID is passed from the URL to the `student()` view function through the `student_id` parameter. Inside the function, you query the students collection and retrieve a student by the ID using the `get_or_404()` method. This will save the student data in the `student` variable if it exists, and respond with a `404 Not Found` HTTP error if no student with the given ID exists in the database.

You render a template called `student.html` and pass it the student you retrieved.

Open this new `student.html` template file:

```custom_prefix(sammy@localhost:$)
nano templates/student.html
```

Type the following code in this new `student.html` file. This will be similar to the `index.html` template, except that it will only display a single student:

```html
[label flask_app/templates/student.html]
{% extends 'base.html' %}

{% block content %}
    <span class="title">
        <h1>{% block title %} {{ student.firstname }} {{ student.lastname }}{% endblock %}</h1>
    </span>
    <div class="content">
            <div class="student">
                <p><b>#{{ student.id }}</b></p>
                <b>
                    <p class="name">{{ student.firstname }} {{ student.lastname }}</p>
                </b>
                <p>{{ student.email }}</p>
                <p>{{ student.age }} years old.</p>
                <p>Joined: {{ student.created_at }}</p>
                <div class="bio">
                    <h4>Bio</h4>
                    <p>{{ student.bio }}</p>
                </div>
            </div>
    </div>
{% endblock %}
```
Save and close the file.

In this file, you extend the base template, setting the student's full name as a title for the page. You display the student ID, the student's first and last name, email, age, the date of record creation, and their bio.

Use your browser to navigate to the URL for the second student:

```
http://127.0.0.1:5000/2
```

You'll see a page similar to the following:

![Single Student Page](https://assets.digitalocean.com/68167/PthHKjw.png)

Now, edit `index.html` to make each student name link to their page:

```custom_prefix(sammy@localhost:$)
nano templates/index.html
```

Edit the `for` loop to look as follows:

```html
[label flask_app/templates/index.html]
{% for student in students %}
    <div class="student">
        <p><b>#{{ student.id }}</b></p>
        <b>
            <p class="name">
                <a href="{{ url_for('student', student_id=student.id)}}">
                    {{ student.firstname }} {{ student.lastname }}
                </a>
            </p>
        </b>
        <p>{{ student.email }}</p>
        <p>{{ student.age }} years old.</p>
        <p>Joined: {{ student.created_at }}</p>
        <div class="bio">
            <h4>Bio</h4>
            <p>{{ student.bio }}</p>
        </div>
    </div>
{% endfor %}
```

Save and close the file.

You added an `<a>` tag to the student's full name which links to the student page using the `url_for()` function, passing the student ID that's stored in `student.id` to the `student()` view function.

Navigate to your index page or refresh it:

```
http://127.0.0.1:5000/
```

You'll now see that each student name links to the proper student page.

After creating a page for individual students, you'll next add a page for adding new students to the database.

## Step 5 — Creating a New Record

In this step, you'll add a new route to your application for adding new students to the database using web forms.

You'll render a page with a web form where users enter the student's data. Then you'll handle the form submission, create an object for the new student using the `Student` model, add it to the session, then commit the transaction, similar to how you've added student entries in Step 2.

Leave the development server running and open a new terminal window.

First, open your `app.py` file:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Add the following route at the end of the `app.py` file:

```python
[label flask_app/app.py]
# ...


@app.route('/create/', methods=('GET', 'POST'))
def create():
    return render_template('create.html')
```

Save and close the file.


In this route, you pass the tuple `('GET', 'POST')` to the `methods` parameter to allow both GET and POST requests. GET requests are used to retrieve data from the server. POST requests are used to post data to a specific route. By default, only GET requests are allowed. When the user first requests the `/create` route using a GET request, a template file called `create.html` will be rendered. You will later edit this route to handle POST requests for when users fill in and submit the web form for adding new students.

Open the new `create.html` template:

```custom_prefix((env)sammy@localhost:$)
nano templates/create.html
```

Add the following code to it:

```html
{% extends 'base.html' %}

{% block content %}
    <h1 style="width: 100%">{% block title %} Add a New Student {% endblock %}</h1>
    <form method="post">
        <p>
            <label for="firstname">First Name</label>
            <input type="text" name="firstname"
                   placeholder="First name">
            </input>
        </p>

        <p>
            <label for="lastname">Last Name</label>
            <input type="text" name="lastname"
                   placeholder="Last name">
            </input>
        </p>

        <p>
            <label for="email">Email</label>
            <input type="email" name="email"
                   placeholder="Student email">
            </input>
        </p>

        <p>
            <label for="age">Age</label>
            <input type="number" name="age"
                   placeholder="Age">
            </input>
        </p>

        <p>
        <label for="bio">Bio</label>
        <br>
        <textarea name="bio"
                  placeholder="Bio"
                  rows="15"
                  cols="60"
                  ></textarea>
        </p>
        <p>
            <button type="submit">Submit</button>
        </p>
    </form>
{% endblock %}
```

Save and close the file.

You extend the base template, set a heading as a title, and use a `<form>` tag with the attribute `method` set to `post` to indicate that the form will submit a POST request.

You have two text fields with the names `firstname` and `lastname`. You'll use these names to access the form data the user submits in your view function later.

You have an email field with the name `email`, a number field for the student's age, and a text area for the student's bio.

Last, you have a **Submit** button at the end of the form.

Now, with the development server running, use your browser to navigate to the `/create` route:

```
http://127.0.0.1:5000/create
```

You will see an **Add a New Student** page with a web form and a **Submit** button like so:

![Add a New Student](https://assets.digitalocean.com/68167/XZDcCO0.png)

If you fill in the form and submit it, sending a POST request to the server, nothing happens because you did not handle POST requests on the `/create` route.

Open `app.py` to handle the POST request the user submits:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Edit the `/create` route to look as follows:

```python
[label flask_app/app.py]

@app.route('/create/', methods=('GET', 'POST'))
def create():
    if request.method == 'POST':
        firstname = request.form['firstname']
        lastname = request.form['lastname']
        email = request.form['email']
        age = int(request.form['age'])
        bio = request.form['bio']
        student = Student(firstname=firstname,
                          lastname=lastname,
                          email=email,
                          age=age,
                          bio=bio)
        db.session.add(student)
        db.session.commit()

        return redirect(url_for('index'))

    return render_template('create.html')
```
Save and close the file.

You handle POST requests inside the `if request.method == 'POST'` condition. You extract the first name, last name, email, age, and bio the user submits from the `request.form` object. You convert the age that gets passed as a string into an integer using the [`int()`](https://docs.python.org/3.8/library/functions.html#int) Python function. You construct a `student` object using the `Student` model. You add the student object to the database session, then commit the transaction.

Lastly, you redirect the user to the index page where they can see the newly added student below the existing students.

With the development server running, use your browser to navigate to the `/create` route:

```
http://127.0.0.1:5000/create
```

Fill in the form with some data and submit it.

You’ll be redirected to the index page where you’ll see your newly added student.

Now that you have the functionality to add new students, you'll need to  add a link to the **Create** page in the navigation bar. Open `base.html`:

```custom_prefix((env)sammy@localhost:$)
nano templates/base.html
```

Edit the `<body>` tag by modifying the value of the `href` attribute for the `Create` link:

```html
[label flask_app/templates/base.html]
<body>
    <nav>
        <a href="{{ url_for('index') }}">FlaskApp</a>
        <a href="{{ url_for('create') }}">Create</a>
        <a href="#">About</a>
    </nav>
    <hr>
    <div class="content">
        {% block content %} {% endblock %}
    </div>
</body>
```

Save and close the file.

Refresh your index page and you’ll notice the **Create** link in the navigation bar is now functional.

You now have a page with a web form for adding new students. For more on web forms, see [How To Use Web Forms in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-web-forms-in-a-flask-application). For a more advanced and more secure method of managing web forms, see [How To Use and Validate Web Forms with Flask-WTF](https://www.digitalocean.com/community/tutorials/how-to-use-and-validate-web-forms-with-flask-wtf). Next, you'll add a page for editing the data of existing students.

## Step 6 — Editing a Record
In this step, you'll add a new page to your application for editing existing student data. You'll add a new `/ID/edit/` route to edit the data of students based on their ID.

Open `app.py`:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Add the following route to the end of the file. This fetches the student entry you want to edit using its ID. It extracts the new student data submitted via a web form you'll will create later. Then it edits the student data, and redirects the user to the index page:

```python
[label flask_app/app.py]
# ...


@app.route('/<int:student_id>/edit/', methods=('GET', 'POST'))
def edit(student_id):
    student = Student.query.get_or_404(student_id)

    if request.method == 'POST':
        firstname = request.form['firstname']
        lastname = request.form['lastname']
        email = request.form['email']
        age = int(request.form['age'])
        bio = request.form['bio']

        student.firstname = firstname
        student.lastname = lastname
        student.email = email
        student.age = age
        student.bio = bio

        db.session.add(student)
        db.session.commit()

        return redirect(url_for('index'))

    return render_template('edit.html', student=student)
```
Save and close the file.

Here, you have the route `/<int:student_id>/edit/` that accepts both POST and GET methods, with `student_id` as a URL variable that passes the ID to the `edit()` view function.

You use the `get_or_404()` query method on the `Student` model to get the student associated with the given student ID. This will respond with a `404 Not Found` error in case no student with the given ID exists in the database.

If the given ID has a student associated with it, code execution continues to the `if request.method == 'POST'` condition. If the request was a GET request, meaning that the user did not submit a form, then this condition is false, and the code inside it will be skipped to the line `return render_template('edit.html', student=student)`. This renders an `edit.html` template, passing it the student object you got from the database, allowing you to fill the student web form with current student data. You will create this `edit.html` template later.

When a user edits student data and submits the form, the code inside the `if request.method == 'POST'` is executed. You extract the submitted student data from the `request.form` object into corresponding variables. You set each attribute of the `student` object to the newly submitted data to change column values as you've done in Step 2. If no change was performed on a field on the web form, the value of that column will stay the same in the database.

After you set the student data to the newly submitted data, you add the `student` object to the database session, then you commit the changes. Lastly, you redirect the user to the index page.

Next, you need to create a page where users can do the editing. Open a new `edit.html` template:

```custom_prefix(sammy@localhost:$)
nano templates/edit.html
```

This new file will have a web form similar to the one that's in the `create.html` file with current student data as default values for the fields. Add the following code inside it:

```html
[label flask_app/templates/edit.html]

{% extends 'base.html' %}

{% block content %}
    <h1 style="width: 100%">
        {% block title %} Edit {{ student.firstname }}
                               {{ student.lastname }}'s Details
        {% endblock %}
    </h1>
    <form method="post">
        <p>
            <label for="firstname">First Name</label>
            <input type="text" name="firstname"
                   value={{ student.firstname }}
                   placeholder="First name">
            </input>
        </p>

        <p>
            <label for="lastname">Last Name</label>
            <input type="text" name="lastname"
                   value={{ student.lastname }}
                   placeholder="Last name">
            </input>
        </p>

        <p>
            <label for="email">Email</label>
            <input type="email" name="email"
                   value={{ student.email }}
                   placeholder="Student email">
            </input>
        </p>

        <p>
            <label for="age">Age</label>
            <input type="number" name="age"
                   value={{ student.age }}
                   placeholder="Age">
            </input>
        </p>

        <p>
        <label for="bio">Bio</label>
        <br>
        <textarea name="bio"
                  placeholder="Bio"
                  rows="15"
                  cols="60"
                  >{{ student.bio }}</textarea>
        </p>
        <p>
            <button type="submit">Submit</button>
        </p>
    </form>
{% endblock %}
```

Save and close the file.

The title has the student's first name and last name. The `value` attribute of each input field and the value of the bio text area are set to the corresponding value in the `student` object you passed from the `edit()` view function to the `edit.html` template.

Now, navigate to the following URL to edit the first student's details:

```
http://127.0.0.1:5000/1/edit
```

You will see a page similar to the following:

![Edit a Student](https://assets.digitalocean.com/68167/b6JRkIy.png)

Edit the student's data and submit the form. You'll be redirected to the index page, and the student's information will be updated.

Next, you'll add an **Edit** button below each student on the index page to link to their edit page. Open the `index.html` template file:

```custom_prefix((env)sammy@localhost:$)
nano templates/index.html
```

Edit the `for` loop in this `index.html` file to look exactly like the following:

```html
[label flask_app/templates/index.html]

{% for student in students %}
    <div class="student">
        <p><b>#{{ student.id }}</b></p>
        <b>
            <p class="name">
                <a href="{{ url_for('student', student_id=student.id)}}">
                    {{ student.firstname }} {{ student.lastname }}
                </a>
            </p>
        </b>
        <p>{{ student.email }}</p>
        <p>{{ student.age }} years old.</p>
        <p>Joined: {{ student.created_at }}</p>
        <div class="bio">
            <h4>Bio</h4>
            <p>{{ student.bio }}</p>
        </div>
        <a href="{{ url_for('edit', student_id=student.id) }}">Edit</a>
    </div>
{% endfor %}
```
Save and close the file.

Here you add an `<a>` tag to link to the `edit()` view function, passing in the `student.id` value to link to the edit page of each student with an **Edit** link.

You now have a page for editing existing students. Next, you'll add a **Delete** button to delete students from the database.

## Step 7 — Deleting a Record
In this step, you'll add a new route and **Delete** button for deleting existing students.

First, you'll add a new `/id/delete` route that accepts POST requests. Your new `delete()` view function will receive the ID of the student you want to delete, pass the ID to the `get_or_404()` query method on the `Student` model to get it if it exists, or respond with a `404 Not Found` page if no student with the given ID was found on the database.

Open `app.py` for editing:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Add the following route to the end of the file:

```python
[label flask_app/app.py]

# ...

@app.post('/<int:student_id>/delete/')
def delete(student_id):
    student = Student.query.get_or_404(student_id)
    db.session.delete(student)
    db.session.commit()
    return redirect(url_for('index'))
```

Save and close the file.

Here, instead of using the usual `app.route` decorator, you use the [`app.post`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.Flask.post) decorator introduced in [Flask version 2.0.0](https://flask.palletsprojects.com/en/2.0.x/changes/#version-2-0-0), which added shortcuts for common HTTP methods. For example, `@app.post("/login")` is a shortcut for `@app.route("/login", methods=["POST"])`. This means that this view function only accepts POST requests, and navigating to the `/ID/delete` route on your browser will return a `405 Method Not Allowed` error, because web browsers default to GET requests. To delete a student, the user clicks on a button that sends a POST request to this route.

This `delete()` view function receives the ID of the student to be deleted via the `student_id` URL variable. You use the `get_or_404()` method to get a student and save it in a `student` variable, or respond with a `404 Not Found` in case the student doesn't exist. You use the `delete()` method on the database session in the line `db.session.delete(student)`, passing it the student object. This sets up the session to delete the student whenever the transaction is committed. Because you don't need to perform any other modifications, you directly commit the transaction using `db.session.commit()`. Lastly, you redirect the user to the index page.

Next, edit the `index.html` template to add a **Delete Student** button:

```custom_prefix(sammy@localhost:$)
nano templates/index.html
```

Edit the `for` loop by adding a new `<form>` tag directly below the **Edit** link:

```html
[label flask_app/templates/index.html]

{% for student in students %}
    <div class="student">
        <p><b>#{{ student.id }}</b></p>
        <b>
            <p class="name">
                <a href="{{ url_for('student', student_id=student.id)}}">
                    {{ student.firstname }} {{ student.lastname }}
                </a>
            </p>
        </b>
        <p>{{ student.email }}</p>
        <p>{{ student.age }} years old.</p>
        <p>Joined: {{ student.created_at }}</p>
        <div class="bio">
            <h4>Bio</h4>
            <p>{{ student.bio }}</p>
        </div>
        <a href="{{ url_for('edit', student_id=student.id) }}">Edit</a>

        <hr>
        <form method="POST"
                action="{{ url_for('delete', student_id=student.id) }}">
            <input type="submit" value="Delete Student"
                onclick="return confirm('Are you sure you want to delete this entry?')">
        </form>

    </div>
{% endfor %}
```

Save and close the file.

Here, you have a web form that submits a POST request to the `delete()` view function. You pass `student.id` as an argument for the `student_id` parameter to specify the student entry to be deleted. You use the [`confirm()` method](https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm) function available in web browsers to display a confirmation message before submitting the request.

Now refresh your index page.

You’ll see a **Delete Student** button below each student entry. Click on it, and confirm the deletion. You’ll be redirected to the index page, and the student will no longer be there.

You now have a way of deleting students from the database in your student management application.

## Conclusion
You built a small Flask web application for managing students using Flask and Flask-SQLAlchemy with an SQLite database. You learned how to connect to your database, set up database models that represent your tables, add items to your database, query your table, and modify database data.

Using SQLAlchemy in your application allows you to use Python classes and objects to manage your SQL database. Instead of SQLite, you can use another database engine, and other than the `SQLALCHEMY_DATABASE_URI` configuration responsible for the connection, you don't need to change anything in your core application code. That allows you to move from one SQL database engine to another with minimal code change. See the [Flask-SQLAlchemy documentation](https://flask-sqlalchemy.palletsprojects.com/en/2.x/config/) for more information.

If you would like to read more about Flask, check out the other tutorials in the [How To Build Web Applications with Flask](https://www.digitalocean.com/community/tutorial_series/how-to-create-web-sites-with-flask) series. 



## How to Use One-to-Many Database Relationships with Flask-SQLAlchemy

*The author selected the [Free and Open Source Fund](https://www.brightfunds.org/funds/foss-nonprofits) to receive a donation as part of the [Write for DOnations](https://do.co/w4do-cta) program.*

### Introduction

[Flask](https://palletsprojects.com/p/flask/) is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. [SQLAlchemy](https://www.sqlalchemy.org/) is an SQL toolkit that provides efficient and high-performing database access for relational databases. It provides ways to interact with several database engines such as SQLite, MySQL, and PostgreSQL. It gives you access to the database's SQL functionalities. And it also gives you an Object Relational Mapper (ORM), which allows you to make queries and handle data using simple Python objects and methods. [Flask-SQLAlchemy](https://flask-sqlalchemy.palletsprojects.com/) is a Flask extension that makes using SQLAlchemy with Flask easier, providing you tools and methods to interact with your database in your Flask applications through SQLAlchemy.

A _one-to-many database relationship_ is a relationship between two database tables where a record in one table can reference several records in another table. For example, in a blogging application, a table for storing posts can have a one-to-many relationship with a table for storing comments. Each post can reference many comments, and each comment references a single post; therefore, one post has a relationship with many comments. The post table is a _parent table_, while the comments table is a _child table_ — a record in the parent table can reference many records in the child table. This relationship is important to enable access to related data in each table.

In this tutorial, you’ll build a small blogging system that demonstrates how to build one-to-many relationships using the Flask-SQLAlchemy extension. You'll create a relationship between posts and comments, where each blog post can have several comments.

## Prerequisites

* A local Python 3 programming environment. Follow the tutorial for your distribution in [How To Install and Set Up a Local Programming Environment for Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-python-3) series. In this tutorial we’ll call our project directory `flask_app`.

* An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out [How to Create Your First Web Application Using Flask and Python](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3) and [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).

* An understanding of basic HTML concepts. You can review our [How To Build a Website with HTML](https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html) tutorial series for background knowledge.

## Step 1 — Installing Flask and Flask-SQLAlchemy
In this step, you'll install the necessary packages for your application.

With your virtual environment activated, use `pip` to install Flask and Flask-SQLAlchemy:

```custom_prefix((env)sammy@localhost:$)
pip install Flask Flask-SQLAlchemy
```

Once the installation is successfully finished, you’ll see a line similar to the following at the end of the output:

```
[secondary_label Output]
Successfully installed Flask-2.1.1 Flask-SQLAlchemy-2.5.1 Jinja2-3.1.1 MarkupSafe-2.1.1 SQLAlchemy-1.4.35 Werkzeug-2.1.1 click-8.1.2 greenlet-1.1.2 itsdangerous-2.1.2
```

With the required Python packages installed, you'll set up the database next.

## Step 2 — Setting up the Database and Models
In this step, you'll set up your database, and create SQLAlchemy _database models_ — Python classes that represent your database tables. You'll create a model for your blog posts and a model for comments. You'll initiate the database, create a table for posts, and add a table for comments based on the models you'll declare. You'll also insert a few posts and comments into your database.

### Setting up The Database Connection

Open a file called `app.py` in your `flask_app` directory. This file will have code for setting up the database and your Flask routes:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

This file will connect to an SQLite database called `database.db`, and will have two classes: A class called `Post` that represents your database posts table, and a `Comment` class representing the comments table. This file will also contain your Flask routes. Add the following `import` statements at the top of `app.py`:

```python
[label flask_app/app.py]
import os
from flask import Flask, render_template, request, redirect, url_for
from flask_sqlalchemy import SQLAlchemy

```

Here, you import the [`os` module](https://docs.python.org/3/library/os.html), which gives you access to miscellaneous operating system interfaces. You'll use it to construct a file path for your `database.db` database file.

From the `flask` package, you then import the necessary helpers you need for your application: the `Flask` class to create a Flask application instance, the `render_template()` function to render templates, the `request` object to handle requests, the `url_for()` function to construct URLs for routes, and the `redirect()` function for redirecting users. For more information on routes and templates, see [How To Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).

You then import the `SQLAlchemy` class from the Flask-SQLAlchemy extension, which gives you access to all the functions and classes from SQLAlchemy, in addition to helpers, and functionality that integrates Flask with SQLAlchemy. You'll use it to create a database object that connects to your Flask application, allowing you to create and manipulate tables using Python classes, objects, and functions without needing to use the SQL language.

Below the imports, you'll set up a database file path, instantiate your Flask application, and configure and connect your application with SQLAlchemy. Add the following code:

```python
[label flask_app/app.py]

basedir = os.path.abspath(os.path.dirname(__file__))

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] =\
           'sqlite:///' + os.path.join(basedir, 'database.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False


db = SQLAlchemy(app)
```

Here, you construct a path for your SQLite database file. You first define a base directory as the current directory. You use the [`os.path.abspath()`](https://docs.python.org/3.8/library/os.path.html#os.path.abspath) function to get the absolute path of the current file's directory. The special `__file__` variable holds the pathname of the current `app.py` file. You store the absolute path of the base directory in a variable called `basedir`.

You then create a Flask application instance called `app`, which you use to configure two Flask-SQLAlchemy [configuration keys](https://flask-sqlalchemy.palletsprojects.com/en/2.x/config/):

* `SQLALCHEMY_DATABASE_URI`: The database URI to specify the database you want to establish a connection with. In this case, the URI follows the format `sqlite:///path/to/database.db`. You use the [`os.path.join()`](https://docs.python.org/3.8/library/os.path.html#os.path.join) function to intelligently join the base directory you constructed and stored in the `basedir` variable, and the `database.db` file name. This will connect to a `database.db` database file in your `flask_app` directory. The file will be created once you initiate the database.

* `SQLALCHEMY_TRACK_MODIFICATIONS`: A configuration to enable or disable tracking modifications of objects. You set it to `False` to disable tracking and use less memory. For more, see [the configuration page](https://flask-sqlalchemy.palletsprojects.com/en/2.x/config/) in the Flask-SQLAlchemy documentation.

<$>[note]
**Note:** If you want to use another database engine such as PostgreSQL or MySQL, you'll need to use the proper URI.

For PostgreSQL, use the following format:
```
postgresql://username:password@host:port/database_name
```

For MySQL:
```
mysql://username:password@host:port/database_name
```

For more, see the [SQLAlchemy documentation for engine configuration](https://docs.sqlalchemy.org/en/14/core/engines.html).
<$>

After configuring SQLAlchemy by setting a database URI and disabling tracking, you create a database object using the `SQLAlchemy` class, passing the application instance to connect your Flask application with SQLAlchemy. You store your database object in a variable called `db`. You'll use this `db` object to interact with your database.

### Declaring The Tables

With the database connection established and the database object created, you'll use the database object to create a database table for posts and one for comments. Tables are represented by a _model_ — a Python class that inherits from a base class Flask-SQLAlchemy provides through the `db` database instance you created earlier. To define the posts and comments tables as models, add the following two classes to your `app.py` file:

```python
[label flask_app/app.py]

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100))
    content = db.Column(db.Text)
    comments = db.relationship('Comment', backref='post')

    def __repr__(self):
        return f'<Post "{self.title}">'


class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text)
    post_id = db.Column(db.Integer, db.ForeignKey('post.id'))

    def __repr__(self):
        return f'<Comment "{self.content[:20]}...">'
```

Here, you create a `Post` model and a `Comment` model, which inherit from the `db.Model` class.

The `Post` model represents the post table. You use the [`db.Column`](https://docs.sqlalchemy.org/en/14/core/metadata.html#sqlalchemy.schema.Column) class to define its columns. The first argument represents the column type, and additional arguments represent the column configuration.

You define the following columns for the `Post` model:

* `id`: The post ID. You define it as an integer with `db.Integer`. `primary_key=True` defines this column as a _primary key_, which will assign it a unique value by the database for each entry (that is, each post).
* `title`: The post's title. A string with a maximum length of 100 characters.
* `content`: The post's content. `db.Text` indicates the column holds long texts.

The `comments` class attribute defines a One-to-Many relationship between the `Post` model and the `Comment` model. You use the `db.relationship()` method, passing it the name of the comments model (`Comment` in this case). You use the `backref` parameter to add a back reference that behaves like a column to the `Comment` model. This way, you can access the post the comment was posted on using a `post` attribute. For example, if you have a comment object in a variable called `comment`, you will be able to access the post the comment belongs to using `comment.post`. You'll see an example demonstrating this later.

See the [SQLAlchemy documentation](https://docs.sqlalchemy.org/en/14/core/type_basics.html) for column types other than the types you used in the preceding code block.

The special [`__repr__`](https://docs.python.org/3/reference/datamodel.html#object.__repr__) function allows you to give each object a string representation to recognize it for debugging purposes.

The `Comment` model represents the comment table. You define the following columns for it:

* `id`: The comment ID. You define it as an integer with `db.Integer`. `primary_key=True` defines this column as a _primary key_, which will assign it a unique value by the database for each entry (that is, each comment).
* `content`: The comment's content. `db.Text` indicates the column holds long texts.
* `post_id`: An integer _foreign key_ you construct using the `db.ForeignKey()` class, which is a key that links a table with another, using that table's primary key. This links a comment to a post using the primary key of the post, which is its ID. Here, the `post` table is a _parent table_, which indicates that each post has many comments. The `comment` table is a _child table_. Each comment is related to a parent post using the post's ID. Therefore, each comment has a `post_id` column that can be used to access the post the comment was posted on.

The special [`__repr__`](https://docs.python.org/3/reference/datamodel.html#object.__repr__) function in the `Comment` model shows the first 20 characters of the comment's content to give a comment object a short string representation.

The `app.py` file will now look as follows:

```python
[label flask_app/app.py]
import os
from flask import Flask, render_template, request, redirect, url_for
from flask_sqlalchemy import SQLAlchemy

basedir = os.path.abspath(os.path.dirname(__file__))

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] =\
           'sqlite:///' + os.path.join(basedir, 'database.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False


db = SQLAlchemy(app)


class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100))
    content = db.Column(db.Text)
    comments = db.relationship('Comment', backref='post')

    def __repr__(self):
        return f'<Post "{self.title}">'


class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text)
    post_id = db.Column(db.Integer, db.ForeignKey('post.id'))

    def __repr__(self):
        return f'<Comment "{self.content[:20]}...">'
```

Save and close `app.py`.

### Creating the Database

Now that you've set the database connection and the post and comment models, you’ll use the Flask shell to create your database and your post and comment tables based on the models you declared.

With your virtual environment activated, set the `app.py` file as your Flask application using the `FLASK_APP` environment variable:

```custom_prefix((env)sammy@localhost:$)
export FLASK_APP=app
```
Then open the Flask shell using the following command in your `flask_app` directory:

```custom_prefix((env)sammy@localhost:$)
flask shell
```

A Python interactive shell will be opened. This special shell runs commands in the context of your Flask application, so that the Flask-SQLAlchemy functions you'll call are connected to your application.

Import the database object and the post and comment models, and then run the `db.create_all()` function to create the tables that are associated with your models:

```custom_prefix(>>>)
from app import db, Post, Comment
db.create_all()
```

Leave the shell running, open another terminal window and navigate to your `flask_app` directory. You will now see a new file called `database.db` in `flask_app`.

<$>[note]
**Note:** The `db.create_all()` function does not recreate or update a table if it already exists. For example, if you modify your model by adding a new column, and run the `db.create_all()` function, the change you make to the model will not be applied to the table if the table already exists in the database. The solution is to delete all existing database tables with the `db.drop_all()` function and then recreate them with the `db.create_all()` function like so:

```custom_prefix(>>>)
db.drop_all()
db.create_all()
```

This will apply the modifications you make to your models, but will also delete all the existing data in the database. To update the database structure and preserve existing data, you'll need to use [_schema migration_](https://en.wikipedia.org/wiki/Schema_migration), which allows you to modify your tables and preserve data. You can use the [Flask-Migrate](https://flask-migrate.readthedocs.io/en/latest/index.html) extension to perform SQLAlchemy schema migrations through the Flask command-line interface.
<$>

If you receive an error, make sure your database URI and your model declaration are correct.

### Populating the Tables

After creating the database and the post and comment tables, you'll create a file in your `flask_app` directory to add some posts and comments to your database.

Open a new file called `init_db.py`:

```custom_prefix((env)sammy@localhost:$)
nano init_db.py
```

Add the following code to it. This file will create three post objects and four comment objects, and add them to the database:

```python
[label flask_app/init_db.py]
from app import db, Post, Comment

post1 = Post(title='Post The First', content='Content for the first post')
post2 = Post(title='Post The Second', content='Content for the Second post')
post3 = Post(title='Post The Third', content='Content for the third post')

comment1 = Comment(content='Comment for the first post', post=post1)
comment2 = Comment(content='Comment for the second post', post=post2)
comment3 = Comment(content='Another comment for the second post', post_id=2)
comment4 = Comment(content='Another comment for the first post', post_id=1)


db.session.add_all([post1, post2, post3])
db.session.add_all([comment1, comment2, comment3, comment4])

db.session.commit()
```

Save and close the file.

Here, you import the database object, the `Post` model, and the `Comment` model from the `app.py` file.

You create a few post objects using the `Post` model, passing the post's title to the `title` parameter and the post's content to the `content` parameter.

You then create a few comment objects, passing the comment's content. You have two methods you can use to associate a comment with the post it belongs to. You can pass the post object to the `post` parameter as demonstrated in the `comment1` and `comment2` objects. And you can also pass the post ID to the `post_id` parameter, as demonstrated in the `comment3` and `comment4` objects. So you can just pass the integer ID of the post if you don't have the post object in your code.

After defining the post and comment objects, you use the `db.session.add_all()` to add all post and comment objects to the database session, which manages transactions. Then you use the `db.session.commit()` method to commit the transaction and apply the changes to the database. For more on SQLAlchemy database sessions, see step 2 of the [How to Use Flask-SQLAlchemy to Interact with Databases in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application#step-2-setting-up-the-database-and-model) tutorial.

Run the `init_db.py` file to execute the code and add the data to the database:

```custom_prefix((env)sammy@localhost:$)
python init_db.py
```

To take a look at the data you added to your database, open the flask shell to query all posts and display their titles and the content of each post's comments:

```custom_prefix((env)sammy@localhost:$)
flask shell
```

Run the following code. This queries all posts and displays each post title and the comments of each post below it:

```python
from app import Post

posts = Post.query.all()

for post in posts:
    print(f'## {post.title}')
    for comment in post.comments:
            print(f'> {comment.content}')
    print('----')
```

Here, you import the `Post` model from the `app.py` file. You query all the posts that exist in the database using the `all()` method on the `query` attribute, and save the result in a variable called `posts`. Then you use a `for` loop to go through each item in the `posts` variable. You print the title and then use another `for` loop to go through each comment belonging to the post. You access the post's comments using `post.comments`. You print the comment's content and then print the string `'----'` to separate between posts.

You'll get the following output:

```
[secondary_label Output]

## Post The First
> Comment for the first post
> Another comment for the first post
----
## Post The Second
> Comment for the second post
> Another comment for the second post
----
## Post The Third
----
```

As you can see, you can access the data of each post and the comments of each post with very little code.

Now exit the shell:

```custom_prefix(>>>)
exit()
```

At this point, you have several posts and comments in your database. Next, you'll create a Flask route for the index page and display all of the posts in your database on it.

## Step 3 — Displaying All Posts
In this step, you'll create a route and a template to display all the posts in the database on the index page.

Open your `app.py` file to add a route for the index page to it:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Add the following route at the end of the file:

```python
[label flask_app/app.py]

# ...

@app.route('/')
def index():
    posts = Post.query.all()
    return render_template('index.html', posts=posts)
```

Save and close the file.

Here, you create an `index()` view function using the `app.route()` decorator. In this function, you query the database and get all the posts like you did in the previous step. You store the query result in a variable called `posts` and then you pass it to a `index.html` template file you render using the `render_template()` helper function.

Before you create the `index.html` template file on which you'll display the existing posts in the database, you'll first create a base template, which will have all the basic HTML code other templates will also use to avoid code repetition. Then you’ll create the `index.html` template file you rendered in your `index()` function. To learn more about templates, see [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).

Create a `templates` directory, then open a new template called `base.html`:

```custom_prefix((env)sammy@localhost:$)
mkdir templates
nano templates/base.html
```

Add the following code inside the `base.html` file:

```html
[label flask_app/templates/base.html]

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %} {% endblock %} - FlaskApp</title>
    <style>
        .title {
            margin: 5px;
        }

        .content {
            margin: 5px;
            width: 100%;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }

        .comment {
            padding: 10px;
            margin: 10px;
            background-color: #fff;
        }

        .post {
            flex: 20%;
            padding: 10px;
            margin: 5px;
            background-color: #f3f3f3;
            inline-size: 100%;
        }

        .title a {
            color: #00a36f;
            text-decoration: none;
        }

        nav a {
            color: #d64161;
            font-size: 3em;
            margin-left: 50px;
            text-decoration: none;
        }

    </style>
</head>
<body>
    <nav>
        <a href="{{ url_for('index') }}">FlaskApp</a>
        <a href="#">Comments</a>
        <a href="#">About</a>
    </nav>
    <hr>
    <div class="content">
        {% block content %} {% endblock %}
    </div>
</body>
</html>
```

Save and close the file.

This base template has all the HTML boilerplate you’ll need to reuse in your other templates. The `title` block will be replaced to set a title for each page, and the `content` block will be replaced with the content of each page. The navigation bar has three links: one for the index page, which links to the `index()` view function using the `url_for()` helper function, one for a **Comments** page, and one for an **About** page if you choose to add one to your application. You'll edit this file later after you add a page for displaying all the latest comments to make the **Comments** link functional.

Next, open a new `index.html` template file. This is the template you referenced in the `app.py` file:

```custom_prefix((env)sammy@localhost:$)
nano templates/index.html
```

Add the following code to it:

```html
[label flask_app/templates/index.html]
{% extends 'base.html' %}

{% block content %}
    <span class="title"><h1>{% block title %} Posts {% endblock %}</h1></span>
    <div class="content">
        {% for post in posts %}
            <div class="post">
                <p><b>#{{ post.id }}</b></p>
                <b>
                    <p class="title">
                        <a href="#">
                            {{ post.title }}
                        </a>
                    </p>
                </b>
                <div class="content">
                    <p>{{ post.content }}</p>
                </div>
                <hr>
            </div>
        {% endfor %}
    </div>
{% endblock %}
```

Save and close the file.

Here, you extend the base template and replace the contents of the content block. You use an `<h1>` heading that also serves as a title. You use a [Jinja `for` loop](https://jinja.palletsprojects.com/en/3.0.x/templates/#for) in the line `{% for post in posts %}` to go through each post in the `posts` variable that you passed from the `index()` view function to this template. You display the post ID, its title, and the post content. The post title will later link to a page that displays the individual post and its comments.

While in your `flask_app` directory with your virtual environment activated, tell Flask about the application (`app.py` in this case) using the `FLASK_APP` environment variable. Then set the `FLASK_ENV` environment variable to `development` to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see [How To Handle Errors in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-handle-errors-in-a-flask-application). Use the following commands to do this:

```custom_prefix((env)sammy@localhost:$)
export FLASK_APP=app
export FLASK_ENV=development
```

Next, run the application:

```custom_prefix((env)sammy@localhost:$)
flask run
```

With the development server running, visit the following URL using your browser:

```
http://127.0.0.1:5000/
```

You'll see the posts you added to the database in a page similar to the following:

![Index Page](https://assets.digitalocean.com/articles/68194/ibgcWby.png)

You've displayed the posts you have in your database on the index page. Next, you'll create a route for a post page, where you will display the details of each post and its comments below it.

## Step 4 — Displaying a Single Post and its Comments

In this step, you'll create a route and a template to display the details of each post on a dedicated page, and the post's comments below it.

By the end of this step, the URL `http://127.0.0.1:5000/1` will be a page that displays the first post (because it has the ID `1`) and its comments. The URL `http://127.0.0.1:5000/ID` will display the post with the associated `ID` number, if it exists.

Leave the development server running and open a new terminal window.

Open `app.py` for modification:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Add the following route at the end of the file:

```python
[label flask_app/app.py]
# ...

@app.route('/<int:post_id>/')
def post(post_id):
    post = Post.query.get_or_404(post_id)
    return render_template('post.html', post=post)
```

Save and close the file.

Here, you use the route `'/<int:post_id>/'`, with `int:` being a [converter](https://flask.palletsprojects.com/en/2.0.x/quickstart/#variable-rules) that converts the default string in the URL into an integer. `post_id` is the URL variable that will determine the post you'll display on the page.

The ID is passed from the URL to the `post()` view function through the `post_id` parameter. Inside the function, you query the post table and retrieve a post by its ID using the `get_or_404()` method. This will save the post data in the `post` variable if it exists, and respond with a `404 Not Found` HTTP error if no post with the given ID exists in the database.

You render a template called `post.html` and pass it the post you retrieved.

Open this new `post.html` template file:

```custom_prefix((env)sammy@localhost:$)
nano templates/post.html
```

Type the following code in it. This will be similar to the `index.html` template, except that it will only display a single post:

```html
[label flask_app/templates/post.html]
{% extends 'base.html' %}

{% block content %}
    <span class="title"><h1>{% block title %} {{ post.title }}  {% endblock %}</h1></span>
    <div class="content">
            <div class="post">
                <p><b>#{{ post.id }}</b></p>
                <b>
                    <p class="title">{{ post.title }}</p>
                </b>
                <div class="content">
                    <p>{{ post.content }}</p>
                </div>
                <hr>
                <h3>Comments</h3>
                {% for comment in post.comments %}
                    <div class="comment">
                        <p>#{{ comment.id }}</p>
                        <p>{{ comment.content }}</p>
                    </div>
                {% endfor %}
            </div>
    </div>
{% endblock %}
```

Save and close the file.

Here, you extend the base template, set the post title as a page title, display the post ID, post title, and the post content. Then, you go through the post comments available via `post.comments`. You display the comment ID, and the contents of the comment.


Use your browser to navigate to the URL for the second post:

```
http://127.0.0.1:5000/2/
```

You'll see a page similar to the following:

![Single Post Page](https://assets.digitalocean.com/articles/68194/Rc0s0NM.png)

Next, edit `index.html` to make the title of the post link to the individual post:

```custom_prefix((env)sammy@localhost:$)
nano templates/index.html
```

Edit the value of the `href` attribute of the post title's link inside the `for` loop:

```html
[label flask_app/templates/index.html]

...

{% for post in posts %}
    <div class="post">
        <p><b>#{{ post.id }}</b></p>
        <b>
            <p class="title">
                <a href="{{ url_for('post', post_id=post.id)}}">
                {{ post.title }}
                </a>
            </p>
        </b>
        <div class="content">
            <p>{{ post.content }}</p>
        </div>
        <hr>
    </div>
{% endfor %}
```

Save and close the file.

Navigate to your index page or refresh it:

```
http://127.0.0.1:5000/
```

Click on each of the post titles on the index page. You'll now see that each post links to the proper post page.

You've now created a page for displaying individual posts. Next, you'll add a web form to the post page to allow users to add new comments.

## Step 5 — Adding New Comments
In this step, you'll edit the `/<int:post_id>/` route and its `post()` view function, which handles displaying an individual post. You'll add a web form below each post to allow users to add comments to that post, then you'll handle the comment submission and add it to the database.

First, open the `post.html` template file to add a web form consisting of a text area for the comment's content, and an **Add Comment** submit button.

```custom_prefix((env)sammy@localhost:$)
nano templates/post.html
```

Edit the file by adding a form below the `Comments` H3 heading, and directly above the `for` loop:

```html
[label flask_app/templates/post.html]

<hr>
<h3>Comments</h3>
<form method="post">
    <p>
        <textarea name="content"
                    placeholder="Comment"
                    cols="60"
                    rows="5"></textarea>
    </p>

    <p>
        <button type="submit">Add comment</button>
    </p>
</form>
{% for comment in post.comments %}
```

Save and close the file.

Here, you add a `<form>` tag with the attribute `method` set to `post` to indicate that the form will submit a POST request.

You have a text area for the comment's content, and a submit button.

With the development server running, use your browser to navigate to a post:

```
http://127.0.0.1:5000/2/
```

You'll see a page similar to the following:

![Single Post Page with Comment Form](https://assets.digitalocean.com/articles/68194/UJ9b7ki.png)

This form sends a POST request to the `post()` view function, but because there is no code to handle the form submission, the form currently does not work.

Next, you will add code to the `post()` view function to handle the form submission and add the new comment to the database. Open `app.py` to handle the POST request the user submits:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Edit the `/<int:post_id>/` route and its `post()` view function to look as follows:

```python
[label flask_app/app.py]

@app.route('/<int:post_id>/', methods=('GET', 'POST'))
def post(post_id):
    post = Post.query.get_or_404(post_id)
    if request.method == 'POST':
        comment = Comment(content=request.form['content'], post=post)
        db.session.add(comment)
        db.session.commit()
        return redirect(url_for('post', post_id=post.id))

    return render_template('post.html', post=post)
```
Save and close the file.

You allow both GET and POST requests using the `methods` parameter. GET requests are used to retrieve data from the server. POST requests are used to post data to a specific route. By default, only GET requests are allowed.

Inside the `if request.method == 'POST'` condition, you handle the POST request the user will submit via the form. You create a comment object using the `Comment` model, passing it the content of the submitted comment which you extract from the `request.form` object. You specify the post the comment belongs to using the `post` parameter, passing it the `post` object you retrieved using the post ID, with the `get_or_404()` method.

You add the comment object you constructed to the database session, commit the transaction, and redirect to the post page.

Now refresh the post page on your browser, write a comment, and submit it. You'll see your new comment below the post.

You now have a web form that allows users to add comments to a post. For more on web forms, see [How To Use Web Forms in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-web-forms-in-a-flask-application). For a more advanced and more secure method of managing web forms, see [How To Use and Validate Web Forms with Flask-WTF](https://www.digitalocean.com/community/tutorials/how-to-use-and-validate-web-forms-with-flask-wtf). Next, you'll add a page that displays all the comments in the database and the posts they were posted on.

## Step 6 — Displaying All Comments
In this step, you'll add a **Comments** page where you will display all the comments in the database, ordering them by displaying the newest comments first. Each comment will have the title and link of the post the comment was posted on.

Open `app.py`:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Add the following route to the end of the file. This fetches all the comments in the database, ordered by the latest first. It then passes them to a template file called `comments.html`, which you'll create later:

```python
[label flask_app/app.py]
# ...

@app.route('/comments/')
def comments():
    comments = Comment.query.order_by(Comment.id.desc()).all()
    return render_template('comments.html', comments=comments)
```
Save and close the file.

You use the `order_by()` method on the `query` attribute to fetch all the comments in a specific order. In this case you use the `desc()` method on the `Comment.id` column to fetch comments in descending order, with the latest comments being first. Then you use the `all()` method to get the result and save it to a variable called `comments`.

You render a template called `comments.html`, passing it the `comments` object which contains all comments ordered by the latest first.

Open this new `comments.html` template file:

```custom_prefix((env)sammy@localhost:$)
nano templates/comments.html
```

Type the following code inside it. This will display the comments and link to the post they belong to:

```html
[label flask_app/templates/comments.html]
{% extends 'base.html' %}

{% block content %}
    <span class="title"><h1>{% block title %} Latest Comments {% endblock %}</h1></span>
    <div class="content">
                {% for comment in comments %}
                    <div class="comment">
                        <i>
                            (#{{ comment.id }})
                            <p>{{ comment.content }}</p>
                        </i>
                        <p class="title">
                        On <a href="{{ url_for('post',
                                                post_id=comment.post.id) }}">
                                {{ comment.post.title }}
                              </a>
                        </p>
                    </div>
                {% endfor %}
            </div>
    </div>
{% endblock %}
```

Save and close the file.

Here, you extend the base template, set a title, and go through the comments using a `for` loop. You display the comment's ID, its content, and a link to the post it belongs to. You access the post data via `comment.post`.

Use your browser to navigate to the comments page:

```
http://127.0.0.1:5000/comments/
```

You’ll see a page similar to the following:

![Comments Page](https://assets.digitalocean.com/articles/68194/JUIOGKO.png)

Now edit the `base.html` template to make the **Comments** navbar link point to this Comments page:

```custom_prefix((env)sammy@localhost:$)
nano templates/base.html
```

Edit the navigation bar to look as follows:

```html
[label flask_app/templates/base.html]
    <nav>
        <a href="{{ url_for('index') }}">FlaskApp</a>
        <a href="{{ url_for('comments') }}">Comments</a>
        <a href="#">About</a>
    </nav>
```
Save and close the file.

Refresh your comments page, and you'll see that the **Comments** navbar link works.

You now have a page that displays all the comments in the database. Next, you'll add a button below each comment on the post page to allow users to delete it.

## Step 7 — Deleting Comments

In this step, you'll add a **Delete Comment** button below each comment to allow users to delete unwanted comments.

First, you'll add a new `/comments/ID/delete` route that accepts POST requests. The view function will receive the ID of the comment you want to delete, fetch it from the database, delete it, and the redirect to post page the deleted comment was on.

Open `app.py`:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Add the following route to the end of the file.

```python
[label flask_app/app.py]
# ...

@app.post('/comments/<int:comment_id>/delete')
def delete_comment(comment_id):
    comment = Comment.query.get_or_404(comment_id)
    post_id = comment.post.id
    db.session.delete(comment)
    db.session.commit()
    return redirect(url_for('post', post_id=post_id))
```
Save and close the file.

Here, instead of using the usual `app.route` decorator, you use the [`app.post`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.Flask.post) decorator introduced in [Flask version 2.0.0](https://flask.palletsprojects.com/en/2.0.x/changes/#version-2-0-0), which added shortcuts for common HTTP methods. For example, `@app.post("/login")` is a shortcut for `@app.route("/login", methods=["POST"])`. This means that this view function only accepts POST requests, and navigating to the `/comments/ID/delete` route on your browser will return a `405 Method Not Allowed` error, because web browsers default to GET requests. To delete a comment, the user clicks on a button that sends a POST request to this route.

This `delete_comment()` view function receives the ID of the comment to be deleted via the `comment_id` URL variable. You use the `get_or_404()` method to get a comment and save it in a `comment` variable, or respond with a `404 Not Found` in case the comment doesn't exist. You save the post ID of the post the comment belongs to in a `post_id` variable, which you'll use to redirect to the post after deleting the comment.

You use the `delete()` method on the database session in the line `db.session.delete(comment)`, passing it the comment object. This sets up the session to delete the comment whenever the transaction is committed. Because you don't need to perform any other modifications, you directly commit the transaction using `db.session.commit()`. Lastly, you redirect the user to the post the now-deleted comment was posted on.

Next, edit the `post.html` template to add a **Delete Comment** button below each comment:

```custom_prefix((env)sammy@localhost:$)
nano templates/post.html
```

Edit the `for` loop by adding a new `<form>` tag directly below the comment content:

```html
[label flask_app/templates/post.html]
    {% for comment in post.comments %}
        <div class="comment">
            <p>#{{ comment.id }}</p>
            <p>{{ comment.content }}</p>
            <form method="POST"
                action="{{ url_for('delete_comment',
                                    comment_id=comment.id) }}">
                <input type="submit" value="Delete Comment"
                    onclick="return confirm('Are you sure you want to delete this entry?')">
            </form>
        </div>
    {% endfor %}
```

Save and close the file.

Here, you have a web form that submits a POST request to the `delete_comment()` view function. You pass `comment.id` as an argument for the `comment_id` parameter to specify the comment that will be deleted. You use the [`confirm()` method](https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm) function available in web browsers to display a confirmation message before submitting the request.

Now navigate to a post page on your browser:

```
http://127.0.0.1:5000/2/
```

You'll see a **Delete Comment** button below each comment. Click on it, and confirm the deletion. You'll see that the comment has been deleted.

You now have a way of deleting comments from the database.

## Conclusion

You built a small blogging system that demonstrates how to manage one-to-many relationships using the Flask-SQLAlchemy extension. You learned how to connect a parent table with a child table, associate a child object with its parent and add it to the database, and how to access child data from a parent entry and vise versa.

If you would like to read more about Flask, check out the other tutorials in the [How To Build Web Applications with Flask](https://www.digitalocean.com/community/tutorial_series/how-to-create-web-sites-with-flask) series.




## How To Use Many-to-Many Database Relationships with Flask-SQLAlchemy

*The author selected the [Free and Open Source Fund](https://www.brightfunds.org/funds/foss-nonprofits) to receive a donation as part of the [Write for DOnations](https://do.co/w4do-cta) program.*

### Introduction

[Flask](https://palletsprojects.com/p/flask/) is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. [SQLAlchemy](https://www.sqlalchemy.org/) is an SQL toolkit that provides efficient and high-performing database access for relational databases. It provides ways to interact with several database engines such as SQLite, MySQL, and PostgreSQL. It gives you access to the database's SQL functionalities. It also gives you an Object Relational Mapper (ORM), which allows you to make queries and handle data using Python objects and methods. [Flask-SQLAlchemy](https://flask-sqlalchemy.palletsprojects.com/) is a Flask extension that makes using SQLAlchemy with Flask easier, providing you tools and methods to interact with your database in your Flask applications through SQLAlchemy.

A _many-to-many database relationship_ is a relationship between two database tables where a record in each table can reference several records in the other table. For example, in a blog, a table for posts can have a many-to-many relationship with a table for storing authors. Each post can have many authors, and each author can write many posts. Therefore, there is a many-to-many relationship between posts and authors. For another example, in a social media application, each post may have many hashtags, and each hashtag may have many posts.

In this tutorial, you’ll modify an application built using Flask and Flask-SQLAlchemy by adding a many-to-many relationship to it. You'll have a relationship between posts and tags, where each blog post can have several tags, and each tag can have multiple posts tagged with it.

Although you can follow this tutorial independently, it is also a continuation of the [How to Use One-to-Many Database Relationships with Flask-SQLAlchemy](https://www.digitalocean.com/community/tutorials/how-to-use-one-to-many-database-relationships-with-flask-sqlalchemy) tutorial, in which you build a multi-table database with a one-to-many relationship between posts and comments in a blogging application.

By the end of the tutorial, your application will have a new feature for adding tags to posts. Posts can be tagged with multiple tags, and each tag page will display all the posts tagged with it.

## Prerequisites

* A local Python 3 programming environment. Follow the tutorial for your distribution in [How To Install and Set Up a Local Programming Environment for Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-python-3) series. In this tutorial, we’ll call our project directory `flask_app`.

* An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out [How To Create Your First Web Application Using Flask and Python](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3) and [How To Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).

* An understanding of basic HTML concepts. You can review our [How To Build a Website with HTML](https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html) tutorial series for background knowledge.

* (Optional) In Step 1, you’ll clone the blogging application you’ll be working on in this tutorial. However, you can optionally work through the tutorial [How to Use One-to-Many Database Relationships with Flask-SQLAlchemy](https://www.digitalocean.com/community/tutorials/how-to-use-one-to-many-database-relationships-with-flask-sqlalchemy). You can access the final code [from this page](https://github.com/do-community/flask-slqa-bloggy).


## Step 1 — Setting Up the Web Application
In this step, you'll set up the blogging application to be ready for modification. You will also review the Flask-SQLAlchemy database models and the Flask routes to understand the structure of the application. If you followed the tutorial in the prerequisites section and still have the code and the virtual environment on your local machine, you can skip this step.

To demonstrate adding a many-to-many relationship to a Flask web application with Flask-SQLAlchemy, you will use the previous tutorial’s application code, which is a blogging system with the ability to add and display posts, comment on posts, and read and delete existing comments.

Clone the repository and rename it from `flask-slqa-bloggy` to `flask_app` with the following command:

```custom_prefix(sammy@localhost:$)
git clone https://github.com/do-community/flask-slqa-bloggy flask_app
```

Navigate to `flask_app`:

```custom_prefix(sammy@localhost:$)
cd flask_app
```

Then create a new virtual environment:

```custom_prefix(sammy@localhost:$)
python -m venv env
```

Activate the environment:

```custom_prefix(sammy@localhost:$)
source env/bin/activate
```

Install Flask and Flask-SQLAlchemy:

```custom_prefix((env)sammy@localhost:$)
pip install Flask Flask-SQLAlchemy
```

Next, set the following environment variables:

```custom_prefix((env)sammy@localhost:$)
export FLASK_APP=app
export FLASK_ENV=development
```

`FLASK_APP` indicates the application you are currently developing, which is `app.py` in this case. `FLASK_ENV` specifies the mode. You'll set it to `development` for development mode; this will allow you to debug the application. Remember not to use this mode in a production environment.

Next, open the Flask shell to create the database tables:

```custom_prefix((env)sammy@localhost:$)
flask shell
```

Then import the `db` Flask-SQLAlchemy database object, the `Post` model, and the `Comment` model, and create the database tables using the `db.create_all()` function:

```custom_prefix(>>>)
from app import db, Post, Comment
db.create_all()
exit()
```

Then populate the database using the `init_db.py` program:

```custom_prefix((env)sammy@localhost:$)
python init_db.py
```

This adds three posts and four comments to the database.

Run the development server:

```custom_prefix((env)sammy@localhost:$)
flask run
```

If you go to your browser, you’ll have the application running at the following URL:

```
http://127.0.0.1:5000/
```

You'll see a page similar to the following:

![Flask App Index](https://assets.digitalocean.com/articles/68342/Rl4qsR.png)

If you get an error, make sure you've followed the steps above properly.

To stop the development server, use `CTRL + C`.

Next, you will go through the Flask-SQLAlchemy database models to understand the current relationships between tables. If you are familiar with the contents of the `app.py` file, you can skip to the next step.

Open the `app.py` file:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

The file contents are as follows:

```python
[label flask_app/app.py]
import os
from flask import Flask, render_template, request, redirect, url_for
from flask_sqlalchemy import SQLAlchemy

basedir = os.path.abspath(os.path.dirname(__file__))

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] =\
           'sqlite:///' + os.path.join(basedir, 'database.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False


db = SQLAlchemy(app)


class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100))
    content = db.Column(db.Text)
    comments = db.relationship('Comment', backref='post')

    def __repr__(self):
        return f'<Post "{self.title}">'


class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text)
    post_id = db.Column(db.Integer, db.ForeignKey('post.id'))

    def __repr__(self):
        return f'<Comment "{self.content[:20]}...">'


@app.route('/')
def index():
    posts = Post.query.all()
    return render_template('index.html', posts=posts)


@app.route('/<int:post_id>/', methods=('GET', 'POST'))
def post(post_id):
    post = Post.query.get_or_404(post_id)
    if request.method == 'POST':
        comment = Comment(content=request.form['content'], post=post)
        db.session.add(comment)
        db.session.commit()
        return redirect(url_for('post', post_id=post.id))

    return render_template('post.html', post=post)


@app.route('/comments/')
def comments():
    comments = Comment.query.order_by(Comment.id.desc()).all()
    return render_template('comments.html', comments=comments)


@app.post('/comments/<int:comment_id>/delete')
def delete_comment(comment_id):
    comment = Comment.query.get_or_404(comment_id)
    post_id = comment.post.id
    db.session.delete(comment)
    db.session.commit()
    return redirect(url_for('post', post_id=post_id))
```

Here, you have two database models representing two tables:

* `Post`: which has an ID column, a title, content, and a One-to-Many relationship with the comments table.

* `Comment`: which has an ID column, a column for content, and a `post_id` column to reference the post the comment belongs to.

Below the models you have the following routes:

* `/`: The index page, which displays all the posts in the database.
* `/<int:post_id>/`: The individual post page. For example, the link `http://127.0.0.1:5000/2/` displays the details of the second post in the database and its comments.
* `/comments/`: A page that displays all the comments in the database and links to the post each comment was posted on.
* `/comments/<int:comment_id>/delete`: A route that deletes a comment through a **Delete Comment** button.

Close the `app.py` file.

In the next step, you will use a many-to-many relationship to create a link between two tables.

## Step 2 — Setting up Database Models for a Many-to-Many Relationship

In this step, you'll add a database model that will represent the tags table. You will link it with the existing posts table using an _association table_, which is a table that connects your two tables in a many-to-many relationship. A many-to-many relationship links two tables where each item in a table has many related items in the other table. In the association table, each post will reference its tags and each tag references the posts tagged with it. You'll also insert a few posts and tags into your database, print posts with their tags, and print tags and their related posts.

Let’s say you have a simple table for blog posts as follows:


```
Posts
+----+-----------------------------------+
| id | content                           |
+----+-----------------------------------+
| 1  | A post on life and death          |
| 2  | A post on joy                     |
+----+-----------------------------------+
```

And a table for tags like so:

```
Tags
+----+-------+
| id | name  |
+----+-------+
| 1  | life  |
| 2  | death |
| 3  | joy   |
+----+-------+
```
Let’s say you want to tag `A post on life and death` with the `life` and `death` tags. You could do this by adding a new row in the posts table like so:

```
Posts
+----+-----------------------------------+------+
| id | content                           | tags |
+----+-----------------------------------+------+
| 1  | A post on life and death          | 1, 2 |
| 2  | A post on joy                     |      |
+----+------------------------------------------+
```

This approach doesn't work, because each column should only have one value. If you have multiple values, basic operations such as adding and updating data become cumbersome and slow. Instead, there should be a third table that references primary keys of related tables—this table is often called an _association table_ or a _join table_, and it stores IDs of each item from each table.

Here is an example of an association table that links between posts and tags:

```
post_tag
+----+---------+-------------+
| id | post_id | tag_id      |
+----+---------+-------------+
| 1  | 1       | 1           |
| 2  | 1       | 2           |
+----+---------+-------------+
```

In the first row, the post with the ID `1` (that is, `A post on life and death`) relates to the tag with the ID `1` (`life`). In the second row, the same post also relates to the tag with the ID `2` (`death`). This means that the post is tagged with both the `life` and `death` tags. Similarly, you can tag each post with multiple tags.

Now, you will modify the `app.py` file to add a new database model that represents the table you'll be using for storing tags. You'll also add an association table called `post_tag` that links posts with tags.

First, open `app.py` to establish a relationship between posts and tags:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Add a `post_tag` table and a `Tag` model below the `db` object and above the `Post` model, then add a `tags` relationship pseudo-column to the `Post` model so you can access a post's tags via `post.tags` and access a tag's posts via `tag.posts`:

```python
[label flask_app/app.py]

# ...

db = SQLAlchemy(app)


post_tag = db.Table('post_tag',
                    db.Column('post_id', db.Integer, db.ForeignKey('post.id')),
                    db.Column('tag_id', db.Integer, db.ForeignKey('tag.id'))
                    )


class Tag(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50))

    def __repr__(self):
        return f'<Tag "{self.name}">' 



class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100))
    content = db.Column(db.Text)
    comments = db.relationship('Comment', backref='post')
    tags = db.relationship('Tag', secondary=post_tag, backref='posts')

    def __repr__(self):
        return f'<Post "{self.title}">'
```

Save and close the file.

Here you use the `db.Table()` function to create a table with two columns. For association tables, the best practice is to use a table instead of a database model.

The `post_tag` table has two columns representing two _foreign keys_, which are keys that are used to reference primary key columns in another table:

* `post_id`: An integer _foreign key_ that represents the post ID and references the ID column in the `post` table.
* `tag_id`: An integer _foreign key_ that represents the tag ID and references the ID column in the `tag` table.

These keys establish the relationships between tables.

Below the `post_tag` table, you create a `Tag` model, which represents the table in which you'll store your tags. This tags table has two columns:

* `id`: The tag's ID.
* `name`: The tag's name.

You use the tag's name in the special `__repr__()` method to give each tag object a clear string representation for debugging purposes.

You add a `tags` class variable to the `Post` model. You use the `db.relationship()` method, passing it the name of the tags model (`Tag` in this case).

You pass the `post_tag` association table to the `secondary` parameter to establish a many-to-many relationship between posts and tags.

You use the `backref` parameter to add a back reference that behaves like a column to the `Tag` model. This way, you can access the tag's posts via `tag.posts` and the tags of a post via `post.tags`. You’ll see an example demonstrating this later.

Next, edit the `init_db.py` Python program to modify the database by adding the `post_tag` association table and the tags table that will be based on the `Tag` model:

```custom_prefix((env)sammy@localhost:$)
nano init_db.py
```

Edit the file to look as follows:

```python
[label flask_app/init_db.py]
from app import db, Post, Comment, Tag

db.drop_all()
db.create_all()

post1 = Post(title='Post The First', content='Content for the first post')
post2 = Post(title='Post The Second', content='Content for the Second post')
post3 = Post(title='Post The Third', content='Content for the third post')

comment1 = Comment(content='Comment for the first post', post=post1)
comment2 = Comment(content='Comment for the second post', post=post2)
comment3 = Comment(content='Another comment for the second post', post_id=2)
comment4 = Comment(content='Another comment for the first post', post_id=1)

tag1 = Tag(name='animals')
tag2 = Tag(name='tech')
tag3 = Tag(name='cooking')
tag4 = Tag(name='writing')

post1.tags.append(tag1)  # Tag the first post with 'animals'
post1.tags.append(tag4)  # Tag the first post with 'writing'
post3.tags.append(tag3)  # Tag the third post with 'cooking'
post3.tags.append(tag2)  # Tag the third post with 'tech'
post3.tags.append(tag4)  # Tag the third post with 'writing'


db.session.add_all([post1, post2, post3])
db.session.add_all([comment1, comment2, comment3, comment4])
db.session.add_all([tag1, tag2, tag3, tag4])

db.session.commit()
```

Save and close the file.

Here, you import the `Tag` model. You delete everything in the database using the `db.drop_all()` function to add the tags and `post_tag` tables safely and to avoid any of the common issues related to adding new tables to a database. Then you create all the tables anew using the `db.create_all()` function.

After the code from the previous tutorial declaring the posts and comments, you use the `Tag` model to create four tags.

You then add tags to posts using the `tags` attribute that was added via the `tags = db.relationship('Tag', secondary=post_tag, backref='posts')` line in the `app.py` file. You assign tags to posts using an `append()` method similar to Python lists.

Next, you add the tags you created to the database session using the `db.session.add_all()` function.

<$>[note]
**Note:**

The `db.create_all()` function does not recreate or update a table if it already exists. For example, if you modify your model by adding a new column and run the `db.create_all()` function, the change you make to the model will not be applied to the table if the table already exists in the database. The solution is to delete all existing database tables with the `db.drop_all()` function and then recreate them with the `db.create_all()` function, as demonstrated in the `init_db.py` file.

This process will apply the modifications you make to your models but will also delete all the existing data in the database. To update the database and preserve existing data, you'll need to use [_schema migration_](https://en.wikipedia.org/wiki/Schema_migration), which allows you to modify your tables and preserve data. You can use the [`Flask-Migrate`](https://flask-migrate.readthedocs.io/en/latest/index.html) extension to perform SQLAlchemy schema migrations through the Flask command-line interface.
<$>

Run the `init_db.py` program to apply changes to the database:

```custom_prefix((env)sammy@localhost:$)
python init_db.py
```

The program should successfully execute without any output. If you see an error, make sure you made changes properly to the `init_db.py` file.

To take a look at the posts and tags that are currently in the database, open the Flask shell:

```custom_prefix((env)sammy@localhost:$)
flask shell
```

Execute the following Python code that loops through posts and tags:

```python
from app import Post

posts = Post.query.all()

for post in posts:
    print(post.title)
    print(post.tags)
    print('---')
```

Here, you import the `Post` model from `app.py`. You query the posts table and fetch all the posts in the database. You loop through posts, and you print the post title and the list of tags associated with each post.

You'll get an output similar to the following:

```
[secondary_label Output]

Post The First
[<Tag "animals">, <Tag "writing">]
---
Post The Third
[<Tag "cooking">, <Tag "tech">, <Tag "writing">]
---
Post The Second
[]
---
```

You can access tag names using `tag.name` as demonstrated in the following example, which you can run using the Flask shell:

```python
from app import Post

posts = Post.query.all()

for post in posts:
    print('TITLE: ', post.title)
    print('-')
    print('TAGS:')
    for tag in post.tags:
        print('> ', tag.name)
    print('-'*30)
```

Here, along with printing the post's title, you also loop through the tags of each post and print the tag name.

You'll get output similar to the following:

```
[secondary_label Output]
TITLE:  Post The First
-
TAGS:
>  animals
>  writing
------------------------------
TITLE:  Post The Third
-
TAGS:
>  cooking
>  tech
>  writing
------------------------------
TITLE:  Post The Second
-
TAGS:
------------------------------
```

As you can see, the tags you added to posts in the `init_db.py` program are properly linked with the posts they were tagged with.

To see a demonstration of how to access posts tagged with a specific tag via `tag.posts`, run the following code in the Flask shell:

```python
from app import Tag

writing_tag = Tag.query.filter_by(name='writing').first()

for post in writing_tag.posts:
    print(post.title)
    print('-'*6)
    print(post.content)
    print('-')
    print([tag.name for tag in post.tags])
    print('-'*20)
```

You import the `Tag` model. Then you use the `filter_by()` method on the `query` attribute passing it a `name` parameter to get the `writing` tag by its name, and you get the first result using the `first()` method. You store the tag object in a variable called `writing_tag`. For more on the `filter_by` method, see [Step 4 of the How To Use Flask-SQLAlchemy to Interact with Databases in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application#step-4-displaying-a-single-record) tutorial.

You loop through the posts tagged with the `writing` tag, which you access via `writing_tag.posts`. You print the post title, content, and a list of tag names you construct using a [list comprehension](https://www.digitalocean.com/community/tutorials/understanding-list-comprehensions-in-python-3) based on the tags of the post, which you access via `post.tags`.

You'll get an output similar to the following:

```
[secondary_label Output]
Post The Third
------
Content for the third post
-
['cooking', 'tech', 'writing']
--------------------
Post The First
------
Content for the first post
-
['animals', 'writing']
--------------------
```

Here you see the two posts that were tagged with the `writing` tag, and tag names are displayed in a Python list.

You can now access posts and their tags and access posts of a specific tag.

You've added a database model that represents the tag table. You linked between posts and tags using an association table, and you inserted a few tags into the database and tagged posts with them. You accessed posts and their tags and the posts of an individual tag. Next, you'll use the Flask shell to add new posts and new tags and link between tags and posts, and you'll learn how to remove tags from a post.

## Step 3 — Managing Data in a Many-to-Many Relationship
In this step, you'll use the Flask shell to add new posts to the database, add tags, and link between posts and tags. You'll access posts with their tags, and you'll see how to disassociate an item from another in Many-to-Many relationships.

First, with your programming environment activated, open the Flask shell if you haven't already:

```custom_prefix((env)sammy@localhost:$)
flask shell
```

Next, add a few posts and tags:

```
from app import db, Post, Tag

life_death_post = Post(title='A post on life and death', content='life and death')
joy_post = Post(title='A post on joy', content='joy')

life_tag = Tag(name='life')
death_tag = Tag(name='death')
joy_tag = Tag(name='joy')

life_death_post.tags.append(life_tag)
life_death_post.tags.append(death_tag)
joy_post.tags.append(joy_tag)

db.session.add_all([life_death_post, joy_post, life_tag, death_tag, joy_tag])

db.session.commit()
```

This creates two posts and three tags. You tag posts with their related tags, and you use the `add_all()` method to add the newly created items to the database session. Then you commit the changes and apply them to the database using the `commit()` method.

Next, use the Flask shell to get all the posts and their tags as you've done in the previous step:

```
posts = Post.query.all()

for post in posts:
    print(post.title)
    print(post.tags)
    print('---')
```

You'll get an output similar to the following:

```
[secondary_label Output]

Post The First
[<Tag "animals">, <Tag "writing">]
---
Post The Third
[<Tag "cooking">, <Tag "tech">, <Tag "writing">]
---
Post The Second
[]
---
A post on life and death
[<Tag "life">, <Tag "death">]
---
A post on joy
[<Tag "joy">]
---
```

You can see that posts were added along with their tags.

To demonstrate how to break a relationship between two items in a many to many database relationship, let's say that the `Post The Third` post is no longer about cooking, so you'll have to remove the `cooking` tag from it.

First, get the post and the tag you want to remove:

```custom_prefix(>>>)
from app import db, Post, Tag
post = Post.query.filter_by(title='Post The Third').first()
tag = Tag.query.filter_by(name='cooking').first()
print(post.title)
print(post.tags)
print(tag.posts)
```

Here you fetch the post titled `Post The Third` using the `filter_by()` method. You get the `cooking` tag. You print the title of the post, its tags, and the posts tagged with the `cooking` tag.

The `filter_by()` method returns a query object, and you can use the `all()` method to get a list of all the results. But because we expect only one result in this case, you use the `first()` method to get the first (and only) result. For more on the `first()` and `all()` methods, check out [Step 4 of How to Use Flask-SQLAlchemy to Interact with Databases in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application#step-4-displaying-a-single-record).

You'll get the following output:

```
[secondary_label Output]

Post The Third


[<Tag "cooking">, <Tag "tech">, <Tag "writing">]


[<Post "Post The Third">]
```

Here you see the post title, the post tags, and a list of the posts tagged with the `cooking` tag.

To remove the `cooking` tag from the post, use the `remove()` method like so:

```custom_prefix(>>>)
post.tags.remove(tag)
db.session.commit()
print(post.tags)
print(tag.posts)
```

Here you use the `remove()` method to disassociate the `cooking` tag from the post. Then you use the `db.session.commit()` method to apply the changes to the database.

You'll get an output that confirms that the tag was removed from the post:

```
[secondary_label Output]
[<Tag "tech">, <Tag "writing">]

[]
```

As you can see, the `cooking` tag is no longer in the `post.tags` list, and the post has been removed from the `tag.posts` list.

Exit the flask shell:

```custom_prefix(>>>)
exit()
```

You've added new posts and tags. You tagged posts and you removed tags from posts. Next, you'll display the tags of each post in your Flask web blog's index page.

## Step 4 — Displaying Tags Under Each Post
In this step, you'll edit the index template to display tags under each post.

First, take a look at the current homepage page of the Flask web blog.

With your programming environment activated, tell Flask about the application (`app.py` in this case) using the `FLASK_APP` environment variable. Then set the `FLASK_ENV` environment variable to `development` to run the application in development mode:

```custom_prefix((env)sammy@localhost:$)
export FLASK_APP=app
export FLASK_ENV=development
```

Next, run the application:

```custom_prefix((env)sammy@localhost:$)
flask run
```

With the development server running, visit the following URL in your browser:

```
http://127.0.0.1:5000/
```

You'll see a page similar to the following:

![Index Page](https://assets.digitalocean.com/articles/68342/Rl4L1c.png)

Leave the development server running and open a new terminal window.

You'll need to display the tags of each post on two pages: under each post on the index page and under the post content on the post page. You'll use the same code to display tags. To avoid code repetition, you will use a [Jinja macro](https://jinja.palletsprojects.com/en/3.0.x/templates/#macros), which behaves like a Python function. A macro holds dynamic HTML code that can be displayed wherever you call the macro, and editing it applies changes wherever it has been called, which makes code reusable.

First, open a new file called `macros.html` in your `templates` directory:

```custom_prefix((env)sammy@localhost:$)
nano templates/macros.html
```

Add the following code to it:

```html
[label flask_app/templates/macros.html]
{% macro display_tags(post) %}
    <div class="tags">
        <p>
            <h4>Tags:</h4>
            {% for tag in post.tags %}
                <a href="#" style="text-decoration: none; color: #dd5b5b">
                    {{ tag.name }}
                </a>
                |
            {% endfor %}
        </p>
    </div>
{% endmacro %}
```

Save and close the file.

Here, you use the `macro` keyword to declare a macro called `display_tags()` with a parameter called `post`. You use a `<div>` tag, in which you display an `<h4>` heading. You use a `for` loop to go through the tags of the post object that will be passed as an argument to the macro when calling it, similar to how an argument is passed in a Python function call. You get tags via `post.tags`. You display the tag name inside an `<a>` tag. You will later edit the `href` attribute's value to link to a tag page you will create where all posts tagged with a particular tag are displayed. You specify the end of the macro using the `endmacro` keyword.

Next, to display tags under each post on the index page, open the `index.html` template file:

```custom_prefix((env)sammy@localhost:$)
nano templates/index.html
```

First, you'll need to import the `display_tags()` macro from the `macros.html` file. Add the following import at the top above the `{% extends 'base.html' %}` line:

```html
[label flask_app/templates/index.html]
{% from 'macros.html' import display_tags %}
{% extends 'base.html' %}
```

Next, edit the `for post in posts` loop, by calling the `display_tags()` macro as follows:

```html
[label flask_app/templates/index.html]
{% for post in posts %}
    <div class="post">
        <p><b>#{{ post.id }}</b></p>
        <b>
            <p class="title">
                <a href="{{ url_for('post', post_id=post.id)}}">
                    {{ post.title }}
                </a>
            </p>
        </b>
        <div class="content">
            <p>{{ post.content }}</p>
        </div>

        {{ display_tags(post) }}

        <hr>
    </div>
{% endfor %}
```

Save and close the file.

You call the `display_tags()` macro, passing it the `post` object. This will display tag names under each post.

Refresh the index page in your browser and you'll see tags under each post, as shown in the following image:

![Index Page with Tags](https://assets.digitalocean.com/articles/68342/Rl4XvE.png)

Next, you'll add tags under the post content on the post's page. Open the `post.html` template file:

```custom_prefix((env)sammy@localhost:$)
nano templates/post.html
```

First, import the `display_tags` macro at the top:

```html
[label flask_app/templates/post.html]
{% from 'macros.html' import display_tags %}
{% extends 'base.html' %}
```

Then call the `display_tags()` macro, passing it the `post` object below the post content and above the `<hr>` tag:

```
[label flask_app/templates/post.html]
<div class="post">
    <p><b>#{{ post.id }}</b></p>
    <b>
        <p class="title">{{ post.title }}</p>
    </b>
    <div class="content">
        <p>{{ post.content }}</p>
    </div>

    {{ display_tags(post) }}

    <hr>
    <h3>Comments</h3>
```

Save and close the file.

Now, navigate to a post page:

```
http://127.0.0.1:5000/2
```

You'll see that tags are displayed in the same way as the tags displayed on the index page.

You've displayed the tags you added to posts under each post. Next, you'll add a new route to your Flask application that displays all the posts tagged with a specific tag. Then you'll make the tag links you've displayed in this step functional.

## Step 5 — Displaying Tags and Their Posts

In this step, you'll add a route and a template to your web application to display the tags you have in your database and their posts.

First, you'll add a route for displaying the posts of each tag. For example, the route `/tags/tag_name/` will show a page that displays all the posts tagged with a tag named `tag_name`.

Open `app.py` for editing:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Add the following route to the end of the file:

```
[label flask_app/app.py]

# ...

@app.route('/tags/<tag_name>/')
def tag(tag_name):
    tag = Tag.query.filter_by(name=tag_name).first_or_404()
    return render_template('tag.html', tag=tag)
```

Save and close the file.

Here you use a URL variable called `tag_name` that determines the tag and the posts tagged with it that will be displayed on the tag page. The tag name is passed to the `tag()` view function via the `tag_name` parameter, which you use on the `filter_by()` method to query the tag. You use the `first_or_404()` to get the tag object and store it in a variable called `tag`, or to respond with a `404 Not Found` error message in case no tag with the given name exists in the database.

Then you render a template file called `tag.html`, passing it the `tag` object.

Open the new `templates/tag.html` for editing:

```custom_prefix((env)sammy@localhost:$)
nano templates/tag.html
```

Add the following code to it:

```html
[label flask_app/templates/tag.html]
{% from 'macros.html' import display_tags %}
{% extends 'base.html' %}

{% block content %}
    <span class="title">
        <h1>{% block title %} Posts Tagged with "{{ tag.name }}" {% endblock %}</h1>
    </span>
    <div class="content">
        {% for post in tag.posts %}
        <div class="post">
            <p><b>#{{ post.id }}</b></p>
            <b>
                <p class="title">
                    <a href="{{ url_for('post', post_id=post.id)}}">
                        {{ post.title }}
                    </a>
                </p>
            </b>
            <div class="content">
                <p>{{ post.content }}</p>
            </div>

            {{ display_tags(post) }}

            <hr>
        </div>
        {% endfor %}
    </div>
{% endblock %}
```

Save and close the file.

You import the `display_tags()` macro from `macros.html`, and extend the base template.

In the content block, you set a heading as a title with the tag name included. You then loop through the posts tagged with the given tag, which you access via `tag.posts`. You display the post ID, the post title, and the post content. Then you call the `display_tags()` macro to display all post tags.

With your development server running, navigate to the following URL:

```
http://127.0.0.1:5000/tags/writing/
```

This is the page for the `writing` tag. As you can see, all the posts that were tagged with `writing` are displayed:

![Tag Page](https://assets.digitalocean.com/articles/68342/Rl420g.png)

Now edit the `display_tags()` macro to make the tag links functional. Open `macros.html`:

```custom_prefix((env)sammy@localhost:$)
nano templates/macros.html
```

Edit the `href` attribute's value as follows:

```python
[label flask_app/templates/macros.html]

{% macro display_tags(post) %}
    <div class="tags">
        <p>
            <h4>Tags:</h4>
            {% for tag in post.tags %}
            <a href="{{ url_for('tag', tag_name=tag.name) }}"
               style="text-decoration: none; color: #dd5b5b">
                    {{ tag.name }}
                </a>
                |
            {% endfor %}
        </p>
    </div>
{% endmacro %}
```

Save and close the file.

Refresh the pages where the `display_tags()` macro has been used, and you'll see that the tag links are now functional:

```
http://127.0.0.1:5000/
http://127.0.0.1:5000/2/
http://127.0.0.1:5000/tags/writing/
```

As you can see, using Jinja macros allows you to reuse code, and editing a macro applies changes across multiple templates.

You've added a page for individual tags where users can view all the posts that were tagged with a specific tag, and the tags under posts now link to this new page.

## Conclusion

The tags feature that you added to your blogging system demonstrates how to manage many-to-many relationships using the Flask-SQLAlchemy extension. You learned how to link between two related tables using an association table (also called a _join table_), associate an entry with another, add the entry to the database, and access and disassociate data from an entry.

If you would like to read more about Flask, check out the other tutorials in the [How To Build Web Applications with Flask](https://www.digitalocean.com/community/tutorial_series/how-to-create-web-sites-with-flask) series.




## How To Query Tables and Paginate Data in Flask-SQLAlchemy

*The author selected the [Free and Open Source Fund](https://www.brightfunds.org/funds/foss-nonprofits) to receive a donation as part of the [Write for DOnations](https://do.co/w4do-cta) program.*

### Introduction
[Flask](https://palletsprojects.com/p/flask/) is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. [SQLAlchemy](https://www.sqlalchemy.org/) is an SQL toolkit that provides efficient and high-performing database access for relational databases. It provides ways to interact with several database engines such as SQLite, MySQL, and PostgreSQL. It gives you access to the database's SQL functionalities. And it also gives you an Object Relational Mapper (ORM), which allows you to make queries and handle data using simple Python objects and methods. [Flask-SQLAlchemy](https://flask-sqlalchemy.palletsprojects.com/) is a Flask extension that makes using SQLAlchemy with Flask easier, providing you tools and methods to interact with your database in your Flask applications through SQLAlchemy.

In this tutorial, you'll use Flask and Flask-SQLAlchemy to create an employee management system with a database that has a table for employees. Each employee will have a unique ID, a first name, a last name, a unique email, an integer value for their age, a date for the day they joined the company, and a boolean value to determine whether an employee is currently active or out of office.

You'll use the Flask shell to query a table, and get table records based on a column value (for example, an email). You'll retrieve employees' records on certain conditions, such as getting only active employees or getting a list of out-of-office employees. You'll order the results by a column value, and count and limit query results. Finally, you'll use pagination to display a certain number of employees per page in a web application.

## Prerequisites

* A local Python 3 programming environment. Follow the tutorial for your distribution in [How To Install and Set Up a Local Programming Environment for Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-python-3) series. In this tutorial we’ll call our project directory `flask_app`.

* An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out [How to Create Your First Web Application Using Flask and Python](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3) and [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).

* An understanding of basic HTML concepts. You can review our [How To Build a Website with HTML](https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html) tutorial series for background knowledge.

* An understanding of basic Flask-SQLAlchemy concepts, such as setting up a database, creating database models, and inserting data into the database. See [How to Use Flask-SQLAlchemy to Interact with Databases in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application) for background knowledge.

## Step 1 — Setting up the Database and Model
In this step, you'll install the necessary packages, and set up your Flask application, the Flask-SQLAlchemy database, and the employee model that represents the `employee` table where you'll store your employee data. You'll insert a few employees into the `employee` table, and add a route and a page where all employees are displayed on your application's index page.

First, with your virtual environment activated, install Flask and Flask-SQLAlchemy:

```custom_prefix((env)sammy@localhost:$)
pip install Flask Flask-SQLAlchemy
```

Once the installation is complete, you will receive output with the following line at the end:

```
[secondary_label Output]

Successfully installed Flask-2.1.2 Flask-SQLAlchemy-2.5.1 Jinja2-3.1.2 MarkupSafe-2.1.1 SQLAlchemy-1.4.37 Werkzeug-2.1.2 click-8.1.3 greenlet-1.1.2 itsdangerous-2.1.2
```

With the required packages installed, open a new file called `app.py` in your `flask_app` directory. This file will have code for setting up the database and your Flask routes:


```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Add the following code to `app.py`. This code will set up an SQLite database and an employee database model representing the `employee` table you'll use to store your employee data:

```python
[label flask_app/app.py]
import os
from flask import Flask, render_template, request, url_for, redirect
from flask_sqlalchemy import SQLAlchemy


basedir = os.path.abspath(os.path.dirname(__file__))

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] =\
        'sqlite:///' + os.path.join(basedir, 'database.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)


class Employee(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    firstname = db.Column(db.String(100), nullable=False)
    lastname = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(100), unique=True, nullable=False)
    age = db.Column(db.Integer, nullable=False)
    hire_date = db.Column(db.Date, nullable=False)
    active = db.Column(db.Boolean, nullable=False)

    def __repr__(self):
        return f'<Employee {self.firstname} {self.lastname}>'
```

Save and close the file.

Here, you import the [`os` module](https://docs.python.org/3/library/os.html), which gives you access to miscellaneous operating system interfaces. You’ll use it to construct a file path for your `database.db` database file.

From the `flask` package, you import helpers you need for your application: the `Flask` class to create a Flask application instance, `render_template()` to render templates, the `request` object to handle requests, `url_for()` to construct URLs, and the `redirect()` function for redirecting users. For more information on routes and templates, see [How To Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).

You then import the `SQLAlchemy` class from the Flask-SQLAlchemy extension, which gives you access to all the functions and classes from SQLAlchemy, in addition to helpers and functionality that integrates Flask with SQLAlchemy. You'll use it to create a database object that connects to your Flask application.

To construct a path for your database file, you define a base directory as the current directory. You use the [`os.path.abspath()`](https://docs.python.org/3.8/library/os.path.html#os.path.abspath) function to get the absolute path of the current file's directory. The special `__file__` variable holds the pathname of the current `app.py` file. You store the absolute path of the base directory in a variable called `basedir`.

You then create a Flask application instance called `app`, which you use to configure two Flask-SQLAlchemy [configuration keys](https://flask-sqlalchemy.palletsprojects.com/en/2.x/config/):

* `SQLALCHEMY_DATABASE_URI`: The database URI to specify the database you want to establish a connection with. In this case, the URI follows the format `sqlite:///path/to/database.db`. You use the [`os.path.join()`](https://docs.python.org/3.8/library/os.path.html#os.path.join) function to intelligently join the base directory you constructed and stored in the `basedir` variable with the `database.db` file name. This will connect to a `database.db` database file in your `flask_app` directory. The file will be created once you initiate the database.

* `SQLALCHEMY_TRACK_MODIFICATIONS`: A configuration to enable or disable tracking modifications of objects. You set it to `False` to disable tracking, which uses less memory. For more, see [the configuration page](https://flask-sqlalchemy.palletsprojects.com/en/2.x/config/) in the Flask-SQLAlchemy documentation.

After configuring SQLAlchemy by setting a database URI and disabling tracking, you create a database object using the `SQLAlchemy` class, passing the application instance to connect your Flask application with SQLAlchemy. You store your database object in a variable called `db`, which you'll use to interact with your database.

After setting up the application instance and the database object, you inherit from the `db.Model` class to create a database model called `Employee`. This model represents the `employee` table, and it has the following columns:

* `id`: The employee ID, an integer primary key.
* `firstname`: The employee's first name, a string with a maximum length of 100 characters. `nullable=False` signifies that this column should not be empty.
* `lastname`: The employee's last name, a string with a maximum length of 100 characters. `nullable=False` signifies that this column should not be empty.
* `email`: The employee's email, a string with a maximum length of 100 characters. `unique=True` signifies that each email should be unique. `nullable=False` signifies that it's value should not be empty.
* `age`: The employee's age, an integer value.
* `hire_date`: The date at which the employee was hired. You set `db.Date` as the column type to declare it as a column that holds dates.
* `active`: A column which will hold a boolean value to indicate whether the employee is currently active or out of office.

The special [`__repr__` function](https://docs.python.org/3/reference/datamodel.html#object.__repr__) allows you to give each object a string representation to recognize it for debugging purposes. In this case, you use the employee's first and last name to represent each employee object.

Now that you've set the database connection and the employee model, you'll write a Python program to create your database and `employee` table and populate the table with some employee data.

Open a new file called `init_db.py` in your `flask_app` directory:

```custom_prefix((env)sammy@localhost:$)
nano init_db.py
```

Add the following code to delete existing database tables to start from a clean database, create the `employee` table, and insert nine employees into it:

```python
[label flask_app/init_db.py]
from datetime import date
from app import db, Employee

db.drop_all()
db.create_all()

e1 = Employee(firstname='John',
              lastname='Doe',
              email='jd@example.com',
              age=32,
              hire_date=date(2012, 3, 3),
              active=True
              )

e2 = Employee(firstname='Mary',
              lastname='Doe',
              email='md@example.com',
              age=38,
              hire_date=date(2016, 6, 7),
              active=True
              )

e3 = Employee(firstname='Jane',
              lastname='Tanaka',
              email='jt@example.com',
              age=32,
              hire_date=date(2015, 9, 12),
              active=False
              )

e4 = Employee(firstname='Alex',
              lastname='Brown',
              email='ab@example.com',
              age=29,
              hire_date=date(2019, 1, 3),
              active=True
              )

e5 = Employee(firstname='James',
              lastname='White',
              email='jw@example.com',
              age=24,
              hire_date=date(2021, 2, 4),
              active=True
              )

e6 = Employee(firstname='Harold',
              lastname='Ishida',
              email='hi@example.com',
              age=52,
              hire_date=date(2002, 3, 6),
              active=False
              )

e7 = Employee(firstname='Scarlett',
              lastname='Winter',
              email='sw@example.com',
              age=22,
              hire_date=date(2021, 4, 7),
              active=True
              )

e8 = Employee(firstname='Emily',
              lastname='Vill',
              email='ev@example.com',
              age=27,
              hire_date=date(2019, 6, 9),
              active=True
              )

e9 = Employee(firstname='Mary',
              lastname='Park',
              email='mp@example.com',
              age=30,
              hire_date=date(2021, 8, 11),
              active=True
              )

db.session.add_all([e1, e2, e3, e4, e5, e6, e7, e8, e9])

db.session.commit()
```

Here, you import the [`date()`](https://docs.python.org/3/library/datetime.html#datetime.date) class from the [`datetime`](https://docs.python.org/3/library/datetime.html) module to use it to set employee hire dates.

You import the database object and the `Employee` model. You call the `db.drop_all()` function to delete all existing tables to avoid the chance of an already populated `employee` table existing in the database, which might cause issues. This deletes all database data whenever you execute the `init_db.py` program. For more information on creating, modifying, and deleting database tables, see [How to Use Flask-SQLAlchemy to Interact with Databases in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application).

You then create several instances of the `Employee` model, which represent the employees you'll query in this tutorial, and add them to the database session using the `db.session.add_all()` function. Lastly, you commit the transaction and apply the changes to the database using the `db.session.commit()`.

Save and close the file.

Execute the `init_db.py` program:

```custom_prefix((env)sammy@localhost:$)
python init_db.py
```

To take a look at the data you added to your database, make sure your virtual environment is activated, and open the Flask shell to query all employees and display their data:

```custom_prefix((env)sammy@localhost:$)
flask shell
```

Run the following code to query all employees and display their data:

```custom_prefix(>>>)
from app import db, Employee


employees = Employee.query.all()

for employee in employees:
    print(employee.firstname, employee.lastname)
    print('Email:', employee.email)
    print('Age:', employee.age)
    print('Hired:', employee.hire_date)
    if employee.active:
        print('Active')
    else:
        print('Out of Office')
    print('----')
```

You use the `all()` method of the `query` attribute to get all employees. You loop through the results, and display employee information. For the `active` column, you use a conditional statement to display the current status of the employee, either `'Active'` or `'Out of Office'`.

You'll receive the following output:

```
[secondary_label Output]
John Doe
Email: jd@example.com
Age: 32
Hired: 2012-03-03
Active
----
Mary Doe
Email: md@example.com
Age: 38
Hired: 2016-06-07
Active
----
Jane Tanaka
Email: jt@example.com
Age: 32
Hired: 2015-09-12
Out of Office
----
Alex Brown
Email: ab@example.com
Age: 29
Hired: 2019-01-03
Active
----
James White
Email: jw@example.com
Age: 24
Hired: 2021-02-04
Active
----
Harold Ishida
Email: hi@example.com
Age: 52
Hired: 2002-03-06
Out of Office
----
Scarlett Winter
Email: sw@example.com
Age: 22
Hired: 2021-04-07
Active
----
Emily Vill
Email: ev@example.com
Age: 27
Hired: 2019-06-09
Active
----
Mary Park
Email: mp@example.com
Age: 30
Hired: 2021-08-11
Active
----
```

You can see that all of the employees we've added to the database are properly displayed.

Exit the Flask shell:

```custom_prefix(>>>)
exit()
```

Next, you'll create a Flask route to display employees. Open `app.py` for editing:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Add the following route at the end of the file:

```python
[label flask_app/app.py]
...

@app.route('/')
def index():
    employees = Employee.query.all()
    return render_template('index.html', employees=employees)
```
Save and close the file.

This queries all employees, renders an `index.html` template, and passes it the employees you fetch.

Create a templates directory and a [base template](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application):

```custom_prefix((env)sammy@localhost:$)
mkdir templates
nano templates/base.html
```

Add the following to `base.html`:

```html
[label flask_app/templates/base.html]
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %} {% endblock %} - FlaskApp</title>
    <style>
        .title {
            margin: 5px;
        }

        .content {
            margin: 5px;
            width: 100%;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }

        .employee {
            flex: 20%;
            padding: 10px;
            margin: 5px;
            background-color: #f3f3f3;
            inline-size: 100%;
        }

        .name {
            color: #00a36f;
            text-decoration: none;
        }

        nav a {
            color: #d64161;
            font-size: 3em;
            margin-left: 50px;
            text-decoration: none;
        }

        .pagination {
            margin: 0 auto;
        }

        .pagination span {
            font-size: 2em;
            margin-right: 10px;
        }

        .page-number {
            color: #d64161;
            padding: 5px;
            text-decoration: none;
        }

        .current-page-number {
            color: #666
        }

    </style>
</head>
<body>
    <nav>
        <a href="{{ url_for('index') }}">FlaskApp</a>
        <a href="#">About</a>
    </nav>
    <hr>
    <div class="content">
        {% block content %} {% endblock %}
    </div>
</body>
</html>
```

Save and close the file.

Here, you use a title block and add some CSS styling. You add a navbar with two items, one for the index page, and one for an inactive About page. This navbar will be reused throughout the application in the templates that inherit from this base template. The content block will be replaced with the content of each page. For more on templates, check out [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).

Next, open a new `index.html` template you rendered in `app.py`:

```custom_prefix((env)sammy@localhost:$)
nano templates/index.html
```

Add the following code to the file:

```html
[label flask_app/templates/index.html]
{% extends 'base.html' %}

{% block content %}
    <h1 class="title">{% block title %} Employees {% endblock %}</h1>
    <div class="content">
        {% for employee in employees %}
            <div class="employee">
                <p><b>#{{ employee.id }}</b></p>
                <b>
                    <p class="name">{{ employee.firstname }} {{ employee.lastname }}</p>
                </b>
                <p>{{ employee.email }}</p>
                <p>{{ employee.age }} years old.</p>
                <p>Hired: {{ employee.hire_date }}</p>
                {% if employee.active %}
                    <p><i>(Active)</i></p>
                {% else %}
                    <p><i>(Out of Office)</i></p>
                {% endif %}
            </div>
        {% endfor %}
    </div>
{% endblock %}
```

Here, you loop through employees and display each employee's information. If the employee is active you add an **(Active)** label, otherwise you display an **(Out of Office)** label.

Save and close the file.

While in your `flask_app` directory with your virtual environment activated, tell Flask about the application (`app.py` in this case) using the `FLASK_APP` environment variable. Then set the `FLASK_ENV` environment variable to `development` to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see [How To Handle Errors in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-handle-errors-in-a-flask-application). Use the following commands to do this:

```custom_prefix((env)sammy@localhost:$)
export FLASK_APP=app
export FLASK_ENV=development
```

Next, run the application:

```custom_prefix((env)sammy@localhost:$)
flask run
```

With the development server running, visit the following URL using your browser:

```
http://127.0.0.1:5000/
```

You’ll see the employees you added to the database in a page similar to the following:

![Employees Page](https://assets.digitalocean.com/articles/68400/Employees_Page.png)

Leave the server running, open another terminal, and continue to the next step.

You've displayed the employees you have in your database on the index page. Next, you'll use the Flask shell to query employees using different methods.

## Step 2 — Querying Records
In this step, you'll use the Flask shell to query records, and filter and retrieve results using multiple methods and conditions.

With your programming environment activated, set the `FLASK_APP` and `FLASK_ENV` variables, and open the Flask shell:

```custom_prefix((env)sammy@localhost:$)
export FLASK_APP=app
export FLASK_ENV=development
flask shell
```

Import the `db` object and the `Employee` model:

```custom_prefix(>>>)
from app import db, Employee
```

### Retrieving All Records

As you've seen in the previous step, you can use the `all()` method on the `query` attribute to get all the records in a table:

```custom_prefix(>>>)
all_employees = Employee.query.all()
print(all_employees)
```

The output will be a list of objects representing all employees:

```
[secondary_label Output]

[<Employee John Doe>, <Employee Mary Doe>, <Employee Jane Tanaka>, <Employee Alex Brown>, <Employee James White>, <Employee Harold Ishida>, <Employee Scarlett Winter>, <Employee Emily Vill>, <Employee Mary Park>]
```

### Retrieving the First Record

Similarly, you can use the `first()` method to get the first record:

```custom_prefix(>>>)
first_employee = Employee.query.first()
print(first_employee)
```

The output will be an object that holds the first employee's data:

```
[secondary_label Output]
<Employee John Doe>
```

### Retrieving a Record by ID

In most database tables, records are identified with a unique ID. Flask-SQLAlchemy allows you to fetch a record using its ID with the `get()` method:

```custom_prefix(>>>)
employee5 = Employee.query.get(5)
employee3 = Employee.query.get(3)
print(f'{employee5} | ID: {employee5.id}')
print(f'{employee3} | ID: {employee3.id}')
```

```
[secondary_label Output]
<Employee James White> | ID: 5
<Employee Jane Tanaka> | ID: 3
```

### Retrieving a Record or Multiple Records by a Column Value

To get a record using the value of one of its columns, use the `filter_by()` method. For example, to get a record using its ID value, similar to the `get()` method:

```custom_prefix(>>>)
employee = Employee.query.filter_by(id=1).first()
print(employee)
```
```
[secondary_label Output]
<Employee John Doe>
```

You use `first()` because `filter_by()` may return multiple results.

<$>[note]
**Note:** For getting a record by ID, using the `get()` method is a better approach.
<$>

For another example, you can get an employee using their age:

```custom_prefix(>>>)
employee = Employee.query.filter_by(age=52).first()
print(employee)
```
```
[secondary_label Output]
<Employee Harold Ishida>
```

For an example where the query result holds more than one matching record, use the `firstname` column and the first name `Mary`, which is a name shared by two employees:

```custom_prefix(>>>)
mary = Employee.query.filter_by(firstname='Mary').all()
print(mary)
```
```
[secondary_label Output]
[<Employee Mary Doe>, <Employee Mary Park>]
```

Here, you use `all()` to get the full list. You can also use `first()` to get only the first result:

```custom_prefix(>>>)
mary = Employee.query.filter_by(firstname='Mary').first()
print(mary)
```
```
[secondary_label Output]
<Employee Mary Doe>
```

You've fetched records through column values. Next, you'll query your table using logical conditions.

## Step 3 — Filtering Records Using Logical Conditions
In complex, full-featured web applications, you often need to query records from the database using complicated conditionals, such as fetching employees based on a combination of conditions that take into account their location, availability, role, and responsibilities. In this step, you'll get practice using conditional operators. You'll use the `filter()` method on the `query` attribute to filter query results using logical conditions with different operators. For example, you can use logical operators to fetch a list of which employees are currently out of office, or employees due for a promotion, and maybe provide a calendar of employee vacation time, etc.

### Equals
The simplest logical operator you can use is the equality operator `==`, which behaves in a similar way to `filter_by()`. For example, to get all the records where the value of the `firstname` column is `Mary`, you can use the `filter()` method like so:

```custom_prefix(>>>)
mary = Employee.query.filter(Employee.firstname == 'Mary').all()
print(mary)
```

Here you use the syntax `Model.column == value` as an argument to the `filter()` method. The `filter_by()` method is a shortcut for this syntax.

The result is the same as the result of the `filter_by()` method with the same condition:

```
[secondary_label Output]
[<Employee Mary Doe>, <Employee Mary Park>]
```

Like `filter_by()`, you can also use the `first()` method to get the first result:

```custom_prefix(>>>)
mary = Employee.query.filter(Employee.firstname == 'Mary').first()
print(mary)
```
```
[secondary_label Output]
<Employee Mary Doe>
```

### Not Equals
The `filter()` method allows you to use the `!=` Python operator to get records. For example, to get a list of out-of-office employees, you can use the following approach:

```custom_prefix(>>>)
out_of_office_employees = Employee.query.filter(Employee.active != True).all()
print(out_of_office_employees)
```
```
[secondary_label Output]
[<Employee Jane Tanaka>, <Employee Harold Ishida>]
```

Here you use the `Employee.active != True` condition to filter results.

### Less Than

You can use the `<` operator to get a record where the value of a given column is less than the given value. For example, to get a list of employees under 32 years old:

```custom_prefix(>>>)
employees_under_32 = Employee.query.filter(Employee.age < 32).all()

for employee in employees_under_32:
    print(employee.firstname, employee.lastname)
    print('Age: ', employee.age)
    print('----')
```
```
[secondary_label Output]

Alex Brown
Age:  29
----
James White
Age:  24
----
Scarlett Winter
Age:  22
----
Emily Vill
Age:  27
----
Mary Park
Age:  30
----
```

Use the `<=` operator for records that are less than or equal to the given value. For example, to include employees aged 32 in the previous query:

```custom_prefix(>>>)
employees_32_or_younger = Employee.query.filter(Employee.age <=32).all()

for employee in employees_32_or_younger:
    print(employee.firstname, employee.lastname)
    print('Age: ', employee.age)
    print('----')
```

```
[secondary_label Output]

John Doe
Age:  32
----
Jane Tanaka
Age:  32
----
Alex Brown
Age:  29
----
James White
Age:  24
----
Scarlett Winter
Age:  22
----
Emily Vill
Age:  27
----
Mary Park
Age:  30
----
```

### Greater Than

Similarly, the `>` operator gets a record where the value of a given column is greater than the given value. For example, to get employees over 32:

```custom_prefix(>>>)
employees_over_32 = Employee.query.filter(Employee.age > 32).all()

for employee in employees_over_32:
    print(employee.firstname, employee.lastname)
    print('Age: ', employee.age)
    print('----')
```
```
[secondary_label Output]
Mary Doe
Age:  38
----
Harold Ishida
Age:  52
----
```

And the `>=` operator is for records that are greater than or equal to the given value. For example, you can again include 32-year-old employees in the previous query:

```custom_prefix(>>>)
employees_32_or_older = Employee.query.filter(Employee.age >=32).all()

for employee in employees_32_or_older:
    print(employee.firstname, employee.lastname)
    print('Age: ', employee.age)
    print('----')
```

```
[secondary_label Output]

John Doe
Age:  32
----
Mary Doe
Age:  38
----
Jane Tanaka
Age:  32
----
Harold Ishida
Age:  52
----
```

### In

SQLAlchemy also provides a way to get records where a column's value matches a value from a given list of values using the `in_()` method on the column like so:

```custom_prefix(>>>)
names = ['Mary', 'Alex', 'Emily']
employees = Employee.query.filter(Employee.firstname.in_(names)).all()
print(employees)
```
```
[secondary_label Output]
[<Employee Mary Doe>, <Employee Alex Brown>, <Employee Emily Vill>, <Employee Mary Park>]
```

Here, you use a condition with the syntax `Model.column.in_(iterable)`, where `iterable` is any type of [object you can iterate through](https://docs.python.org/3.8/glossary.html#term-iterable). For another example, you can use the `range()` Python function to get employees from a certain age range. The following query gets all the employees that are in their thirties.

```custom_prefix(>>>)
employees_in_30s = Employee.query.filter(Employee.age.in_(range(30, 40))).all()
for employee in employees_in_30s:
    print(employee.firstname, employee.lastname)
    print('Age: ', employee.age)
    print('----')
```
```
[secondary_label Output]
John Doe
Age:  32
----
Mary Doe
Age:  38
----
Jane Tanaka
Age:  32
----
Mary Park
Age:  30
----
```

### Not In

Similar to the `in_()` method, you can use the `not_in()` method to get records where a column value is not in a given iterable:

```custom_prefix(>>>)
names = ['Mary', 'Alex', 'Emily']
employees = Employee.query.filter(Employee.firstname.not_in(names)).all()
print(employees)
```
```
[secondary_label Output]

[<Employee John Doe>, <Employee Jane Tanaka>, <Employee James White>, <Employee Harold Ishida>, <Employee Scarlett Winter>]
```

Here, you get all employees except those with a first name in the `names` list.

### And
You can join several conditions together using the `db.and_()` function, which works like Python's `and` operator.

For example, let's say you want to get all the employees that are 32 years old **and** are currently active. First, you can check who is 32 using the `filter_by()` method (you can also use `filter()` if you want):

```custom_prefix(>>>)
for employee in Employee.query.filter_by(age=32).all():
    print(employee)
    print('Age:', employee.age)
    print('Active:', employee.active)
    print('-----')
```
```
[secondary_label Output]
<Employee John Doe>
Age: 32
Active: True
-----
<Employee Jane Tanaka>
Age: 32
Active: False
-----
```
Here, you see that John and Jane are the employees that are 32 years old. John is active, and Jane is out of office.

To get the employees that are 32 **and** active, you'll use two conditions with the `filter()` method:

* `Employee.age == 32`
* `Employee.active == True`

To join these two conditions together, use the `db.and_()` function like so:

```custom_prefix(>>>)
active_and_32 = Employee.query.filter(db.and_(Employee.age == 32,
                                      Employee.active == True)).all()
print(active_and_32)
```

```
[secondary_label Output]
[<Employee John Doe>]
```

Here, you use the syntax `filter(db.and_(condition1, condition2))`.

Using `all()` on the query returns a list of all the records that match the two conditions. You can use the `first()` method to get the first result:

```custom_prefix(>>>)
active_and_32 = Employee.query.filter(db.and_(Employee.age == 32,
                                      Employee.active == True)).first()
print(active_and_32)
```

```
[secondary_label Output]
<Employee John Doe>
```

For a more complex example, you can use the `db.and_()` with the `date()` function to get employees who were hired in a specific time span. In this example, you get all the employees hired in the year 2019:

```custom_prefix(>>>)
from datetime import date

hired_in_2019 = Employee.query.filter(db.and_(Employee.hire_date >= date(year=2019, month=1, day=1), Employee.hire_date < date(year=2020, month=1, day=1))).all()

for employee in hired_in_2019:
    print(employee, ' | Hired: ', employee.hire_date)
```
```
[secondary_label Output]
<Employee Alex Brown>  | Hired:  2019-01-03
<Employee Emily Vill>  | Hired:  2019-06-09
```

Here you import the `date()` function, and you filter results using the `db.and_()` function to combine the following two conditions:

* `Employee.hire_date >= date(year=2019, month=1, day=1)`: This is `True` for employees hired the first of January 2019 or later.
* `Employee.hire_date < date(year=2020, month=1, day=1)`: This is `True` for employees hired before the first of January 2020.

Combining the two conditions fetches employees hired from the first day of 2019 and before the first day of 2020.

### Or

Similar to `db.and_()`, the `db.or_()` function combines two conditions, and it behaves like the `or` operator in Python. It fetches all records that meet one of two conditions. For example, to get employees aged 32 **or** 52, you can combine two conditions with the `db.or_()` function as follows:

```custom_prefix(>>>)
employees_32_or_52 = Employee.query.filter(db.or_(Employee.age == 32, Employee.age == 52)).all()

for e in employees_32_or_52:
    print(e, '| Age:', e.age)
```
```
[secondary_label Output]
<Employee John Doe> | Age: 32
<Employee Jane Tanaka> | Age: 32
<Employee Harold Ishida> | Age: 52
```

You can also use the `startswith()` and `endswith()` methods on string values in conditions you pass to the `filter()` method. For example, to get all the employees whose first name starts with the string `'M'` and those with a last name that ends with the string `'e'`:


```custom_prefix(>>>)
employees = Employee.query.filter(db.or_(Employee.firstname.startswith('M'), Employee.lastname.endswith('e'))).all()

for e in employees:
    print(e)
```
```
[secondary_label Output]
<Employee John Doe>
<Employee Mary Doe>
<Employee James White>
<Employee Mary Park>
```

Here you combine the following two conditions:

* `Employee.firstname.startswith('M')`: Matches employees with a first name that starts with `'M'`.
* `Employee.lastname.endswith('e')`: Matches employees with a last name that ends with `'e'`.

You can now filter query results using logical conditions in your Flask-SQLAlchemy applications. Next, you'll order, limit, and count the results you get from the database.

## Step 4 — Ordering, Limiting, and Counting Results

In web applications, you often need to order your records when displaying them. For example, you might have a page to display the latest hires in each department to let the rest of the team know about new hires, or you can order employees by displaying the oldest hires first to recognize long-tenured employees. You will also need to limit your results in certain cases, such as displaying only the latest three hires on a small sidebar. And you often need to count the results of a query, for example, to display the number of employees who are currently active. In this step, you'll learn how to order, limit, and count results.

### Ordering Results
To order results using the values of a specific column, use the `order_by()` method. For example, to order results by the employees' first name:

```custom_prefix(>>>)
employees = Employee.query.order_by(Employee.firstname).all()
print(employees)
```
```
[secondary_label Output]
[<Employee Alex Brown>, <Employee Emily Vill>, <Employee Harold Ishida>, <Employee James White>, <Employee Jane Tanaka>, <Employee John Doe>, <Employee Mary Doe>, <Employee Mary Park>, <Employee Scarlett Winter>]
```

As the output shows, the results are ordered alphabetically by the employee's first name.

You can order by other columns. For example, you can use the last name to order employees:

```custom_prefix(>>>)
employees = Employee.query.order_by(Employee.lastname).all()
print(employees)
```
```
[secondary_label Output]
[<Employee Alex Brown>, <Employee John Doe>, <Employee Mary Doe>, <Employee Harold Ishida>, <Employee Mary Park>, <Employee Jane Tanaka>, <Employee Emily Vill>, <Employee James White>, <Employee Scarlett Winter>]
```

You can also order employees by their hire date:

```custom_prefix(>>>)
em_ordered_by_hire_date = Employee.query.order_by(Employee.hire_date).all()

for employee in em_ordered_by_hire_date:
    print(employee.firstname, employee.lastname, employee.hire_date)
```
```
[secondary_label Output]

Harold Ishida 2002-03-06
John Doe 2012-03-03
Jane Tanaka 2015-09-12
Mary Doe 2016-06-07
Alex Brown 2019-01-03
Emily Vill 2019-06-09
James White 2021-02-04
Scarlett Winter 2021-04-07
Mary Park 2021-08-11
```

As the output shows, this orders results from the earliest hire to the latest hire. To reverse the order and make it descending from the latest hire to the earliest, use the `desc()` method like so:

```custom_prefix(>>>)
em_ordered_by_hire_date_desc = Employee.query.order_by(Employee.hire_date.desc()).all()

for employee in em_ordered_by_hire_date_desc:
    print(employee.firstname, employee.lastname, employee.hire_date)
```
```
[secondary_label Output]
Mary Park 2021-08-11
Scarlett Winter 2021-04-07
James White 2021-02-04
Emily Vill 2019-06-09
Alex Brown 2019-01-03
Mary Doe 2016-06-07
Jane Tanaka 2015-09-12
John Doe 2012-03-03
Harold Ishida 2002-03-06
```

You can also combine the `order_by()` method with the `filter()` method to order filtered results. The following example gets all the employees hired in 2021 and orders them by age:

```custom_prefix(>>>)
from datetime import date
hired_in_2021 = Employee.query.filter(db.and_(Employee.hire_date >= date(year=2021, month=1, day=1), Employee.hire_date < date(year=2022, month=1, day=1))).order_by(Employee.age).all()

for employee in hired_in_2021:
    print(employee.firstname, employee.lastname,
          employee.hire_date, '| Age', employee.age)
```
```
[secondary_label Output]
Scarlett Winter 2021-04-07 | Age 22
James White 2021-02-04 | Age 24
Mary Park 2021-08-11 | Age 30
```

Here, you use the `db.and_()` function with two conditions: `Employee.hire_date >= date(year=2021, month=1, day=1)` for employees hired on the first day of 2021 or later, and `Employee.hire_date < date(year=2022, month=1, day=1)` for employees hired before the first day of 2022. You then use the `order_by()` method to order the resulting employees by their age.

### Limiting Results

In most real world cases, when querying a database table, you might get up to millions of matching results, and it is sometimes necessary to limit results to a certain number. To limit results in Flask-SQLAlchemy, you can use the `limit()` method. The following example queries the `employee` table and returns only the first three matching results:

```custom_prefix(>>>)
employees = Employee.query.limit(3).all()
print(employees)
```
```
[secondary_label Output]
[<Employee John Doe>, <Employee Mary Doe>, <Employee Jane Tanaka>]
```

You can use `limit()` with other methods, such as `filter` and `order_by`. For example, you can get the last two employees hired in 2021 using the `limit()` method like so:

```custom_prefix(>>>)
from datetime import date
hired_in_2021 = Employee.query.filter(db.and_(Employee.hire_date >= date(year=2021, month=1, day=1), Employee.hire_date < date(year=2022, month=1, day=1))).order_by(Employee.age).limit(2).all()

for employee in hired_in_2021:
    print(employee.firstname, employee.lastname,
          employee.hire_date, '| Age', employee.age)
```
```
[secondary_label Output]
Scarlett Winter 2021-04-07 | Age 22
James White 2021-02-04 | Age 24
```

Here, you use the same query in the previous section with an additional `limit(2)` method call.

### Counting Results
To count the number of results of a query, you can use the `count()` method. For example, to get the number of employees that are currently in the database:

```custom_prefix(>>>)
employee_count = Employee.query.count()
print(employee_count)
```
```
[secondary_label Output]
9
```
You can combine the `count()` method with other query methods similar to `limit()`. For example, to get the number of employees hired in 2021:

```custom_prefix(>>>)
from datetime import date
hired_in_2021_count = Employee.query.filter(db.and_(Employee.hire_date >= date(year=2021, month=1, day=1), Employee.hire_date < date(year=2022, month=1, day=1))).order_by(Employee.age).count()
print(hired_in_2021_count)
```
```
[secondary_label Output]
3
```
Here you use the same query you used previously for getting all the employees that were hired in 2021. And you use the `count()` to retrieve the number of entries, which is 3.

You've ordered, limited, and counted query results in Flask-SQLAlchemy. Next, you'll learn how to split query results into multiple pages and how to create a pagination system in your Flask applications.

## Step 5 — Displaying Long Record Lists on Multiple Pages
In this step, you'll modify the main route to make the index page display employees on multiple pages to make navigating the employee list easier.

First, you'll use the Flask shell to see a demonstration of how to use the pagination feature in Flask-SQLAlchemy. Open the Flask shell if you haven't already:

```custom_prefix((env)sammy@localhost:$)
flask shell
```

Let's say you want to split the employee records in your table into multiple pages, with two items per page. You can do this using the `paginate()` query method like so:

```custom_prefix(>>>)
page1 = Employee.query.paginate(page=1, per_page=2)
print(page1)
print(page1.items)
```
```
[secondary_label Output]
<flask_sqlalchemy.Pagination object at 0x7f1dbee7af80>
[<Employee John Doe>, <Employee Mary Doe>]
```

You use the `page` parameter of the `paginate()` query method to specify the page you want to access, which is the first page in this case. The `per_page` parameter specifies the number of items each page must have. In this case you set it to `2` to make each page have two items.

The `page1` variable here is a _pagination object_, which gives you access to attributes and methods you'll use to manage your pagination.

You access the page's items using the `items` attribute.

To access the next page, you can use the `next()` method of the pagination object like so, the returned result is also a pagination object:

```custom_prefix(>>>)
page2 = page1.next()

print(page2.items)
print(page2)
```
```
[secondary_label Output]
[<Employee Jane Tanaka>, <Employee Alex Brown>]

<flask_sqlalchemy.Pagination object at 0x7f1dbee799c0>
```

You can get a pagination object for the previous page using the `prev()` method. In the following example you access the pagination object for the fourth page, then you access the pagination object of its previous page, which is page 3:

```custom_prefix(>>>)
page4 = Employee.query.paginate(page=4, per_page=2)
print(page4.items)
page3 = page4.prev()
print(page3.items)
```
```
[secondary_label Output]
[<Employee Scarlett Winter>, <Employee Emily Vill>]

[<Employee James White>, <Employee Harold Ishida>]
```

You can access the current page number using the `page` attribute like so:

```custom_prefix(>>>)
print(page1.page)
print(page2.page)
```
```
[secondary_label Output]
1
2
```

To get the total number of pages, use the `pages` attribute of the pagination object. In the following example, both `page1.pages` and `page2.pages` return the same value because the total number of pages is a constant:

```custom_prefix(>>>)
print(page1.pages)
print(page2.pages)
```
```
[secondary_label Output]
5
5
```

For the total number of items, use the `total` attribute of the pagination object:

```custom_prefix(>>>)
print(page1.total)
print(page2.total)
```
```
[secondary_label Output]
9
9
```

Here, since you query all employees, the total number of items in the pagination is 9, because there are nine employees in the database.

Following are some of the other attributes that pagination objects have:

* `prev_num`: The previous page number.
* `next_num`: The next page number.
* `has_next`: `True` if there is a next page.
* `has_prev`: `True` if there is a previous page.
* `per_page`: The number of items per page.


The pagination object also has an `iter_pages()` method you can loop through to access page numbers. For example, you can print all page numbers like so:

```custom_prefix(>>>)
pagination = Employee.query.paginate(page=1, per_page=2)

for page_num in pagination.iter_pages():
    print(page_num)
```
```
[secondary_label Output]
1
2
3
4
5
```

The following is a demonstration of how to access all pages and their items using a pagination object and the `iter_pages()` method:

```custom_prefix(>>>)
pagination = Employee.query.paginate(page=1, per_page=2)

for page_num in pagination.iter_pages():
    print('PAGE', pagination.page)
    print('-')
    print(pagination.items)
    print('-'*20)
    pagination = pagination.next()
```


```
[secondary_label Output]

PAGE 1
-
[<Employee John Doe>, <Employee Mary Doe>]
--------------------
PAGE 2
-
[<Employee Jane Tanaka>, <Employee Alex Brown>]
--------------------
PAGE 3
-
[<Employee James White>, <Employee Harold Ishida>]
--------------------
PAGE 4
-
[<Employee Scarlett Winter>, <Employee Emily Vill>]
--------------------
PAGE 5
-
[<Employee Mary Park>]
--------------------
```

Here, you create a pagination object that starts from the first page. You loop through pages using a `for` loop with the `iter_pages()` pagination method. You print the page number and page items, and you set the `pagination` object to the pagination object of its next page using the `next()` method.

You can also use the `filter()` and the `order_by()` methods with the `paginate()` method to paginate filtered and ordered query results. For example, you can get employees over thirty and order results by age and paginate the results like so:

```custom_prefix(>>>)
pagination = Employee.query.filter(Employee.age > 30).order_by(Employee.age).paginate(page=1, per_page=2)

for page_num in pagination.iter_pages():
    print('PAGE', pagination.page)
    print('-')
    for employee in pagination.items:
        print(employee, '| Age: ', employee.age)
    print('-'*20)
    pagination = pagination.next()
```
```
[secondary_label Output]
PAGE 1
-
<Employee John Doe> | Age:  32
<Employee Jane Tanaka> | Age:  32
--------------------
PAGE 2
-
<Employee Mary Doe> | Age:  38
<Employee Harold Ishida> | Age:  52
--------------------
```

Now that you have a solid understanding of how pagination works in Flask-SQLAlchemy, you will edit the index page of your application to display employees on multiple pages for easier navigation.

Exit the Flask shell:

```custom_prefix(>>>)
exit()
```

To access different pages, you'll use _URL parameters_, also known as _URL query strings_, which are a way to pass information to the application through the URL. Parameters are passed to the application in the URL after a `?` symbol. For example, to pass a `page` parameter with different values you can use the following URLs:


```
http://127.0.0.1:5000/?page=1
http://127.0.0.1:5000/?page=3
```

Here, the first URL passes a value `1` to the URL parameter `page`. The second URL passes a value `3` to the same parameter.

Open the `app.py` file:

```custom_prefix((env)sammy@localhost:$)
nano app.py
```

Edit the index route to look as follows:

```python
@app.route('/')
def index():
    page = request.args.get('page', 1, type=int)
    pagination = Employee.query.order_by(Employee.firstname).paginate(
        page, per_page=2)
    return render_template('index.html', pagination=pagination)
```

Here, you get the value of the `page` URL parameter using the `request.args` object and its `get()` method. For example `/?page=1` will get the value `1` from the `page` URL parameter. You pass `1` as a default value, and you pass the `int` Python type as an argument to the `type` parameter to make sure the value is an integer.

Next you create a `pagination` object, ordering query results by the first name. You pass the `page` URL parameter value to the `paginate()` method, and you split results into two items per page by passing the value `2` to the `per_page` parameter.

Lastly, you pass the `pagination` object you constructed to the rendered `index.html` template.

Save and close the file.

Next, edit the `index.html` template to display pagination items:

```custom_prefix((env)sammy@localhost:$)
nano templates/index.html
```

Change the content `div` tag by adding an `h2` heading that indicates the current page, and changing the `for` loop to loop through the `pagination.items` object instead of the `employees` object, which is no longer available:

```html
<div class="content">
    <h2>(Page {{ pagination.page }})</h2>
    {% for employee in pagination.items %}
        <div class="employee">
            <p><b>#{{ employee.id }}</b></p>
            <b>
                <p class="name">{{ employee.firstname }} {{ employee.lastname }}</p>
            </b>
            <p>{{ employee.email }}</p>
            <p>{{ employee.age }} years old.</p>
            <p>Hired: {{ employee.hire_date }}</p>
            {% if employee.active %}
                <p><i>(Active)</i></p>
            {% else %}
                <p><i>(Out of Office)</i></p>
            {% endif %}
        </div>
    {% endfor %}
</div>
```

Save and close the file.

If you haven't already, set the `FLASK_APP` and `FLASK_ENV` environment variables and run the development server:

```custom_prefix((env)sammy@localhost:$)
export FLASK_APP=app
export FLASK_ENV=development
flask run
```

Now, navigate to the index page with different values for the `page` URL parameter:

```
http://127.0.0.1:5000/
http://127.0.0.1:5000/?page=2
http://127.0.0.1:5000/?page=4
http://127.0.0.1:5000/?page=19
```

You'll see different pages with two items each, and different items on each page, as you've seen previously in the Flask shell.

![Paginated Index](https://assets.digitalocean.com/articles/68400/Paginated_Index.png)

If the given page number does not exit, you'll get a `404 Not Found` HTTP error, which is the case with the last URL in the preceding URL list.

Next, you'll create a pagination widget to navigate between pages, you'll use a few attributes and methods of the pagination object to display all page numbers, each number links to its dedicated page, and a `<<<` button for going back if the current page has a previous page, and a `>>>` button for going to the next page if it exists.

The pagination widget will look as follows:

![Pagination Widget](https://assets.digitalocean.com/articles/68400/Pagination_Widget.png)
![Pagination Widget2](https://assets.digitalocean.com/articles/68400/Pagination_Widget2.png)

To add it, open `index.html`:

```custom_prefix((env)sammy@localhost:$)
nano templates/index.html
```

Edit the file by adding the following highlighted `div` tag below the content `div` tag:

```html
[label flask_app/templates/index.html]
<div class="content">
    {% for employee in pagination.items %}
        <div class="employee">
            <p><b>#{{ employee.id }}</b></p>
            <b>
                <p class="name">{{ employee.firstname }} {{ employee.lastname }}</p>
            </b>
            <p>{{ employee.email }}</p>
            <p>{{ employee.age }} years old.</p>
            <p>Hired: {{ employee.hire_date }}</p>
            {% if employee.active %}
                <p><i>(Active)</i></p>
            {% else %}
                <p><i>(Out of Office)</i></p>
            {% endif %}
        </div>
    {% endfor %}
</div>

<div class="pagination">
    {% if pagination.has_prev %}
        <span>
            <a class='page-number' href="{{ url_for('index', page=pagination.prev_num) }}">
                {{ '<<<' }}
            </a>
        </span>
    {% endif %}

    {% for number in pagination.iter_pages() %}
        {% if pagination.page != number %}
            <span>
                    <a class='page-number'
                        href="{{ url_for('index', page=number) }}">
                    {{ number }}
                    </a>
            </span>
        {% else %}
            <span class='current-page-number'>{{ number }}</span>
        {% endif %}
    {% endfor %}

    {% if pagination.has_next %}
        <span>
            <a class='page-number'
                href="{{ url_for('index', page=pagination.next_num) }}">
                {{ '>>>' }}
            </a>
        </span>
    {% endif %}
</div>
```
Save and close the file.

Here, you use the condition `if pagination.has_prev` to add a `<<<` link to the previous page if the current page isn't the first page. You link to the previous page using the `url_for('index', page=pagination.prev_num)` function call, in which you link to the index view function, passing the `pagination.prev_num` value to the `page` URL parameter.

To display links to all the available page numbers, you loop through the items of the `pagination.iter_pages()` method which gives you a page number on each loop.

You use the `if pagination.page != number` condition to see whether the current page number isn't the same as the number in the current loop. If the condition is true, you link to the page to allow the user to change the current page to another page. Otherwise, if the current page is the same as the loop number, you display the number without a link. This allows users to know the current page number in the pagination widget.

Lastly, you use the `pagination.has_next` condition to see whether the current page has a next page, in which case you link to it using the `url_for('index', page=pagination.next_num)` call and a `>>>` link.


Navigate to the index page in your browser: `http://127.0.0.1:5000/`

You'll see the pagination widget is fully functional:

![Pagination Widget](https://assets.digitalocean.com/articles/68400/Pagination_Widget.png)
![Pagination Widget2](https://assets.digitalocean.com/articles/68400/Pagination_Widget2.png)

Here, you use `>>>` for moving to the next page and `<<<` for the previous page, but you can also use any other characters you'd like, such as `>` and `<` or images in `<img>` tags.

You've displayed employees on multiple pages and learned how to handle pagination in Flask-SQLAlchemy. And you can now use your pagination widget on other Flask applications you build.

## Conclusion

You used Flask-SQLAlchemy to create an employee management system. You queried a table and filtered results based on column values and simple and complex logical conditions. You ordered, counted, and limited query results. And you created a pagination system to display a certain number of records on each page in your web application, and navigate between pages.

You can use what you've learned in this tutorial in combination with concepts explained in some of our other Flask-SQLAlchemy tutorials to add more functionality to your employee management system:

* [How to Use Flask-SQLAlchemy to Interact with Databases in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application) to learn how to add, edit, or delete employees.
* [How to Use One-to-Many Database Relationships with Flask-SQLAlchemy](https://www.digitalocean.com/community/tutorials/how-to-use-one-to-many-database-relationships-with-flask-sqlalchemy) to learn how to use one-to-many relationships to create a department table to link each employee to the department they belong to.
* [How To Use Many-to-Many Database Relationships with Flask-SQLAlchemy](https://www.digitalocean.com/community/tutorials/how-to-use-many-to-many-database-relationships-with-flask-sqlalchemy) to learn how to use many-to-many relationships to create a `tasks` table and link it to the `employee` table, where each employee has many tasks and each task is assigned to multiple employees.

If you would like to read more about Flask, check out the other tutorials in the [How To Build Web Applications with Flask](https://www.digitalocean.com/community/tutorial_series/how-to-create-web-sites-with-flask) series.



## How To Structure a Large Flask Application with Flask Blueprints and Flask-SQLAlchemy

*The author selected the [Free and Open Source Fund](https://www.brightfunds.org/funds/foss-nonprofits) to receive a donation as part of the [Write for DOnations](https://do.co/w4do-cta) program.*

### Introduction

[Flask](https://palletsprojects.com/p/flask/) is a lightweight Python web framework with useful tools and features for creating web applications in Python. [SQLAlchemy](https://www.sqlalchemy.org/) is an SQL toolkit that offers efficient and high-performing database access for relational databases. It supplies ways to interact with several database engines, such as SQLite, MySQL, and PostgreSQL, by providing access to the database's SQL functionalities. This toolkit also gives you an Object Relational Mapper (ORM), which enables you to make queries and handle data using simple Python objects and methods. [Flask-SQLAlchemy](https://flask-sqlalchemy.palletsprojects.com/) is a Flask extension that makes using SQLAlchemy with Flask easier, providing tools and methods to interact with your database in your Flask applications.

Flask provides a way to build a small web application quickly with one Python file. However, a small application can grow into a large application with multiple database tables, hundreds of routes, and complex features. Writing the code for a large application in one file will quickly become messy and hard to manage. Flask allows you to organize your application's code base by splitting each of the application's major parts into specific directories and files for a better-organized application.

For example, in a social media application, you might have the routes for users in a file called `routes.py` inside a directory called `users`, and you might then collect the database models for users inside a module called `users.py` inside a `models` directory. Then you can do the same for posts, followers, hashtags, questions, answers, ads, the marketplace, payments, and other features in your large social media application. If you want to edit some business logic into the payments code, you can change the database code for payments in a file located at `mysocialapp/models/payment.py`, then change the business logic in a file located at `mysocialapp/payments/routes.py`. Each part of the application will have its code isolated in different files and directories, effectively splitting the application into easy-to-manage components. This structure also helps familiarize new developers with your application so they know where to troubleshoot an issue or add a new feature.

Flask provides a feature called [_blueprints_](https://flask.palletsprojects.com/en/2.2.x/blueprints/) for making application components. In the prior example, you can use blueprints to structure your large social media application with different blueprints, such as a users' blueprint, a blueprint for posts, one for followers, and so on for each feature.

In this tutorial, you'll use Flask blueprints to structure a web application with three components: the main blueprint containing the home page and other main routes, a posts blueprint for managing blog posts, and a questions blueprint for questions and answers.

## Prerequisites

- A local Python 3 programming environment, which you can set up by following the tutorial for your distribution in [How To Install and Set Up a Local Programming Environment for Python 3](https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-python-3) series. In this tutorial,  we’ll call our project directory `flask_app`.

- An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out [How to Create Your First Web Application Using Flask and Python](https://www.digitalocean.com/community/tutorials/how-to-create-your-first-web-application-using-flask-and-python-3) and [How to Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).

- An understanding of basic HTML concepts. You can review our [How To Build a Website with HTML](https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html) tutorial series for background knowledge.

- An understanding of basic Flask-SQLAlchemy concepts, such as setting up a database, creating database models, and inserting data into the database. See [How to Use Flask-SQLAlchemy to Interact with Databases in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application) for background knowledge.

## The Target Application Structure

By the end of the tutorial, you will have built a Flask application with the following structure:

```
.
└── flask_app
    ├── app
    │   ├── extensions.py
    │   ├── __init__.py
    │   ├── main
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   ├── models
    │   │   ├── post.py
    │   │   └── question.py
    │   ├── posts
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   ├── questions
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   └── templates
    │       ├── base.html
    │       ├── index.html
    │       ├── posts
    │       │   ├── categories.html
    │       │   └── index.html
    │       └── questions
    │           └── index.html
    ├── app.db
    └── config.py
```

Inside your `flask_app` directory, you'll have an `app.db` database file and a `config.py` configuration file for your Flask application. The main Flask application will be in the `app` directory, which will have an `__init__.py` special file to make it a package for imports to work properly, and it will contain a function for creating the Flask application instance.

The `app` directory will contain an `extensions.py` file for managing the Flask extensions you'll use in your application (in this tutorial, Flask-SQLAlchemy is the example of using a Flask extension). You will also have the following directories:

- `main`: the main blueprint for main routes, such as the home page.
- `posts`: the posts blueprint for managing blog posts.
- `questions`: the questions blueprint for managing questions and answers.
- `models`: the directory that will contain Flask-SQLAlchemy models.
- `templates`: the templates directory that will contain files for the main blueprint and a directory for each blueprint.

## Step 1 — Installing Flask and Flask-SQLAlchemy

In this step, you'll install the necessary packages for your application.

In your `flask_app` directory, active your virtual environment:

```command
source my_env/bin/activate
```

With your virtual environment activated, use `pip` to install Flask and Flask-SQLAlchemy:

```custom_prefix((env)sammy@localhost:$)
pip install Flask Flask-SQLAlchemy
```

Once the installation has finished, the output will print a line similar to the following:

```
[secondary_label Output]
Successfully installed Flask-2.1.2 Flask-SQLAlchemy-2.5.1 Jinja2-3.1.2 MarkupSafe-2.1.1 SQLAlchemy-1.4.39 Werkzeug-2.1.2 click-8.1.3 greenlet-1.1.2 itsdangerous-2.1.2
```

With the required Python packages installed, you'll set up a configuration file to manage your Flask application's settings in the next step.

## Step 2 — Creating a Configuration File

In this step, you'll create a configuration file for your Flask application, separating your application settings from the rest of the application and making changing settings easier. The configuration file will configure things such as [the secret key](https://flask.palletsprojects.com/en/2.2.x/api/#sessions), the [SQLAlchemy database URI](https://www.digitalocean.com/community/tutorials/how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application#step-2-setting-up-the-database-and-model), and so on.

In your `flask_app` directory, open a new file called `config.py`. This file will hold your Flask application's configuration:

```custom_prefix((env)sammy@localhost:$)
nano config.py
```

Add the following code to it:

```python
[label flask_app/config.py]
import os

basedir = os.path.abspath(os.path.dirname(__file__))


class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY')
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URI')\
        or 'sqlite:///' + os.path.join(basedir, 'app.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
```

Save and close the file.

You import the `os` module to access your file system. You use `os` to establish the base directory with `os.path.abspath(os.path.dirname(__file__))` to correctly set up the path of the database file.

You use a class called `Config` and set configuration values using class variables. Here, you set three configurations:

- `SECRET_KEY`: A long random string used by Flask as a _secret key_, or a key used to secure the sessions that remember information from one request to another. The user can access the information stored in the session but cannot modify it unless they have the secret key, so you must never allow anyone to access your secret key. See the [Flask documentation on sessions](https://flask.palletsprojects.com/en/2.2.x/api/#sessions) for more information. Other Flask extensions often use this secret key to secure data. See [Step 3 of How To Use Web Forms in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-web-forms-in-a-flask-application#step-3-handling-form-requests) for more information on how to create a secure secret key. When developing your Flask applications, you should set the secret key with an environment variable called `SECRET_KEY`. To get its value in this `config.py` file and save it in a class variable called `SECRET_KEY`, you access the environment variable's value via the [`os.environ`](https://docs.python.org/3/library/os.html#os.environ) object using its `get()` method. (Though you do not need to set a secret key to follow this tutorial, you can review the note at the end of this list for instructions on how to set a secret key.)

- `SQLALCHEMY_DATABASE_URI`: The database URI specifies the database you want to establish a connection with using SQLAlchemy. In this case, you either get it from a `DATABASE_URI` environment variable or you set a default value. The default URI value here follows the format `sqlite:///path/to/app.db`. You use the `os.path.join()` function to join the base directory you constructed and stored in the `basedir` variable and the `app.db` file name. With this, creating a Flask application without setting a `DATABASE_URI` environment variable will connect to an `app.db` database file in your `flask_app` directory by default. The file will be created when you create your database tables. If you'd like to set a database URI for a different SQL engine, see [Step 2 of How to Use Flask-SQLAlchemy to Interact with Databases in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application#step-2-setting-up-the-database-and-model).

- `SQLALCHEMY_TRACK_MODIFICATIONS`: A configuration to enable or disable tracking modifications of objects. You set it to `False` to disable tracking and use less memory. For more, you can read [the configuration page](https://flask-sqlalchemy.palletsprojects.com/en/2.x/config/) in the Flask-SQLAlchemy documentation.

<$>[note]
**Note:** You will not set a secret key in this tutorial because you will not use functionality that needs a secret key. However, if you need to set a secret key, you can set it as follows (for Windows, use `set` instead of `export`):

```custom_prefix((env)sammy@localhost:$)
export SECRET_KEY="your secret key"
```

Similarly, you can set a database URI like so (use `set` on Windows):

```custom_prefix((env)sammy@localhost:$)
export DATABASE_URI="postgresql://username:password@host:port/database_name"
```
<$>

You have now set up a configuration file for your application. Next, you'll set up a Flask application instance and create a few blueprints that represent different components of your Flask application.

## Step 3 — Creating a Flask Application Factory

In this step, you'll create a [_Flask application factory_](https://flask.palletsprojects.com/en/2.2.x/patterns/appfactories/), which is a Python function that sets up a Flask application instance.

At this point in the tutorial, your `flask_app` directory structure is as follows (excluding the virtual environment's directory):

```
.
├── flask_app
   └── config.py
```

Your application's core code will live inside a project directory, which will be a Python package. In this tutorial, we'll call it `app`, but you can use your project's name or another common directory name such as `src`, `core`, or something similar.

You'll make the folder containing the application's core code a Python package so that imports work correctly throughout the code base and to increase its maintainability.

To make the `app` project directory a Python package, you'll create a special `__init__.py` file inside of it, which marks directories as Python packages. This `__init__.py` file will hold code for your _Flask factory function_, which is a function you'll use to set and create the Flask application instance where you link all your Flask blueprints together. Think of the factory function as the central function in which all your Flask components (blueprints) are combined into one application and that you can use to create different Flask application instances for different purposes with different configurations. For example, you could use the factory function to create a Flask application instance for testing with proper configurations for testing.

Inside your `flask_app` directory, create this new `app` directory:

```custom_prefix((env)sammy@localhost:$)
mkdir app
```

Then open a new `__init__.py` file inside the `app` directory:

```custom_prefix((env)sammy@localhost:$)
nano app/__init__.py
```

Add the following code to it:

```python
[label flask_app/app/__init__.py]
from flask import Flask

from config import Config

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)

    # Initialize Flask extensions here

    # Register blueprints here

    @app.route('/test/')
    def test_page():
        return '<h1>Testing the Flask Application Factory Pattern</h1>'

    return app
```

Save and close the file.

In this file, you import the `Flask` class from the `flask` package. Then you import the `Config` configuration class from the `config.py` file you created in the `flask_app` directory in the previous step.

The `create_app()` function is the [_Flask application factory function_](https://flask.palletsprojects.com/en/2.2.x/patterns/appfactories/). It creates an application instance called `app` from the `Flask()` class using the familiar `app = Flask(__name__)` line. You configure the application by importing configuration values from an object using the `app.config.from_object()` method, passing it the value of the `config_class` parameter, which holds the `Config` class as a default value. You will initialize your Flask extensions below the `# Initialize Flask extensions here` comment and register your application blueprints below the `# Register blueprints here` comment once you create them.

You create a test route using the `app.route()` decorator inside the factory function to demonstrate how to register routes inside application factories. In this case, the `test_page()` view function returns the heading `Testing the Flask Application Factory Pattern`.

Lastly, the `create_app()` factory function returns the application instance you constructed with the line `return app`.

Flask will automatically detect the `create_app()` factory function in your `app` package and use it to create an application instance. But you'll need to set the environment variables required to run your Flask application in development mode first.

While in your `flask_app` directory with your virtual environment activated, you will tell Flask where the factory function is by passing the core application's directory name `app` as a value to the `FLASK_APP` environment variable. Then you will set the `FLASK_ENV` environment variable to `development` to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see [How To Handle Errors in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-handle-errors-in-a-flask-application).

First, set the `app` package as the place where Flask should look for the `create_app()` factory function:

```custom_prefix((env)sammy@localhost:$)
export FLASK_APP=app
```

You may be used to building your Flask applications in a single Python file called `app.py`. In that case, you also use the same command to tell Flask where to locate your application. The difference here is that `app` in the preceding command is for the project's core directory, where you have your `__init__.py` file.

Set the `FLASK_ENV` environment variable to run the application in development mode:

```custom_prefix((env)sammy@localhost:$)
export FLASK_ENV=development
```

Then run the application:

```custom_prefix((env)sammy@localhost:$)
flask run
```

With the development server running, visit the following URL using your browser:

```
http://127.0.0.1:5000/test/
```

The site will load with a `Testing the Flask Application Factory Pattern` heading.

You have now created a Flask application factory function. Next, you'll create Flask blueprints and register them in this factory function.

## Step 4 — Creating Flask Blueprints

In this step, you will create a blueprint for the main routes that will manage the main component of your Flask application, and then you will register the blueprint on your factory function. You'll create another blueprint each for blog posts, questions, and answers. You'll add a few routes to each blueprint and render templates for each route with a `templates` directory for each blueprint.

At this point in the tutorial, your `flask_app` directory structure is as follows (excluding the virtual environment's directory):

```
.
├── flask_app
    ├── app
    │   └── __init__.py
    └── config.py
```

### Creating the Main Blueprint and Rendering its Templates

You will now create the main blueprint for the application and render its templates.

Leave the development server you started in the previous step running, and open a new terminal.

Navigate to your `flask_app` directory in the new terminal. Then create a directory called `main` for your main blueprint inside the `app` directory:

```custom_prefix((env)sammy@localhost:$)
mkdir app/main
```

Next, open a new `__init__.py` main file inside the new `main` directory:

```custom_prefix((env)sammy@localhost:$)
nano app/main/__init__.py
```

This is where you'll create your main blueprint. Add the following code to this file:

```python
[label flask_app/app/main/__init__.py]
from flask import Blueprint

bp = Blueprint('main', __name__)
```

Save and close the file.

Here, you import the [`Blueprint`](https://flask.palletsprojects.com/en/2.2.x/api/#flask.Blueprint) class from the `flask` package. Then you use this class to create a blueprint object `bp`, passing it two arguments: a name (`'main'` in this case) and the `__name__` special variable, which holds the name of the current Python module.

You now have a blueprint object, which will later have routes and functions you can plug into the Flask application you create using the `create_app()` factory function you've written in the previous step.

Next, you'll create a `routes.py` file inside your `main` blueprint directory, which will hold the routes of the main blueprint. Open a new `routes.py` file inside your main blueprint directory:

```custom_prefix((env)sammy@localhost:$)
nano app/main/routes.py
```

You'll create routes using the `bp` object. Add the following route inside the new file:

```python
[label flask_app/app/main/routes.py]
from app.main import bp


@bp.route('/')
def index():
    return 'This is The Main Blueprint'
```

Save and close the file.

Here, you import the `bp` blueprint object from the main blueprint, which you access through `app.main`. In the import line, `app` is the project's package, `main` is the main blueprint package, and `bp` is the object you declared in the main blueprint's `__init__.py` file.

You use the `bp` object to create a `/` route and an `index()` view function with the `bp.route()` decorator, similar to the familiar `app.route()` decorator.

For Flask to use these routes and to make them importable directly from the blueprint, you'll need to import this `routes.py` file in your blueprint's `__init__.py` file. Open it for editing:

```custom_prefix((env)sammy@localhost:$)
nano app/main/__init__.py
```

Add the highlighted import line at the end of the file:

```python
[label flask_app/app/main/__init__.py]
from flask import Blueprint

bp = Blueprint('main', __name__)

from app.main import routes
```

Save and close the file.

With this addition, registering a blueprint will also register its routes.

Now that you've created a blueprint and added a route, you'll need to tell Flask about this new blueprint so that it can be treated as part of your Flask application. To do this, you'll register the blueprint inside your Flask application factory function.

Open the `app/__init__.py` file to edit your factory function:

```custom_prefix((env)sammy@localhost:$)
nano app/__init__.py
```

Edit the `create_app()` factory function to match the following block, adding the highlighted lines:

```python
[label flask_app/app/main/__init__.py]
...
def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)

    # Initialize Flask extensions here

    # Register blueprints here
    from app.main import bp as main_bp
    app.register_blueprint(main_bp)

    @app.route('/test/')
    def test_page():
        return '<h1>Testing the Flask Application Factory Pattern</h1>'

    return app
```
Save and close the file.

You import the `bp` blueprint object from the main blueprint and rename it to `main_bp` for readability. Then you use the `app.register_blueprint()` method to register this main blueprint for Flask to treat as part of the application.

With the development server running, navigate to the following URL:

```
http://127.0.0.1:5000/
```

The page will load with the text **This is The Main Blueprint**, which is the text you returned in the main route.

You now have a blueprint with a route in your application. Next, you will edit the main route in the main blueprint to render an HTML template, which will demonstrate how to render templates when working with Flask blueprints.

Open the `routes.py` file of the main blueprint for modification:

```custom_prefix((env)sammy@localhost:$)
nano app/main/routes.py
```

Edit the file with the highlighted lines:

```python
[label flask_app/app/main/routes.py]
from flask import render_template
from app.main import bp

@bp.route('/')
def index():
    return render_template('index.html')
```

Save and close the file.

Here, you import the `render_template()` function and use it in the route to render a template file called `index.html`.

You'll now have to create a templates directory and base template that all other templates will share to avoid code repetition.

Create a templates directory inside your `app` directory:

```custom_prefix((env)sammy@localhost:$)
mkdir app/templates
```

Open a new file called `base.html` to act as the base template:

```custom_prefix((env)sammy@localhost:$)
nano app/templates/base.html
```

Add the following code to the new file:

```html
[label flask_app/app/templates/base.html]
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %} {% endblock %} - FlaskApp</title>
    <style>
        h2 {
            width: 100%;
        }

        .title {
            margin: 5px;
            width: 100%;
        }

        .content {
            margin: 5px;
            width: 100%;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }

        .post {
            flex: 20%;
            padding: 10px;
            margin: 5px;
            background-color: #f3f3f3;
            inline-size: 100%;
        }

        .title a {
            color: #00a36f;
            text-decoration: none;
        }

        nav a {
            color: #d64161;
            font-size: 3em;
            margin-left: 50px;
            text-decoration: none;
        }

    </style>
</head>
<body>
    <nav>
        <a href="{{ url_for('main.index') }}">FlaskApp</a>
        <a href="#">Posts</a>
        <a href="#">Categories</a>
        <a href="#">Questions</a>
    </nav>
    <hr>
    <div class="content">
        {% block content %} {% endblock %}
    </div>
</body>
</html>
```

Save and close the file.

This base template features HTML boilerplate that you will reuse in your other templates.

The base template has a title block, some CSS, a navigation bar to link to different parts of your application, and a content block. For more on base templates, see [How To Use Templates in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application).

You use the syntax `blueprint_name.view_function_name` to link to a route when using the `url_for()` function with blueprints. The index page is handled by the `index()` view function in the main blueprint; therefore, you pass `main.index` to the `url_for()` function to build a link.

Now, create the `index.html` file you rendered in the `index()` view function of the main blueprint:

```custom_prefix((env)sammy@localhost:$)
nano app/templates/index.html
```

Add the following code to the newly created file:

```html
[label flask_app/app/templates/index.html]
{% extends 'base.html' %}

{% block content %}
    <span class="title"><h1>{% block title %} The Home Page of FlaskApp {% endblock %}</h1></span>
    <div class="content">
        <h2>This is the main Flask blueprint</h2>
    </div>
{% endblock %}
```

Save and close the file.

Here, you extend the base template. You replace the content block, using an `<h1>` heading that also serves as a title and an `<h2>` heading to indicate the index page is part of the main Flask blueprint.

With the development server running, visit the index page using your browser or refresh it if it's already open:

```
http://127.0.0.1:5000/
```

A page similar to the following image will load:

![Main Blueprint](https://deved-images.nyc3.digitaloceanspaces.com/CART-68467/Main%20Blueprint.png)

You have now set up a blueprint, added a route to its `routes.py` file, registered it on the application, and rendered templates for it. Next, you'll create another blueprint for blog posts.

### Creating the Posts Blueprint and Rendering its Templates

Now you'll create the blueprint for blog posts, register it, and render its templates.

At this point in the tutorial, your `flask_app` directory structure is as follows (excluding the virtual environment's directory):

```
.
├── flask_app
    ├── app
    │   ├── __init__.py
    │   ├── main
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   └── templates
    │       ├── base.html
    │       └── index.html
    └── config.py
```

To create a new blueprint for blog posts, you'll follow the same steps as in the previous section.

First, create a new `posts` directory to hold the blueprint's files:

```custom_prefix((env)sammy@localhost:$)
mkdir app/posts
```

Next, open a new `__init__.py` file inside the new `posts` directory:

```custom_prefix((env)sammy@localhost:$)
nano app/posts/__init__.py
```

Create a `bp` blueprint object and import the routes that you'll create into the blueprint's `routes.py` file:

```python
[label flask_app/app/posts/__init__.py]
from flask import Blueprint

bp = Blueprint('posts', __name__)


from app.posts import routes
```

Save and close the file.

In the preceding code block, you use `posts` as the blueprint's name. You also import the routes from a `routes.py` file, which you haven't created yet.

Next, open the new `routes.py` file where you'll put the routes for the posts blueprint:

```custom_prefix((env)sammy@localhost:$)
nano app/posts/routes.py
```

Add the following routes to this file:

```python
[label flask_app/app/posts/routes.py]
from flask import render_template
from app.posts import bp

@bp.route('/')
def index():
    return render_template('posts/index.html')

@bp.route('/categories/')
def categories():
    return render_template('posts/categories.html')
```

Save and close the file.

Here, you have two routes: a route for the index page of the posts component of the application and a route for categories, which will be part of the posts component.

In the `index` route, you render a template file with the path `posts/index.html` which means that Flask will look for a directory called `posts` in the `templates` directory and then look for an `index.html` file inside of the `posts` directory.

In the `categories` route, you render a `categories.html` template, which will also be inside a `posts` directory inside the `templates` folder.

Now create the new `posts` directory inside your templates directory:

```custom_prefix((env)sammy@localhost:$)
mkdir app/templates/posts
```

Next, create the new `index.html` file inside the `posts` directory. This is the file you render in the `index()` view function of the posts blueprint:

```custom_prefix((env)sammy@localhost:$)
nano app/templates/posts/index.html
```

Add the following code to the newly created file:

```html
[label flask_app/app/templates/posts/index.html]
{% extends 'base.html' %}

{% block content %}
    <span class="title"><h1>{% block title %} The Posts Page {% endblock %}</h1></span>
    <div class="content">
        <h2>This is the posts Flask blueprint</h2>
    </div>
{% endblock %}
```

Save and close the file.

Here you extend the base template. You also set an `<h1>` heading as a title and an `<h2>` heading to mark the page as part of the posts blueprint.

Next, create a new `categories.html` file inside the `posts` directory. This is the file you rendered in the `categories()` view function of the posts blueprint:

```custom_prefix((env)sammy@localhost:$)
nano app/templates/posts/categories.html
```

Add the following code to the newly created file:

```html
[label flask_app/app/templates/posts/categories.html]
{% extends 'base.html' %}

{% block content %}
    <span class="title"><h1>{% block title %} Categories {% endblock %}</h1></span>
    <div class="content">
        <h2>This is the categories page within the posts blueprint</h2>
    </div>
{% endblock %}
```

Save and close the file.

You extend the base template and set an `<h1>` heading as a title and a `<h2>` heading to mark the page as part of the posts blueprint.

You've created the posts blueprint, added routes, and made the rendered templates. You will now register this blueprint in your factory function for Flask to recognize it as part of the application.

Open the `app/__init__.py` file to edit your factory function:

```custom_prefix((env)sammy@localhost:$)
nano app/__init__.py
```

Edit the `create_app()` factory function by adding the highlighted lines:

```python
[label flask_app/app/__init__.py]

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)

    # Initialize Flask extensions here

    # Register blueprints here
    from app.main import bp as main_bp
    app.register_blueprint(main_bp)

    from app.posts import bp as posts_bp
    app.register_blueprint(posts_bp, url_prefix='/posts')

    @app.route('/test/')
    def test_page():
        return '<h1>Testing the Flask Application Factory Pattern</h1>'

    return app
```

Save and close the file.

Here you imported the `bp` blueprint object from the posts blueprint package and renamed it `posts_bp` for readability.

You register the posts blueprint using the `app.register_blueprint()` method by passing it the `posts_bp` blueprint object. You also pass it a value `'/posts'` for the `url_prefix` parameter, which will prefix the blueprint's routes with this string. For example, the main `/` route of the posts blueprint will become accessible via `/posts/`, and the `/categories` route will be at `/posts/categories/`.

With your new posts blueprint registered and your development server running, use your browser to navigate to the following URLs:

```
http://127.0.0.1:5000/posts/
http://127.0.0.1:5000/posts/categories/
```

The **The Posts Page** heading will load for the `http://127.0.0.1:5000/posts/` page. A **Categories** heading will load for the `http://127.0.0.1:5000/posts/categories/` page.

To make the **Posts** and **Categories** links in the navigation bar functional, open the base template for modification:

```custom_prefix((env)sammy@localhost:$)
nano app/templates/base.html
```

Modify the `<nav>` tag with the highlighted expressions:

```html
[label flask_app/app/templates/base.html]
    <nav>
        <a href="{{ url_for('main.index') }}">FlaskApp</a>
        <a href="{{ url_for('posts.index') }}">Posts</a>
        <a href="{{ url_for('posts.categories') }}">Categories</a>
        <a href="#">Questions</a>
    </nav>
```
Save and close the file.

You link to the posts index with the `url_for('posts.index')` function call and the categories page with `url_for('posts.categories')`.

Refresh any page in your application to enable the **Posts** and **Categories** link functionality.

You now have a posts blueprint registered in your application. Next, you'll add a blueprint for questions and answers.

### Creating the Questions Blueprint and Rendering its Templates

Now you'll create the questions blueprint, register it, and render its templates.

At this point in the tutorial, your `flask_app` directory structure is as follows (excluding the virtual environment's directory):

```
.
├── flask_app
    ├── app
    │   ├── __init__.py
    │   ├── main
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   ├── posts
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   └── templates
    │       ├── base.html
    │       ├── index.html
    │       └── posts
    │           ├── categories.html
    │           └── index.html
    └── config.py
```

To create a new blueprint for questions and answers, create a new `questions` directory to hold the blueprint's files:

```custom_prefix((env)sammy@localhost:$)
mkdir app/questions
```

Next, open a new `__init__.py` file inside the new `questions` directory:

```custom_prefix((env)sammy@localhost:$)
nano app/questions/__init__.py
```

Create a `bp` blueprint object and import the routes that you'll later create in the blueprint's `routes.py` file:

```python
[label flask_app/app/questions/__init__.py]
from flask import Blueprint

bp = Blueprint('questions', __name__)

from app.questions import routes
```

Save and close the file.

In the preceding code block, you use `questions` as the blueprint's name. You also import the routes from a `routes.py` file, which you haven't created yet.

Next, open the new `routes.py` file where you'll put the routes for the questions blueprint:

```custom_prefix((env)sammy@localhost:$)
nano app/questions/routes.py
```

Add the following routes to this file:

```python
[label flask_app/app/questions/routes.py]
from flask import render_template
from app.questions import bp

@bp.route('/')
def index():
    return render_template('questions/index.html')
```

Save and close the file.

You create a `/` route using the `questions` blueprint object, rendering a template file called `index.html` inside a directory called `questions`, which you'll create inside the templates folder.

Create the `questions` directory inside the templates directory, and then open an `index.html` file in it:

```custom_prefix((env)sammy@localhost:$)
mkdir app/templates/questions
nano app/templates/questions/index.html
```

Add the following code to the new file:

```html
[label flask_app/app/templates/questions/index.html]
{% extends 'base.html' %}

{% block content %}
    <span class="title">
        <h1>{% block title %} Questions {% endblock %}</h1>
    </span>
    <div class="questions">
        <h2>Questions Blueprint</h2>
    </div>
{% endblock %}
```

Save and close the file.

Here, you set a title and a subheading, similar to the previous index templates in the other blueprints.

Now open `app/__init__.py` to register the questions blueprint in the `create_app()` factory function:

```custom_prefix((env)sammy@localhost:$)
nano app/__init__.py
```

Edit the `create_app()` factory function by adding the highlighted lines:

```python
[label flask_app/app/__init__.py]

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)

    # Initialize Flask extensions here

    # Register blueprints here
    from app.main import bp as main_bp
    app.register_blueprint(main_bp)

    from app.posts import bp as posts_bp
    app.register_blueprint(posts_bp, url_prefix='/posts')

    from app.questions import bp as questions_bp
    app.register_blueprint(questions_bp, url_prefix='/questions')

    @app.route('/test/')
    def test_page():
        return '<h1>Testing the Flask Application Factory Pattern</h1>'

    return app
```

Save and close the file.

You register the questions blueprint as you did with the posts blueprint, adding a `/questions` prefix to its routes.

With your development server running, use your browser to navigate to the following URL:

```
http://127.0.0.1:5000/questions/
```

The **Questions** and **Questions Blueprint** headings will be displayed on the page.

You will now make the **Questions** link functional. Open the base template to edit the navigation bar:

```custom_prefix((env)sammy@localhost:$)
nano app/templates/base.html
```

Modify the `<nav>` tag with the highlighted expression:

```html
[label flask_app/app/templates/base.html]
    <nav>
        <a href="{{ url_for('main.index') }}">FlaskApp</a>
        <a href="{{ url_for('posts.index') }}">Posts</a>
        <a href="{{ url_for('posts.categories') }}">Categories</a>
        <a href="{{ url_for('questions.index') }}">Questions</a>
    </nav>
```

Save and close the file.

Here, you link to the questions index page using the `url_for('questions.index')` function call.

Refresh any page in your application to enable the **Questions** link functionality in the navigation bar.

You have created several blueprints to manage different components of your application. You registered the blueprints on your factory function and rendered templates for each route. Next, you'll add Flask-SQLAlchemy to your application to manage and organize large databases in your Flask application.

## Step 5 — Adding Flask-SQLAlchemy Models to your Flask Application

In this step, you'll integrate Flask-SQLAlchemy with your application, add a directory for database models, and create a model for posts and one for questions. You'll insert a few blog posts into the posts table, then edit the posts' index route to display all posts in the database. You will also insert a few questions and answers into the questions table to display them on the questions' index page, alongside a new web form for adding further questions and answers to the database.

At this point in the tutorial, your `flask_app` directory structure is as follows (excluding the virtual environment's directory):

```
.
├── flask_app
    ├── app
    │   ├── __init__.py
    │   ├── main
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   ├── posts
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   ├── questions
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   └── templates
    │       ├── base.html
    │       ├── index.html
    │       ├── posts
    │       │   ├── categories.html
    │       │   └── index.html
    │       └── questions
    │           └── index.html
    └── config.py
```

### Creating a File for Managing Flask Extensions and Integrating Flask-SQLAlchemy

To add the Flask-SQLAlchemy extension to your application, you'll first add a Python module called `extensions.py`, in which you'll set up your various Flask extensions, to your `app` directory.

Open a new `extensions.py` file inside your `app` directory:

```custom_prefix((env)sammy@localhost:$)
nano app/extensions.py
```

Add the following code to the newly created file:

```python
[label flask_app/app/extensions.py]
from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()
```

Save and close the file.

Here, you import the `SQLAlchemy()` class from the Flask-SQLAlchemy package, and then you use it to create a `db` database object with no arguments.

You will use this `db` object to integrate SQLAlchemy with the Flask application you construct in your factory function. Open your `app/__init__.py` file to edit the factory function:

```custom_prefix((env)sammy@localhost:$)
nano app/__init__.py
```

Edit the file to import and initialize the database object:

```python
[label flask_app/app/__init__.py]
from flask import Flask

from config import Config
from app.extensions import db

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)

    # Initialize Flask extensions here
    db.init_app(app)

    # Register blueprints here
    from app.main import bp as main_bp
    app.register_blueprint(main_bp)

    from app.posts import bp as posts_bp
    app.register_blueprint(posts_bp, url_prefix='/posts')

    from app.questions import bp as questions_bp
    app.register_blueprint(questions_bp, url_prefix='/questions')

    @app.route('/test/')
    def test_page():
        return '<h1>Testing the Flask Application Factory Pattern</h1>'

    return app
```

Here, you import the `db` database object from the `app.extensions` module you created earlier. Before registering blueprints, you connect the database object to the `app` application instance using the `db.init_app()` method. With this, you can use your `db` object to create and interact with Flask-SQLAlchemy models in your application.

Remember that you've configured Flask-SQLAlchemy using the `Config` object in the `config.py` file inside your `flask_app` directory. You can open this file for a quick reminder:

```custom_prefix((env)sammy@localhost:$)
nano config.py
```

```python
[label flask_app/config.py]
import os

basedir = os.path.abspath(os.path.dirname(__file__))

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY')
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URI')\
        or 'sqlite:///' + os.path.join(basedir, 'app.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
```

If you don't set up a `DATABASE_URI` environment variable, the `db` object will, by default, connect to an SQLite file called `app.db` that will appear in your `flask_app` directory once you create your database tables. Close the file when finished reviewing it.

You can check that the database was registered correctly using the Flask shell. First, with your virtual environment activated, make sure you've set up your Flask environment variables in your `flask_app` directory:

```custom_prefix((env)sammy@localhost:$)
export FLASK_APP=app
export FLASK_ENV=development
```

Open the Flask shell:

```custom_prefix((env)sammy@localhost:$)
flask shell
```

Import the `db` object from the `app.extensions` module, then print it:

```custom_prefix(>>>)
from app.extensions import db
print(db)
```

You'll receive the path of your database, similar to the following:

```
[secondary_label Output]
<SQLAlchemy engine=sqlite:///your_path_to_flask_app/app.db>
```

This output means that the `db` object was properly registered. If you get an error running the code in the Flask shell, ensure you've correctly registered the `db` object in your factory function before moving to the next section. You can exit the Flask shell by typing `exit()`.

### Creating and Interacting with the Post Model

In large applications, you may have hundreds of database tables, which means you would need to write hundreds of SQLAlchemy models to manage them. Putting all your models in one file will make your application hard to maintain, so you will split your models into separate Python files inside a `models` directory. Each file will hold the models and functions related to a specific part of your application. For example, you may put models and functions for managing posts inside a `post.py` file in a directory called `models` in the `app` directory.

At this point in the tutorial, your `flask_app` directory structure is as follows (excluding the virtual environment's directory):

```
.
├── flask_app
    ├── app
    │   ├── extensions.py
    │   ├── __init__.py
    │   ├── main
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   ├── posts
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   ├── questions
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   └── templates
    │       ├── base.html
    │       ├── index.html
    │       ├── posts
    │       │   ├── categories.html
    │       │   └── index.html
    │       └── questions
    │           └── index.html
    └── config.py
```

To create a database model for posts in its own file, first create a directory called `models` inside your `app` directory:

```custom_prefix((env)sammy@localhost:$)
mkdir app/models
```

Then, open a new file called `post.py` inside your models directory:

```custom_prefix((env)sammy@localhost:$)
nano app/models/post.py
```

Add the following code to the newly created file:

```python
[label flask_app/app/models/post.py]
from app.extensions import db

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(150))
    content = db.Column(db.Text)

    def __repr__(self):
        return f'<Post "{self.title}">'
```

Save and close the file.

You import the `db` database object from the `app.extensions` module. Then you create a Flask-SQLAlchemy database model called `Post` using the `db.Model` class. In the model, you have an ID integer column as a primary key (`id`), a column to hold strings for the post title (`title`), and a text column for content (`content`). You use the special `__repr__()` method to provide a string representation for each post object using its title. For more on Flask-SQLAlchemy, you can review [How to Use Flask-SQLAlchemy to Interact with Databases in a Flask Application](https://www.digitalocean.com/community/tutorials/how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application).

Next, open the Flask shell to create the post table based on the post model:

```custom_prefix((env)sammy@localhost:$)
flask shell
```

Run the following code to create the posts table:

```custom_prefix(>>>)
from app.extensions import db
from app.models.post import Post
db.create_all()
```

You import the `db` object from the `app.extensions` module and the `Post` model from the `app.models.post` module. Then you use the `create_all()` method to create the posts table.

The code should execute without an output. If you receive an error, check your `app/extensions.py` and `app/models/post.py` files, and review the previous steps to ensure you have followed them as written.

<$>[note]
**Note:** The `db.create_all()` function does not recreate or update a table if it already exists. For example, if you want to modify your model by adding a new column and so you run the `db.create_all()` function, the change you make to the model will not be applied to the table if the table already exists in the database. The solution is to delete all existing database tables with the `db.drop_all()` function and then recreate them with the `db.create_all()` function like so:

```custom_prefix(>>>)
db.drop_all()
db.create_all()
```

These commands will apply the modifications you make to your models and will delete all the existing data in the database. To update the database and preserve existing data, you'll need to use [_schema migration_](https://en.wikipedia.org/wiki/Schema_migration), which allows you to modify your tables and preserve data. You can use the [Flask-Migrate](https://flask-migrate.readthedocs.io/en/latest/index.html) extension to perform SQLAlchemy schema migrations through the Flask command-line interface.
<$>

Next, run the following code to create ten random posts:

```custom_prefix(>>>)
import random

for i in range(0, 10):
    random_num = random.randrange(1, 1000)
    post = Post(title=f'Post #{random_num}',
                content=f'Content #{random_num}')
    db.session.add(post)
    print(post)
    print(post.content)
    print('--')
    db.session.commit()
```

You import the `db` database object, the `Post` database model, and the [`random`](https://docs.python.org/3/library/random.html) Python module. You'll use this module to generate random numbers to create sample posts with different titles and contents. You use a `for` loop with the `range()` Python function to repeat a code block ten times.

In the `for` loop, you use the [`random.randrange()`](https://docs.python.org/3/library/random.html#random.randrange) method to generate a random integer number between `1` and `1000` and save it to a variable called `random_num`. You then create a post object using the `Post` model and use the random number in the `random_num` variable to generate a sample post title and content.

You then add the post object to the database session, print the object itself and its content, and commit the transaction.

You'll receive an output similar to the following but with different numbers:

```
[secondary_label Output]
<Post "Post #58">
Content #58
--
<Post "Post #55">
Content #55
--
<Post "Post #994">
Content #994
--
<Post "Post #394">
Content #394
--
<Post "Post #183">
Content #183
--
<Post "Post #633">
Content #633
--
<Post "Post #790">
Content #790
--
<Post "Post #883">
Content #883
--
<Post "Post #259">
Content #259
--
<Post "Post #581">
Content #581
--
```

Each post has a randomly generated number attached to it. These posts will now be in your database.

Leave the Flask shell running and open a new terminal window. Source your environment and navigate to your application folder.

Now that you have some sample posts in your table, you can display them on the posts' index page. First, open the posts routes file to modify the index route:

```custom_prefix((env)sammy@localhost:$)
nano app/posts/routes.py
```

Edit the imports and the index route by adding the highlighted lines:

```python
[label flask_app/app/posts/routes.py]
from flask import render_template
from app.posts import bp
from app.extensions import db
from app.models.post import Post


@bp.route('/')
def index():
    posts = Post.query.all()
    return render_template('posts/index.html', posts=posts)
```

Save and close the file.

You import the `db` database object and the `Post` model. You get all the posts in the database and then pass them to the posts' index template.

Open the posts' index template for modification to display the posts you passed to it:

```custom_prefix((env)sammy@localhost:$)
nano app/templates/posts/index.html
```

Edit the file by adding the highlighted lines:

```html
[label flask_app/app/templates/posts/index.html]
{% extends 'base.html' %}

{% block content %}
    <span class="title"><h1>{% block title %} The Posts Page {% endblock %}</h1></span>
    <div class="content">
        <h2>This is the posts Flask blueprint</h2>
        {% for post in posts %}
            <div class="post">
                <p><b>#{{ post.id }}</b></p>
                <p class="title">
                    <b>
                        <a href="#">
                            {{ post.title }}
                        </a>
                    </b>
                </p>
                <div class="content">
                    <p>{{ post.content }}</p>
                </div>
                <hr>
            </div>
        {% endfor %}
    </div>
{% endblock %}
```

Save and close the file.

Here, you loop through posts and display each post's ID, title, and content.

With the development server running, visit the posts' index page or refresh it if you have it open:

```
http://127.0.0.1:5000/posts/
```

The sample posts you've generated will be displayed on the index page, similar to the following image:

![The Posts Page](https://deved-images.nyc3.digitaloceanspaces.com/CART-68467/The%20Posts%20Page.png)

You now have a database model for posts. You can now add features to your application with new routes and templates, such as creating, editing, and deleting posts.

### Creating and Interacting with the Question Model

You've created a posts model and interacted with it in your posts blueprint. You will now add the questions database model for managing questions and answers.

At this point in the tutorial, your `flask_app` directory structure is as follows (excluding the virtual environment's directory):

```
.
├── flask_app
    ├── app
    │   ├── extensions.py
    │   ├── __init__.py
    │   ├── main
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   ├── models
    │   │   └── post.py
    │   ├── posts
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   ├── questions
    │   │   ├── __init__.py
    │   │   └── routes.py
    │   └── templates
    │       ├── base.html
    │       ├── index.html
    │       ├── posts
    │       │   ├── categories.html
    │       │   └── index.html
    │       └── questions
    │           └── index.html
    ├── app.db
    └── config.py
```

To create a questions database model, open a new file called `question.py` inside your models directory:

```custom_prefix((env)sammy@localhost:$)
nano app/models/question.py
```

Add the following code:

```python
[label flask_app/app/models/question.py]
from app.extensions import db

class Question(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text)
    answer = db.Column(db.Text)

    def __repr__(self):
        return f'<Question {self.content}>'
```

Save and close the file.

Here, you import the `db` database object from the `app.extensions` module. Then you create a model called `Question` using the `db.Model` class. In the model, you have an ID integer column as a primary key (`id`), a text column for the question's content (`content`), and a text column for its answer (`answer`). Then you use the special `__repr__()` method to represent each question using its content.

In the terminal session that is running the Flask shell, run the following code to create the questions table based on the questions model:

```custom_prefix((env)sammy@localhost:$)
flask shell
```

Run the following code to create the questions table and add a few questions and answers to it:

```custom_prefix(>>>)
from app.extensions import db
from app.models.question import Question
db.create_all()

q1 = Question(content='Why is the sky blue?', answer='Because... Why not?')
q2 = Question(content='What is love?', answer='A portal to the underworld.')
db.session.add_all([q1, q2])
db.session.commit()
```

The code should execute without an output. If you receive an error, check your `app/models/question.py` file to ensure your code is written with the correct syntax.

You import the database object and the questions model, then use `db.create_all()` to create the table, and finally you add two question objects to the database session and commit the transaction.

Exit the Flask shell:

```custom_prefix((env)sammy@localhost:$)
exit()
```

You can now interact with the new questions model in your questions blueprint. To do so, open the questions blueprint's `routes.py` file for a modification to query and display the questions you have in your questions table:

```custom_prefix(sammy@localhost:$)
nano app/questions/routes.py
```

Edit the file by adding the highlighted lines:

```python
[label flask_app/app/questions/routes.py]
from flask import render_template
from app.questions import bp
from app.models.question import Question

@bp.route('/')
def index():
    questions = Question.query.all()
    return render_template('questions/index.html', questions=questions)
```

Save and close the file.

Here, you import the questions model, get all the questions in the database, and then pass them to the questions' index template.

Next, you'll display the questions you passed to the questions' index template and add a web form to allow users to add new questions. Open the `index.html` file in the questions' template directory:

```custom_prefix((env)sammy@localhost:$)
nano app/templates/questions/index.html
```

Edit the file by adding the highlighted lines:

```html
[label flask_app/app/templates/questions/index.html]
{% extends 'base.html' %}

{% block content %}
    <span class="title">
        <h1>{% block title %} Questions {% endblock %}</h1>
    </span>
    <div class="questions">
        <h2>Questions Blueprint</h2>

        <div class="question">
            <div class="new-question">
                <form method="POST">
                    <p>
                        <textarea id="q-content"
                                name="content"
                                placeholder="Question"
                                cols="30" rows="3"></textarea>
                    </p>
                    <textarea id="q-answer"
                            name="answer"
                            placeholder="Answer"
                            cols="30" rows="3"></textarea>
                    <p><input type="submit"></p>
                </form>
            </div>
            <div class="questions-list">
                {% for question in questions %}
                    <div class="question">
                        <h4>{{ question.content }}</h4>
                        <p>{{ question.answer }}</p>
                        <hr>
                    </div>
                {% endfor %}
            </div>
        </div>

    </div>
{% endblock %}
```

Save and close the file.

Here, you create a form with two text areas: one for the question's content and one for its answer. Then you add a submit button for the form.

Below the form, you loop through the `questions` variable you passed from the questions' index route, displaying each question's content and answer.

With your development server running, use your browser to navigate to the questions index page:

```
http://127.0.0.1:5000/questions/
```

The page will load with the blueprint heading, the submission form, and two sample questions:

![Questions Index](https://deved-images.nyc3.digitaloceanspaces.com/CART-68467/Questions%20Index.png)

However, filling in and submitting the form will result in a `405 Method Not Allowed` HTTP error because the form sends a `POST` request to the questions' index route, but the route does not accept nor handle `POST` requests. To resolve this issue and make the form functional, you'll modify the index route of the questions blueprint and use the form data to add new questions to the database. 

Open the questions blueprint's `routes.py` file:

```custom_prefix((env)sammy@localhost:$)
nano app/questions/routes.py
```

Edit the file by adding the highlighted lines:

```python
[label flask_app/app/questions/routes.py]
from flask import render_template, request, url_for, redirect
from app.questions import bp
from app.models.question import Question
from app.extensions import db

@bp.route('/', methods=('GET', 'POST'))
def index():
    questions = Question.query.all()

    if request.method == 'POST':
        new_question = Question(content=request.form['content'],
                                answer=request.form['answer'])
        db.session.add(new_question)
        db.session.commit()
        return redirect(url_for('questions.index'))

    return render_template('questions/index.html', questions=questions)
```

Save and close the file.

You allow the `GET` and `POST` methods by passing the `('GET', 'POST')` tuple to the `methods` parameter. You handle `POST` requests in the `if request.method == 'POST':` condition. In it, you create a new question object using the content and answer the user submits, which you get from the `request.form` object. You add the new question to the database session, commit the transaction, and then redirect the user to the questions index page.

The form will now work, and you can add new questions and answers to your database. You can test this functionality at the `http://127.0.0.1:5000/questions/` URL.

You have integrated Flask-SQLAlchemy with your application, adding a directory for models to organize your code.

You can compare your final files against the code held in [the DigitalOcean community repository](https://github.com/adyouri/large-flask-app-template).

## Conclusion

You've structured a large Flask application using blueprints and organized it with templates and models. You set it up so that each component has its own routes, templates, and models.

The example web application now has three major components that can be expanded upon in different ways:

- The main blueprint: You can add an about page or a contact page for users to contact the application owner.

- The posts blueprint: You can add pages for creating, editing, deleting, and sorting posts. You can also add tags to posts using a [Many-to-Many database relationship with Flask-SQLAlchemy](https://www.digitalocean.com/community/tutorials/how-to-use-many-to-many-database-relationships-with-flask-sqlalchemy).

- The questions blueprint: You can add pages for managing questions and use a [One-to-Many database relationship with Flask-SQLAlchemy](https://www.digitalocean.com/community/tutorials/how-to-use-one-to-many-database-relationships-with-flask-sqlalchemy) to create another table for answers so that a question can have multiple solutions.

You can also add more blueprints for features such as authentication, payments, administration, and more.

If you want to read more about Flask, check out the other tutorials in the [How To Build Web Applications with Flask](https://www.digitalocean.com/community/tutorial_series/how-to-create-web-sites-with-flask) series.

